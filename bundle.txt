FILE_BEGIN info.json
{
  "type": "Standard",
  "core" : false,
  "name": "Autofit",
  "icon": "/workdir/projects/C++/PluginAutoFit/icons/bochtje50.png",
  "description": "Vind buizen en bochten",
  "authors": [
    {
      "name": "Richard Rombouts",
      "email": "rf.rombouts@gmail.com"
    }
  ],
  "maintainers": [
    {
      "name": "Richard Rombouts",
      "email": "rf.rombouts@gmail.com"
    }
  ],
  "references": [
  ]
}
FILE_END
FILE_BEGIN CMakeGUI.json
{
    "compiler": "clang",
    "build_type": "Debug",
    "output_type": "Shared Library",
    "use_wx_widgets": false,
    "use_opengl": false,
    "extra_flags": ""
}
FILE_END
FILE_BEGIN pack_to_jbf_tar.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys

EXCLUDE_DIRS = {"__pycache__", "build", "icons", "images"}

def should_include(d):
    return (
        not d.startswith('.') and
        d not in EXCLUDE_DIRS
    )

def pack_dir(root_dir: str, out_path: str):
    root_dir = os.path.abspath(root_dir)
    with open(out_path, "w", encoding="utf-8", newline="\n") as out:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # directories filteren
            dirnames[:] = [d for d in dirnames if should_include(d)]

            for fname in filenames:
                full_path = os.path.join(dirpath, fname)
                rel_path = os.path.relpath(full_path, root_dir)

                try:
                    with open(full_path, "r", encoding="utf-8") as f:
                        content = f.read()
                except UnicodeDecodeError:
                    # binaire files overslaan
                    continue

                out.write(f"FILE_BEGIN {rel_path}\n")
                out.write(content.rstrip("\n") + "\n")
                out.write("FILE_END\n")

    print(f"‚úÖ JBF-bundle geschreven naar: {out_path}")

def main():
    if len(sys.argv) != 3:
        print("Gebruik:")
        print(f"  python3 {sys.argv[0]} <root_dir> <bundle.txt>")
        print("\nVoorbeeld:")
        print(f"  python3 {sys.argv[0]} ./chatGPT project_bundle.txt")
        sys.exit(1)

    root_dir = sys.argv[1]
    out_path = sys.argv[2]

    if not os.path.isdir(root_dir):
        print(f"‚ùå Directory bestaat niet: {root_dir}")
        sys.exit(1)

    pack_dir(root_dir, out_path)

if __name__ == "__main__":
    main()
FILE_END
FILE_BEGIN CMakeLists.txt
cmake_minimum_required(VERSION 3.16)
project(PluginAutoFit C CXX)

# --------------------------------------
# Compilerinstellingen
# --------------------------------------
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Waarschuwingsniveaus
add_compile_options(
    -Wall
    -Wno-unused-parameter
    -Wno-old-style-cast
    -Wno-sign-conversion
    -Wno-shadow
    -Wno-deprecated-declarations
    -Wno-conversion
    -Wno-missing-field-initializers
    -Wno-reorder
    -Wno-switch
    -fpermissive
)

# --------------------------------------
# Paden
# --------------------------------------
set(CC_SRC_ROOT "/workdir/projects/C++/CloudCompare")
set(CC_BUILD_DIR "${CC_SRC_ROOT}/build/debug")

# --------------------------------------
# Qt MOC configuratie
# --------------------------------------
set(Qt5_MOC_EXECUTABLE "/usr/lib/qt5/bin/moc")
if(NOT EXISTS "${Qt5_MOC_EXECUTABLE}")
    message(FATAL_ERROR "moc not found at: ${Qt5_MOC_EXECUTABLE}")
endif()

set(MOC_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/moc/moc_autofit.cpp)
file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/moc)

# MOC generatie commando
add_custom_command(
    OUTPUT ${MOC_OUTPUT}
    COMMAND ${Qt5_MOC_EXECUTABLE}
        -I${CC_SRC_ROOT}/libs/CCPluginStub/include
        -I${CMAKE_CURRENT_SOURCE_DIR}/include
        ${CMAKE_CURRENT_SOURCE_DIR}/include/autofit.h
        -o ${MOC_OUTPUT}
    DEPENDS include/autofit.h
    VERBATIM
    COMMENT "Generating moc file with plugin interface support"
)

# --------------------------------------
# Bestanden verzamelen
# --------------------------------------
file(GLOB SOURCE_FILES "src/*.cpp")
file(GLOB HEADER_FILES "include/*.h")

# --------------------------------------
# Libraries zoeken
# --------------------------------------
add_library(${PROJECT_NAME} MODULE
    ${SOURCE_FILES}
    ${HEADER_FILES}
    ${MOC_OUTPUT}
)

# Expliciet compileren voor debugging met maximale informatie en zonder optimalisaties
target_compile_options(${PROJECT_NAME} PRIVATE $<$<CONFIG:Debug>:
  -fno-inline
  -fno-limit-debug-info
  -fno-omit-frame-pointer
  -fstandalone-debug
  -g
  -gdwarf-5
  -O0
> )

# --------------------------------------
# Includes
# --------------------------------------
target_include_directories(${PROJECT_NAME} SYSTEM PRIVATE
    include
    ${CC_SRC_ROOT}/libs
    ${CC_SRC_ROOT}/libs/qCC_db/include
    ${CC_SRC_ROOT}/libs/CCPluginAPI/include
    ${CC_SRC_ROOT}/libs/CCPluginStub/include
    ${CC_SRC_ROOT}/libs/qCC_db/extern/CCCoreLib/include
    ${CC_SRC_ROOT}/libs/qCC_glWindow/include
    ${CC_SRC_ROOT}/build/debug/libs/qCC_db/extern/CCCoreLib/exports
    ${CC_SRC_ROOT}/libs/CCCoreLib/include
    ${Qt5_INCLUDE_DIRS}
)

# --------------------------------------
# Compile definities
# --------------------------------------
target_compile_definitions(${PROJECT_NAME} PRIVATE 
    QT_PLUGIN
    QCC_PLUGIN_NAME=\"${PROJECT_NAME}\"
    CC_PLUGIN_TYPE_STD
)

# --------------------------------------
# Target properties
# --------------------------------------
set_target_properties(${PROJECT_NAME} PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/plugins"
    PREFIX "libQ"
    AUTOMOC OFF
)

# --------------------------------------
# Link met Qt en CC libs
# --------------------------------------
find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets)

# Twee centrale zoekpaden
set(CC_MAIN_LIB_DIR "${CC_SRC_ROOT}/install/release/lib/cloudcompare")
set(CC_PLUGINS_DIR "${CC_MAIN_LIB_DIR}/plugins")

# Directe linking zonder zoekopdrachten
target_link_libraries(${PROJECT_NAME} PRIVATE
    Qt5::Core
    Qt5::Gui
    Qt5::Widgets
    "${CC_MAIN_LIB_DIR}/libCCCoreLib.so"
    "${CC_MAIN_LIB_DIR}/libQCC_DB_LIB.so"
    "${CC_PLUGINS_DIR}/libQCORE_IO_PLUGIN.so"
)

# --------------------------------------
# Installatie
# --------------------------------------
install(TARGETS ${PROJECT_NAME} 
    LIBRARY DESTINATION "lib/cloudcompare/plugins"
)
FILE_END
FILE_BEGIN clangfmt.sh
#!/bin/bash
clang-format -i include/*.h* src/*.c*
FILE_END
FILE_BEGIN .gitignore
# ============================================
# BUILD DIRECTORY: we sluiten alles uit behalve moc/ en daarbinnen .cpp en .h
# ============================================
/build/*
!/build/moc/
/build/moc/*
!/build/moc/*.cpp
!/build/moc/*.h

# ============================================
# ANDERE DIRECTORIES DIE WE UITSLUITEN
# ============================================
/bin/
/lib/
/test_moc/
/.cache/
/CMakeFiles/

# ============================================
# CMAKE GENERATED FILES
# ============================================
CMakeCache.txt
cmake_install.cmake
CMakeGUI.json
compile_commands.json
build.ninja
.ninja_deps
.ninja_log

# ============================================
# COMPILED BINARIES & OBJECT FILES
# ============================================
*.o
*.obj
*.so
*.so.*
*.dylib
*.dll
*.exe
*.out
*.app

# ============================================
# QT CONFIGURATIE FILES (geen source)
# ============================================
*.moc
*.qrc.d
.qmake.stash

# ============================================
# DEBUG FILES
# ============================================
*.pdb
*.idb
*.su

# ============================================
# TEMPORARY FILES
# ============================================
*~           # Editor backup files
*.tmp
*.temp
*.swp
*.swo

# ============================================
# IDE CONFIGURATIES
# ============================================
/.vscode/
/.idea/

# ============================================
# PLATFORM SPECIFIEK
# ============================================
.DS_Store
Thumbs.db

# ============================================
# LOG FILES
# ============================================
*.log
cmake_build.log

# ============================================
# PROJECT SPECIFIEK uitsluiten
# ============================================
/images/
FILE_END
FILE_BEGIN sanity_checks.txt
# Linux:
nm -D libPluginAutoFit.so | grep Bocari
# Windows:
dumpbin /EXPORTS PluginAutoFit.dll | findstr Bocari

strings myplugin.so | grep Bocari. 

Voer MOC handmatig uit (voor testing):
/usr/lib/qt5/bin/moc myheader.h -o moc_myheader.cpp


Controleer: Of AUTOMOC de header met Q_PLUGIN_METADATA daadwerkelijk verwerkt:
bash

ls build/moc_*.cpp  # Zoek naar gegenereerde MOC-bestanden
/workdir/projects/C++/CloudCompare/plugins/core/Standard

===
glxinfo | grep "renderer"

Je wilt:

OpenGL renderer string: NVIDIA GeForce RTX 4070/PCIe/SSE2
Op de host:

xhost +local:root
xhost +si:localuser:developer  # indien nodig

Of gebruik xhost + tijdelijk om alle lokale toegang toe te staan (niet persistent/veilig).


===
/workdir/projects/C++/CloudCompare/release/install/bin/CloudCompare

/opt/occt-7.9.1
/opt/occt-7.9.1/install
/usr/local/E57Format-3.2-x86_64-gcc13/lib
/usr/local/E57Format-3.2-x86_64-linux-gnu
/opt/libE57Format

/usr/bin/ld: cannot find -lcc_plugin_std: No such file or directory
/usr/bin/ld: cannot find -lqCC_db: No such file or directory
/usr/bin/ld: cannot find -lCCCoreLib: No such file or directory

find /workdir \
     /opt/glm \
     /opt/tmp \
     /opt/occt-7.9.1 \
     /opt/occt-7.9.1/install \
     /usr/local/E57Format-3.2-x86_64-gcc13 \
     /opt/libE57Format \
     -type f \( -iname "*plugin*.so" -o -iname "*qcc_db*.so" -o -iname "*corelib*so" \)

Controleer runtime dependencies met ldd

ldd path/to/cc_PluginAutoFit.so

Deze output toont of de .so afhankelijk is van andere libraries (zoals libCCPluginAPI.so, libQCC_DB_LIB.so, enz.), en of die gevonden worden.

    Als je lijnen ziet met => not found, dan mist een dependency of staat de lib niet in je LD_LIBRARY_PATH.

    Voorbeeld output:

libCCPluginAPI.so => /workdir/projects/.../libCCPluginAPI.so (0x00007f...)
libQCC_DB_LIB.so => not found

===
readelf -d path/to/cc_PluginAutoFit.so | grep NEEDED
Als je libCCPluginAPI.so niet in deze lijst ziet staan, dan is het niet gelinkt, en moet je je CMakeLists.txt aanpassen.


QPluginLoader
does not seem to be a valid plugin or it is not supported by this version

/workdir/projects/C++/CloudCompare/libs/CCAppCommon/src/ccPluginManager.cpp
53, 77, 312, 326, 337, 341

fileName "libQCORE_IO_PLUGIN.so" 
 path  "/workdir/projects/C++/CloudCompare/debug/install/lib/cloudcompare/plugins/libQCORE_IO_PLUGIN.so" 
IID  "cccorp.cloudcompare.plugin.qCoreIO" 
metaDataValid true
+++

 QObject *plugin = loader->instance();
QObject::connect(QAction, Autofit): invalid nullptr parameter


nvidia-smi --query-gpu=driver_version --format=csv,noheader && dpkg -l | grep nvidia-575
# Toon versie en ondersteunde schema's:
docker-compose version --short && docker version --format '{{.Client.Version}}'

host:
~$ sudo apt-mark hold libnvidia-compute-575 libnvidia-gl-575
[sudo] password for richard: 
libnvidia-compute-575 set on hold.
libnvidia-gl-575 set on hold.
richard@Nerd:~$ nvidia-smi --query-gpu=driver_version --format=csv,noheader && dpkg -l | grep nvidia-575
575.57.08
ii  xserver-xorg-video-nvidia-575            575.57.08-0ubuntu1                       amd64        NVIDIA binary Xorg driver
richard@Nerd:~$ docker-compose version --short && docker version --format '{{.Client.Version}}'
Command 'docker-compose' not found, but can be installed with:
sudo snap install docker          # version 28.1.1+1, or
sudo apt  install docker-compose  # version 1.29.2-6.3
See 'snap info docker' for additional versions.
richard@Nerd:~$ 


Ik wil helemaal geen swarm
$ # Check Docker versie
docker-compose version
docker version

# Test GPU-toegang
docker compose run --rm cloud nvidia-smi
Command 'docker-compose' not found, but can be installed with:
snap install docker          # version 28.1.1+1, or
apt  install docker-compose  # version 1.29.2-6.3
See 'snap info docker' for additional versions.
Client:
 Version:           26.1.3
 API version:       1.45
 Go version:        go1.22.8
 Git commit:        26.1.3-0ubuntu1.1
 Built:             Thu Dec 12 08:27:10 2024
 OS/Arch:           linux/amd64
 Context:           default

Server:
 Engine:
  Version:          26.1.3
  API version:      1.45 (minimum version 1.24)
  Go version:       go1.22.8
  Git commit:       26.1.3-0ubuntu1.1
  Built:            Thu Dec 12 08:27:10 2024
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          2.0.0~rc3
  GitCommit:        
 runc:
  Version:          1.1.12-0ubuntu4
  GitCommit:        
 docker-init:
  Version:          0.19.0
  GitCommit:        
no configuration file provided: not found
developer@Nerd:/usr/lib/x86_64-linux-gnu$ 

wear leveling
FILE_END
FILE_BEGIN bundle.txt
FILE_BEGIN info.json
{
  "type": "Standard",
  "core" : false,
  "name": "Autofit",
  "icon": "/workdir/projects/C++/PluginAutoFit/icons/bochtje50.png",
  "description": "Vind buizen en bochten",
  "authors": [
    {
      "name": "Richard Rombouts",
      "email": "rf.rombouts@gmail.com"
    }
  ],
  "maintainers": [
    {
      "name": "Richard Rombouts",
      "email": "rf.rombouts@gmail.com"
    }
  ],
  "references": [
  ]
}
FILE_END
FILE_BEGIN CMakeGUI.json
{
    "compiler": "clang",
    "build_type": "Debug",
    "output_type": "Shared Library",
    "use_wx_widgets": false,
    "use_opengl": false,
    "extra_flags": ""
}
FILE_END
FILE_BEGIN pack_to_jbf_tar.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys

EXCLUDE_DIRS = {"__pycache__", "build", "icons", "images"}

def should_include(d):
    return (
        not d.startswith('.') and
        d not in EXCLUDE_DIRS
    )

def pack_dir(root_dir: str, out_path: str):
    root_dir = os.path.abspath(root_dir)
    with open(out_path, "w", encoding="utf-8", newline="\n") as out:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # directories filteren
            dirnames[:] = [d for d in dirnames if should_include(d)]

            for fname in filenames:
                full_path = os.path.join(dirpath, fname)
                rel_path = os.path.relpath(full_path, root_dir)

                try:
                    with open(full_path, "r", encoding="utf-8") as f:
                        content = f.read()
                except UnicodeDecodeError:
                    # binaire files overslaan
                    continue

                out.write(f"FILE_BEGIN {rel_path}\n")
                out.write(content.rstrip("\n") + "\n")
                out.write("FILE_END\n")

    print(f"‚úÖ JBF-bundle geschreven naar: {out_path}")

def main():
    if len(sys.argv) != 3:
        print("Gebruik:")
        print(f"  python3 {sys.argv[0]} <root_dir> <bundle.txt>")
        print("\nVoorbeeld:")
        print(f"  python3 {sys.argv[0]} ./chatGPT project_bundle.txt")
        sys.exit(1)

    root_dir = sys.argv[1]
    out_path = sys.argv[2]

    if not os.path.isdir(root_dir):
        print(f"‚ùå Directory bestaat niet: {root_dir}")
        sys.exit(1)

    pack_dir(root_dir, out_path)

if __name__ == "__main__":
    main()
FILE_END
FILE_BEGIN CMakeLists.txt
cmake_minimum_required(VERSION 3.16)
project(PluginAutoFit C CXX)

# --------------------------------------
# Compilerinstellingen
# --------------------------------------
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Waarschuwingsniveaus
add_compile_options(
    -Wall
    -Wno-unused-parameter
    -Wno-old-style-cast
    -Wno-sign-conversion
    -Wno-shadow
    -Wno-deprecated-declarations
    -Wno-conversion
    -Wno-missing-field-initializers
    -Wno-reorder
    -Wno-switch
    -fpermissive
)

# --------------------------------------
# Paden
# --------------------------------------
set(CC_SRC_ROOT "/workdir/projects/C++/CloudCompare")
set(CC_BUILD_DIR "${CC_SRC_ROOT}/build/debug")

# --------------------------------------
# Qt MOC configuratie
# --------------------------------------
set(Qt5_MOC_EXECUTABLE "/usr/lib/qt5/bin/moc")
if(NOT EXISTS "${Qt5_MOC_EXECUTABLE}")
    message(FATAL_ERROR "moc not found at: ${Qt5_MOC_EXECUTABLE}")
endif()

set(MOC_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/moc/moc_autofit.cpp)
file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/moc)

# MOC generatie commando
add_custom_command(
    OUTPUT ${MOC_OUTPUT}
    COMMAND ${Qt5_MOC_EXECUTABLE}
        -I${CC_SRC_ROOT}/libs/CCPluginStub/include
        -I${CMAKE_CURRENT_SOURCE_DIR}/include
        ${CMAKE_CURRENT_SOURCE_DIR}/include/autofit.h
        -o ${MOC_OUTPUT}
    DEPENDS include/autofit.h
    VERBATIM
    COMMENT "Generating moc file with plugin interface support"
)

# --------------------------------------
# Bestanden verzamelen
# --------------------------------------
file(GLOB SOURCE_FILES "src/*.cpp")
file(GLOB HEADER_FILES "include/*.h")

# --------------------------------------
# Libraries zoeken
# --------------------------------------
add_library(${PROJECT_NAME} MODULE
    ${SOURCE_FILES}
    ${HEADER_FILES}
    ${MOC_OUTPUT}
)

# Expliciet compileren voor debugging met maximale informatie en zonder optimalisaties
target_compile_options(${PROJECT_NAME} PRIVATE $<$<CONFIG:Debug>:
  -fno-inline
  -fno-limit-debug-info
  -fno-omit-frame-pointer
  -fstandalone-debug
  -g
  -gdwarf-5
  -O0
> )

# --------------------------------------
# Includes
# --------------------------------------
target_include_directories(${PROJECT_NAME} SYSTEM PRIVATE
    include
    ${CC_SRC_ROOT}/libs
    ${CC_SRC_ROOT}/libs/qCC_db/include
    ${CC_SRC_ROOT}/libs/CCPluginAPI/include
    ${CC_SRC_ROOT}/libs/CCPluginStub/include
    ${CC_SRC_ROOT}/libs/qCC_db/extern/CCCoreLib/include
    ${CC_SRC_ROOT}/libs/qCC_glWindow/include
    ${CC_SRC_ROOT}/build/debug/libs/qCC_db/extern/CCCoreLib/exports
    ${CC_SRC_ROOT}/libs/CCCoreLib/include
    ${Qt5_INCLUDE_DIRS}
)

# --------------------------------------
# Compile definities
# --------------------------------------
target_compile_definitions(${PROJECT_NAME} PRIVATE 
    QT_PLUGIN
    QCC_PLUGIN_NAME=\"${PROJECT_NAME}\"
    CC_PLUGIN_TYPE_STD
)

# --------------------------------------
# Target properties
# --------------------------------------
set_target_properties(${PROJECT_NAME} PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/plugins"
    PREFIX "libQ"
    AUTOMOC OFF
)

# --------------------------------------
# Link met Qt en CC libs
# --------------------------------------
find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets)

# Twee centrale zoekpaden
set(CC_MAIN_LIB_DIR "${CC_SRC_ROOT}/install/release/lib/cloudcompare")
set(CC_PLUGINS_DIR "${CC_MAIN_LIB_DIR}/plugins")

# Directe linking zonder zoekopdrachten
target_link_libraries(${PROJECT_NAME} PRIVATE
    Qt5::Core
    Qt5::Gui
    Qt5::Widgets
    "${CC_MAIN_LIB_DIR}/libCCCoreLib.so"
    "${CC_MAIN_LIB_DIR}/libQCC_DB_LIB.so"
    "${CC_PLUGINS_DIR}/libQCORE_IO_PLUGIN.so"
)

# --------------------------------------
# Installatie
# --------------------------------------
install(TARGETS ${PROJECT_NAME} 
    LIBRARY DESTINATION "lib/cloudcompare/plugins"
)
FILE_END
FILE_BEGIN clangfmt.sh
#!/bin/bash
clang-format -i include/*.h* src/*.c*
FILE_END
FILE_BEGIN .gitignore
# ============================================
# BUILD DIRECTORY: we sluiten alles uit behalve moc/ en daarbinnen .cpp en .h
# ============================================
/build/*
!/build/moc/
/build/moc/*
!/build/moc/*.cpp
!/build/moc/*.h

# ============================================
# ANDERE DIRECTORIES DIE WE UITSLUITEN
# ============================================
/bin/
/lib/
/test_moc/
/.cache/
/CMakeFiles/

# ============================================
# CMAKE GENERATED FILES
# ============================================
CMakeCache.txt
cmake_install.cmake
CMakeGUI.json
compile_commands.json
build.ninja
.ninja_deps
.ninja_log

# ============================================
# COMPILED BINARIES & OBJECT FILES
# ============================================
*.o
*.obj
*.so
*.so.*
*.dylib
*.dll
*.exe
*.out
*.app

# ============================================
# QT CONFIGURATIE FILES (geen source)
# ============================================
*.moc
*.qrc.d
.qmake.stash

# ============================================
# DEBUG FILES
# ============================================
*.pdb
*.idb
*.su

# ============================================
# TEMPORARY FILES
# ============================================
*~           # Editor backup files
*.tmp
*.temp
*.swp
*.swo

# ============================================
# IDE CONFIGURATIES
# ============================================
/.vscode/
/.idea/

# ============================================
# PLATFORM SPECIFIEK
# ============================================
.DS_Store
Thumbs.db

# ============================================
# LOG FILES
# ============================================
*.log
cmake_build.log

# ============================================
# PROJECT SPECIFIEK uitsluiten
# ============================================
/images/
FILE_END
FILE_BEGIN chatGPT/splitter4.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import os
import sys

def strip_outer_fence(text):
    """
    Verwijder exact √©√©n outer ``` fence als die het hele document omsluit.
    (Markdown copy-button probleem oplossen)
    """
    lines = text.splitlines()

    if len(lines) >= 2 and lines[0].strip() == "```" and lines[-1].strip() == "```":
        return "\n".join(lines[1:-1])
    return text


def split_bundle(bundle_text):
    """
    Splitst FILE_BEGIN/FILE_END of <file></file>
    in losse bestanden, zonder ooit inhoud te wijzigen.
    """

    pattern = re.compile(
        r'(?:FILE_BEGIN\s+([^\s]+)|<file\s+path="([^"]+)">)\s*(.*?)\s*(?:FILE_END|</file>)',
        re.DOTALL
    )

    matches = list(pattern.finditer(bundle_text))

    if not matches:
        print("‚ùå Geen file-blokken gevonden. Controleer bundel.\n")
        return

    format_used = "FILE_BEGIN/FILE_END" if "FILE_BEGIN" in bundle_text else "<file></file>"
    print(f"‚úÖ {len(matches)} bestanden gevonden ({format_used}-formaat)")

    for m in matches:
        file_path = m.group(1) or m.group(2)
        content = m.group(3)

        if not file_path:
            print("‚ö†Ô∏è Blok zonder bestandsnaam overgeslagen.")
            continue

        directory = os.path.dirname(file_path)
        if directory and not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)
            print(f"üìÅ map aangemaakt: {directory}")

        with open(file_path, "w", encoding="utf-8", newline="\n") as f:
            # Schrijf EXACTE inhoud, geen strip of md fix
            f.write(content.rstrip("\n") + "\n")

        print(f"‚úîÔ∏è schreef: {file_path}")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Gebruik: python3 splitter_raw.py bundle.txt")
        sys.exit(1)

    with open(sys.argv[1], "r", encoding="utf-8") as f:
        text = f.read()

    text = strip_outer_fence(text)
    split_bundle(text)
FILE_END
FILE_BEGIN chatGPT/README.txt
Autofit GPU - JBF pipeline (NL identifiers)

Bouwen zonder CMake:
chmod +x nv
./nv

Inprikken in CloudCompare:

* Koppel h_do_optimize_frame3.cpp aan jouw plugin bronbestand waar AutofitImpl::doOptimizeFrame3() leeft.
* Roep h_do_optimize_frame3(...) aan met CCVector3/ccPointCloud adapter (zie include/cc_adapter.h).

Directory-indeling:
include/
config.h                ‚Üê globale drempels/constanten (EPS_NEAR2, TAU_FAR2, R_MIN, R_MAX, SECTORS_HALF, enz.)
types.h                 ‚Üê basis types/labels/AxisPermutatie
device_buffer.cuh       ‚Üê DeviceBuffer<T> (alloc/kopie/resize)
morton_utils.cuh        ‚Üê 64-bit Morton encode/decode + region-prefix
cc_adapter.h            ‚Üê dunne adapter naar CloudCompare types (pas include-pad aan)
src/
h_do_optimize_frame3.cpp‚Üê host-sturing (JBF flow) ‚Äî roept kernels (worden in part02+ geleverd)
k_voxeliseer_morton.cu  ‚Üê quantize ‚Üí morton keys ‚Üí CUB radixsort ‚Üí permute floats (komt in part02)
k_ruis_boeren.cu        ‚Üê 2-burenfilter (komt in part02)
k_vlak_vote.cu          ‚Üê zaad triangle ‚Üí lokale support ‚Üí richting-stem (komt in part02)
k_buis_vote.cu          ‚Üê annulus/wedge voor buisrichting (komt in part03)
k_reduce_groepen.cu     ‚Üê reduce-by-key voor (richting-keys) (komt in part03)
k_planair_regressie.cu  ‚Üê JBF u*/v* regressie ‚Üí n* (komt in part03)
k_rotatie_quat.cu       ‚Üê roteren naar ideaal frame (komt in part04)
k_fine_slabs_cyl.cu     ‚Üê fine labeling na frame (komt in part04)

Buildscript:
nv  (nvcc, sm_89, C++20, extended-lambda)

Let op taalafspraken:

* NL identifiers & comments
* Uitzonderingen toegestaan: seed, triangle, tree, forest, vote, count, slab
* Kernels: prefix k_
* Device helpers: d_
* Host helpers: h_

Volgorde van werken:

1. ./nv bouwen
2. Integreer cc_adapter.h include-pad
3. Start met h_do_optimize_frame3.cpp (logt elke stap); kernels volgen in part02/03/04.
FILE_END
FILE_BEGIN chatGPT/c.txt
FILE_BEGIN include/otndc.h
#pragma once
#include <cuda_runtime.h>
#include <stdint.h>

// === Resultaat voor hoofdassen ===
struct AssenResultaat {
    float v[3][3];   // 3 assen (unit)
    float score[3];  // sterkte per as (aantal gewogen stemmen)
    int   dimensie;  // 1D/2D/3D (hier: 1 of 2 of 3 als we later uitbreiden)
};

// === Config (OTNDC) ===
// Namen NL; geen magic numbers.
struct OTConfig {
    // Boeren-ring (ruisfilter)
    float binnenStraal2;   // min ring (kwadraat)
    float buitenStraal2;   // max ring (kwadraat)

    // Paar-acceptatie (orthogonaliteit)
    // Voor "hoek >= 20¬∞" gebruiken we |dot| <= cos(70¬∞) ~= 0.342.
    float maxDotOrtho;     // max |dot(n1,n2)| om kruispaar toe te laten (bv 0.34)

    // Warmup/minimum
    int   warmupMin;       // minimum stemmen om een richting te houden (host-reduce)

    // Kernel/block
    int   blokGrootte;     // threads per blok (bv 256)
    int   partnerZoekRadius; // max offset in tile om partner te zoeken (bv 32)
};

// Interne slot-accu voor as-samples (globaal).
struct OTAsAccu {
    float3 som;    // vectorsom van a-samples
    int    count;  // aantal (gewogen) stemmen
};

// Run via paren ‚Üí schat een top-as richting (v[0])
// x/y/z: arrays met punten (getransleerde cloud: stralen ‚âà p/|p|)
// N: aantal punten
// out: vult v[0], score[0], dimensie (>=1 als er steun is)
void runOTNDC_pairs(
    const float* x, const float* y, const float* z, int N,
    AssenResultaat* out,
    const OTConfig& cfg);


FILE_END

FILE_BEGIN src/k_pairs_bucket.cu


#include <cuda_runtime.h>
#include <math_constants.h>
#include "otndc.h"

// ============ device helpers ============
__device__ __forceinline__ float3 make3(float x,float y,float z){return make_float3(x,y,z);}
__device__ __forceinline__ float  dot3(float3 a,float3 b){return a.x*b.x+a.y*b.y+a.z*b.z;}
__device__ __forceinline__ float3 cross3(float3 a,float3 b){
    return make3( a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x );
}
__device__ __forceinline__ float3 norm3(float3 v){
    float n2 = v.x*v.x + v.y*v.y + v.z*v.z;
    if(n2 < 1e-20f) return make3(0,0,0);
    float inv = rsqrtf(n2);
    return make3(v.x*inv, v.y*inv, v.z*inv);
}

// ============ kernel ============
// Per punt -> straal (v). In gedeeld geheugen een tile.
// Voor elk v: zoek binnen +- partnerZoekRadius in de tile 1 partner u
// met |dot(v,u)| <= maxDotOrtho; kies de beste (kleinste |dot|).
// Voeg a = normalize(cross(v,u)) bij aan globale accumulator met gewicht sin(theta).
extern "C" __global__
void k_otndc_pairs(
    const float* __restrict__ x,
    const float* __restrict__ y,
    const float* __restrict__ z,
    int N,
    float binnen2, float buiten2,
    float maxDotOrtho,
    int partnerZoekRadius,
    OTAsAccu* __restrict__ gAccu)
{
    extern __shared__ float sMem[]; // layout: vx[], vy[], vz[]
    float* sx = sMem;
    float* sy = sx + blockDim.x;
    float* sz = sy + blockDim.x;

    const int gid  = blockIdx.x * blockDim.x + threadIdx.x;

    // Laad tile stralen (met ringfilter)
    float3 v = make3(0,0,0);
    if(gid < N){
        float3 p = make3(x[gid], y[gid], z[gid]);
        float r2 = dot3(p,p);
        if(r2 >= binnen2 && r2 <= buiten2) {
            v = norm3(p); // straal = genormaliseerde plaatsvector
        }
    }
    sx[threadIdx.x] = v.x;
    sy[threadIdx.x] = v.y;
    sz[threadIdx.x] = v.z;
    __syncthreads();

    // Zoek √©√©n partner in de tile
    if(gid >= N) return;
    if(v.x==0.f && v.y==0.f && v.z==0.f) return; // buiten ring

    float bestAbsDot = 1e9f;
    float3 bestU = make3(0,0,0);

    // Zoek rondom huidige thread (beperkt venster)
    const int t = threadIdx.x;
    const int L = max(0, t - partnerZoekRadius);
    const int R = min(blockDim.x-1, t + partnerZoekRadius);

    for(int j=L; j<=R; ++j){
        if(j==t) continue;
        float3 u = make3(sx[j], sy[j], sz[j]);
        if(u.x==0.f && u.y==0.f && u.z==0.f) continue;

        float d = fabsf(dot3(v,u)); // |cos theta|
        if(d <= maxDotOrtho && d < bestAbsDot){
            bestAbsDot = d;
            bestU = u;
        }
    }

    if(bestAbsDot==1e9f) return; // geen geschikte partner

    // Kruisproduct ‚Üí as-sample
    float3 a = cross3(v, bestU);
    float a2 = dot3(a,a);
    if(a2 < 1e-20f) return;
    float inv = rsqrtf(a2);
    a.x *= inv; a.y *= inv; a.z *= inv;

    // Gewicht: sin(theta) = sqrt(1 - cos^2)
    float w = sqrtf( fmaxf(0.f, 1.f - bestAbsDot*bestAbsDot) );

    // Atomics naar globale accu
    atomicAdd(&gAccu->som.x, a.x * w);
    atomicAdd(&gAccu->som.y, a.y * w);
    atomicAdd(&gAccu->som.z, a.z * w);
    atomicAdd(&gAccu->count, 1);
}


FILE_END

FILE_BEGIN src/h_axis_fit.cu


#include <cuda_runtime.h>
#include <algorithm>
#include <vector>
#include <cmath>
#include <iostream>

#include "otndc.h"

// small helper
static inline void cudaCheck(cudaError_t e, const char* msg){
    if(e!=cudaSuccess){
        std::cerr<<"CUDA fout: "<<msg<<": "<<cudaGetErrorString(e)<<"\n";
        std::abort();
    }
}
static inline float3 make3(float x,float y,float z){return make_float3(x,y,z);}

extern "C" void k_otndc_pairs(
    const float*, const float*, const float*, int,
    float, float, float, int, OTAsAccu*);

void runOTNDC_pairs(
    const float* x,const float* y,const float* z,int N,
    AssenResultaat* out,const OTConfig& cfg)
{
    // Globale accumulator
    OTAsAccu* dAccu = nullptr;
    cudaCheck(cudaMalloc(&dAccu, sizeof(OTAsAccu)), "malloc dAccu");
    cudaCheck(cudaMemset(dAccu, 0, sizeof(OTAsAccu)), "memset dAccu");

    // Kernelconfig
    const int B = (cfg.blokGrootte>0? cfg.blokGrootte:256);
    const int G = (N + B - 1)/B;
    const size_t shmem = 3 * B * sizeof(float); // sx,sy,sz

    // Launch
    k_otndc_pairs<<<G, B, shmem>>>(
        x,y,z,N,
        cfg.binnenStraal2, cfg.buitenStraal2,
        cfg.maxDotOrtho,
        cfg.partnerZoekRadius,
        dAccu);
    cudaCheck(cudaGetLastError(), "launch k_otndc_pairs");
    cudaCheck(cudaDeviceSynchronize(), "sync k_otndc_pairs");

    // Host reduce
    OTAsAccu hAccu{};
    cudaCheck(cudaMemcpy(&hAccu, dAccu, sizeof(OTAsAccu), cudaMemcpyDeviceToHost), "cpy accu");
    cudaCheck(cudaFree(dAccu), "free accu");

    // Normeer richting
    float len = std::sqrt(hAccu.som.x*hAccu.som.x + hAccu.som.y*hAccu.som.y + hAccu.som.z*hAccu.som.z);
    int dim = 0;
    if(hAccu.count >= cfg.warmupMin && len > 1e-8f){
        out->v[0][0] = hAccu.som.x / len;
        out->v[0][1] = hAccu.som.y / len;
        out->v[0][2] = hAccu.som.z / len;
        out->score[0] = static_cast<float>(hAccu.count);
        dim = 1;
    }
    out->dimensie = dim;

    // (Slots 2 en 3 blijven leeg in deze fase)
    for(int i=1;i<3;i++){ out->v[i][0]=out->v[i][1]=out->v[i][2]=0.f; out->score[i]=0.f; }
}


FILE_END

FILE_BEGIN src/demo_axis2.cpp


#include "otndc.h"
#include <vector>
#include <iostream>
#include <cmath>
#include <random>

// Synthetische test: cilinder rond X-as (asrichting moet ~ (1,0,0) worden).
int main(){
    const int turns = 2000;     // aantal "ringen" langs x
    const float lengte = 5.0f;  // 5 m
    const float r = 0.10f;      // 10 cm
    const float sigma = 0.003f; // 3 mm jitter
    const int perRing = 256;    // punten per ring

    const int N = turns * perRing;
    std::vector<float> x(N), y(N), z(N);

    std::mt19937 rng(42);
    std::normal_distribution<float> noise(0.0f, sigma);

    for(int i=0;i<turns;i++){
        float t = (float)i/(turns-1);
        float X = -lengte*0.5f + t * lengte;
        for(int k=0;k<perRing;k++){
            float ang = (2.0f*float(M_PI))* (float)k / (float)perRing;
            int idx = i*perRing + k;
            x[idx] = X + noise(rng)*0.1f; // klein
            y[idx] = r*std::cos(ang) + noise(rng);
            z[idx] = r*std::sin(ang) + noise(rng);
        }
    }

    OTConfig cfg{};
    // Ring (we gebruiken hele cloud; zet ring ruim open zodat alles meedoet)
    cfg.binnenStraal2 = 0.0f;
    cfg.buitenStraal2 = (lengte*lengte + 4*r*r)*2.0f; // ruime bovengrens

    // Orthogonaliteit (>=~20¬∞): |dot| <= cos(70¬∞) ‚âà 0.342
    cfg.maxDotOrtho = 0.35f;

    cfg.warmupMin = 100;     // min stemmen om richting te accepteren
    cfg.blokGrootte = 256;
    cfg.partnerZoekRadius = 32;

    AssenResultaat out{};
    runOTNDC_pairs(x.data(), y.data(), z.data(), N, &out, cfg);

    std::cout<<"Dimensie: "<<out.dimensie<<"\n";
    if(out.dimensie>=1){
        std::cout<<"As 0: "<<out.v[0][0]<<","<<out.v[0][1]<<","<<out.v[0][2]
                 <<"  score="<<out.score[0]<<"\n";
    }
    return 0;
}


FILE_END
FILE_END
FILE_BEGIN chatGPT/splitter3.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import os
import sys

def split_bundle(bundle_text):
    """
    Splitst de gebundelde XML-achtige of FILE_BEGIN/FILE_END tekst in afzonderlijke bestanden.
    Ondersteunt beide formaten automatisch.
    """

    # Regex: match FILE_BEGIN or <file>, same for end
    pattern = re.compile(
        r'(?:FILE_BEGIN\s+([^\s]+)|<file\s+path="([^"]+)">)\s*(.*?)\s*(?:FILE_END|</file>)',
        re.DOTALL
    )

    matches = list(pattern.finditer(bundle_text))

    if not matches:
        print("‚ùå Geen file-blokken gevonden (<file ...> of FILE_BEGIN ...). Controleer het bestand.\n")
        return

    # Detecteer welk type gebruikt is
    if "FILE_BEGIN" in bundle_text:
        format_used = "FILE_BEGIN/FILE_END"
    else:
        format_used = "<file></file>"

    print(f"‚úÖ {len(matches)} bestanden gevonden ({format_used}-formaat), start uitpakken‚Ä¶")

    for m in matches:
        file_path = m.group(1) or m.group(2)
        content   = m.group(3)

        if not file_path:
            print("‚ö†Ô∏è  blok zonder bestandsnaam overgeslagen")
            continue

        # Map aanmaken indien nodig
        directory = os.path.dirname(file_path)
        if directory and not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)
            print(f"üìÅ map aangemaakt: {directory}")

        # Wegschrijven (UTF-8, Unix line endings)
        try:
            with open(file_path, "w", encoding="utf-8", newline="\n") as f:
                f.write(content.strip() + "\n")
            print(f"‚úîÔ∏è  schreef: {file_path}")
        except Exception as e:
            print(f"‚ùå fout bij schrijven {file_path}: {e}")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Gebruik:")
        print(f"  python3 {sys.argv[0]} bundle.txt\n")
        sys.exit(1)

    bundle = sys.argv[1]

    try:
        with open(bundle, "r", encoding="utf-8") as f:
            text = f.read()
    except Exception as e:
        print(f"‚ùå kan bundle niet lezen: {e}")
        sys.exit(1)

    split_bundle(text)
    print("\nüéâ Splitsing voltooid.")
FILE_END
FILE_BEGIN chatGPT/nv
#!/usr/bin/env bash
set -euo pipefail

ARCH=sm_89
__host__=/usr/bin/g++
CUDA=/usr/local/cuda/bin/nvcc

INC="-Iinclude -I/usr/local/cuda/include"
SRC="src/h_do_optimize_frame3.cpp 
src/k_voxeliseer_morton.cu 
src/k_ruis_boeren.cu 
src/k_vlak_vote.cu 
src/k_buis_vote.cu 
src/k_reduce_groepen.cu 
src/k_planair_regressie.cu 
src/k_rotatie_quat.cu 
src/k_fine_slabs_cyl.cu"

# Tijdens deel 1 ontbreken sommige .cu: compileer wat er is (ignore missing)

FILTERED_SRC=""
for f in $SRC; do
if [ -f "$f" ]; then FILTERED_SRC+="$f "; fi
done

OUT="autofit_gpu"

echo "[nv] Bouwen met nvcc ($ARCH) ..."
$CUDA 
-arch=${ARCH} 
-ccbin=${__host__} 
-std=c++20 
--extended-lambda 
--relaxed-constexpr 
-Xcompiler "-O2 -fPIC" 
$INC 
$FILTERED_SRC 
-o ${OUT}

echo "‚úÖ Klaar: ./${OUT}"
FILE_END
FILE_BEGIN chatGPT/docs/README_PARTS.txt
# GPU-autofit ‚Äî Part 08

Deze part voegt toe:

* `include/axis_permutatie.h` (as-permutatie host, NL identifiers).
* Integratie merge/split:

  * `h_merge_xyz_naar_vec3()` v√≥√≥r de pipeline,
  * `h_split_vec3_naar_xyz()` na labeling/rotatie.
* Update van `h_do_optimize_frame3.cpp` met duidelijke statusregels (S0 happy path):

  1. CC cloud ‚Üí host x/y/z
  2. as-permutatie zodat Vx ‚â• Vy ‚â• Vz
  3. upload d_x/d_y/d_z ‚Üí merge naar d_pts
  4. morton sort ‚Üí boeren ruisfilter
  5. vlak-check huidig frame; zonodig brute planes; zonodig brute buizen
  6. quaternion-rotatie naar ideaal frame
  7. fine slabs + simpele cilinderlabel in ideaal frame
  8. split vec3‚Üíx/y/z ‚Üí download ‚Üí terug-permuteer namen

Build:

```
bash scripts/build_nv.sh
```

Volgende parts:

* Vervang placeholder `maak_quat_naar_ideaal_frame()` door jouw mat‚Üíquat logica (consistent met `k_rotatie_quat.cu`).
* Werk S1 (langzame, algemene aanpak) verder in h_orchestratie en h_vlak_vote/h_buis_vote.
FILE_END
FILE_BEGIN chatGPT/docs/README_BDRM.txt
GPU-Autofit ‚Äî Boeren-richtingstralenmethode (BDRM)
==================================================

## Doel

Betrouwbare hoofdassen vinden in een pointcloud zonder SVD/PCA:
‚Äì geen hemisfeer-binning
‚Äì geen full sort per richting
‚Äì JBF (simpel, robuust, snel)

## Kernidee

‚Ä¢ Raakvlak-normaal van buizen staat loodrecht op de as.
‚Ä¢ Transleer alle ‚Äústralen‚Äù conceptueel naar O (we gebruiken alleen richting).
‚Ä¢ Cluster die richtingen met een LRU per block en voeg in warm-up enkele kruisproducten toe.
‚Ä¢ Vlakken stemmen direct hun normaal; buizen induceren via kruisen de asrichting.

## Pipeline (vroege fase)

1. k_r1r2_filter
   ‚Äì Zoek 2 dichtste buren in ring [r1..r2]
   ‚Äì Exclusieve driehoek check: max(|c-a|,|c-b|) ‚â§ r2/2 ‚àí 1mm
   ‚Äì Normaal van mini-triangle + slab-inliers tellen
   ‚Äì Chaos = geen tri & weinig slab-inliers

2. k_local_slab_test
   ‚Äì Markeer ok_for_vote (geen chaos) ‚Äî vlak en ‚Äúcurved‚Äù mogen beiden stemmen

3. k_direction_vote_bdrm
   ‚Äì LRU per block (K=8)
   ‚Äì Stem op n
   ‚Äì Warm-up: kruisen met top-slots als ~orthogonaal ‚Üí voeg ontbrekende assen toe
   ‚Äì E√©n bubble-swap per update (geen dure sort)
   ‚Äì Output: top M winners per block ‚Üí host combineert tot A*,B*,C*

## Labels

‚Ä¢ In deze fase worden labels alleen ge√Ønitialiseerd (Ruis).
‚Ä¢ Na frame-lock volgt fine slab/cylinder labeling in ideaal frame (volgende stap).

## Build

./scripts/build_nv.sh

## Bestanden

include/consts.cuh             ‚Äì toleranties
include/types.cuh              ‚Äì Vec3f, PuntType
include/device_buffer.cuh      ‚Äì eenvoudige device buffer
include/bdrm_lru.cuh           ‚Äì LRU per block
src/k_r1r2_filter.cu           ‚Äì ring + tri + slab inliers
src/k_local_slab_test.cu       ‚Äì ok_for_vote
src/k_direction_vote_bdrm.cu   ‚Äì LRU stemmen + warm-up kruisen
src/k_label_sort.cu            ‚Äì presentatie sort (na labeling)
src/h_do_optimize_frame2.cpp   ‚Äì host flow en meldingen
FILE_END
FILE_BEGIN chatGPT/scripts/build_nv.sh
#!/usr/bin/env bash
set -e
nvcc -std=c++17 -O3 -arch=sm_80 \
  -Iinclude \
  src/k_r1r2_filter.cu \
  src/k_local_slab_test.cu \
  src/k_direction_vote_bdrm.cu \
  src/k_label_sort.cu \
  src/h_do_optimize_frame2.cpp \
  -o build/autofit_demo
echo "Build OK ‚Üí build/autofit_demo"
FILE_END
FILE_BEGIN chatGPT/scripts/compute_sha256.sh
#!/usr/bin/env bash
set -euo pipefail
find src include scripts docs -type f -print0 | xargs -0 sha256sum
FILE_END
FILE_BEGIN chatGPT/tools/split_and_verify.py
#!/usr/bin/env python3
import sys, re, os, hashlib, argparse, pathlib

TAG_RE = re.compile(r'<file path="([^"]+)">\n?(.*?)
FILE_END
FILE_BEGIN chatGPT/include/wiskunde_utils.cuh
#pragma once
#include <algorithm>
#include <cmath>

struct Vec3f
{
    float x, y, z;
};
struct Quat
{
    float w, x, y, z;
};

__host__ __device__ inline Vec3f normalize(const Vec3f& v)
{
    float n = std::sqrt(v.x * v.x + v.y * v.y + v.z * v.z) + 1e-20f;
    return {v.x / n, v.y / n, v.z / n};
}
__host__ __device__ inline float dot(const Vec3f& a, const Vec3f& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__host__ __device__ inline Vec3f cross(const Vec3f& a, const Vec3f& b)
{
    return {a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x};
}

// Welford: gemiddelde & M2 (variance som) voor streaming cosines
struct Welford
{
    int   n    = 0;
    float mean = 0.f;
    float M2   = 0.f;

    __host__ __device__ inline void add(float x)
    {
        n++;
        float delta = x - mean;
        mean += delta / float(n);
        float delta2 = x - mean;
        M2 += delta * delta2;
    }
    __host__ __device__ inline float variance() const { return (n & gt; 1) ? (M2 / float(n - 1)) : 0.f; }
    __host__ __device__ inline float sigma() const
    {
        float v = variance();
        return v & gt;
        0.f ? std::sqrt(v) : 0.f;
    }
};

// Exponential moving average op een normalerichting
struct EmaNormaal
{
    Vec3f n     = {0, 0, 1};
    bool  init  = false;
    float alpha = 0.2f;

    __host__ __device__ inline void setAlpha(float a) { alpha = a; }

    __host__ __device__ inline void add(const Vec3f& amp; m)
    {
        if(!init)
        {
            n    = normalize(m);
            init = true;
            return;
        }
        // lineaire mix gevolgd door normaliseren
        Vec3f mix{(1 - alpha) * n.x + alpha * m.x, (1 - alpha) * n.y + alpha * m.y, (1 - alpha) * n.z + alpha * m.z};
        n = normalize(mix);
    }
};

// Quaternion helpers
inline Quat quat_from_axis_angle(const Vec3f& axis, float rad)
{
    Vec3f a = normalize(axis);
    float s = std::sin(rad * 0.5f);
    return {std::cos(rad * 0.5f), a.x * s, a.y * s, a.z * s};
}
inline Vec3f quat_rotate(const Quat& q, const Vec3f& v)
{
    // v' = q * (0,v) * q^{-1}
    Vec3f u{q.x, q.y, q.z};
    float s   = q.w;
    Vec3f uv  = cross(u, v);
    Vec3f uuv = cross(u, uv);
    Vec3f out{v.x + 2.0f * (s * uv.x + uuv.x), v.y + 2.0f * (s * uv.y + uuv.y), v.z + 2.0f * (s * uv.z + uuv.z)};
    return out;
}
inline Quat quat_mul(const Quat& a, const Quat& b)
{
    return {a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z, a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x, a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w};
}

// Decompose quaternion naar Z-rotatie (yaw) vervolgens Y-rotatie (pitch).
// Doel: twee as-rotaties kunnen printen in graden (CloudCompare UI check).
inline void quat_to_ZY_angles(const Quat& q, float& yawDeg, float& pitchDeg)
{
    // Converteer naar rotatiematrix en haal ZY-Euler (yaw-pitch, geen roll).
    // r = Rz(yaw)*Ry(pitch)
    float ww = q.w * q.w, xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;
    float xy = q.x * q.y, xz = q.x * q.z, yz = q.y * q.z, wx = q.w * q.x, wy = q.w * q.y, wz = q.w * q.z;

    float r00 = ww + xx - yy - zz;
    float r01 = 2 * (xy - wz);
    float r02 = 2 * (xz + wy);

    float r10 = 2 * (xy + wz);
    float r11 = ww - xx + yy - zz;
    float r12 = 2 * (yz - wx);

    float r20 = 2 * (xz - wy);
    float r21 = 2 * (yz + wx);
    float r22 = ww - xx - yy + zz;

    // ZY-extract
    float pitch = std::asin(std::clamp(-r20, -1.0f, 1.0f)); // Ry
    float yaw   = std::atan2(r10, r00);                     // Rz

    yawDeg   = yaw * 180.0f / float(M_PI);
    pitchDeg = pitch * 180.0f / float(M_PI);
}

// Clip kleine correcties (|graad| < clip) naar 0
inline void clip_small_degrees(float clipDeg, float& deg)
{
    if(std::fabs(deg) < clipDeg) deg = 0.f;
}
FILE_END
FILE_BEGIN chatGPT/include/otndc.h
#pragma once
#include <cuda_runtime.h>
#include <stdint.h>

// === Resultaat voor hoofdassen ===
struct AssenResultaat {
    float v[3][3];   // 3 assen (unit)
    float score[3];  // sterkte per as (aantal gewogen stemmen)
    int   dimensie;  // 1D/2D/3D (hier: 1 of 2 of 3 als we later uitbreiden)
};

// === Config (OTNDC) ===
// Namen NL; geen magic numbers.
struct OTConfig {
    // Boeren-ring (ruisfilter)
    float binnenStraal2;   // min ring (kwadraat)
    float buitenStraal2;   // max ring (kwadraat)

    // Paar-acceptatie (orthogonaliteit)
    // Voor "hoek >= 20¬∞" gebruiken we |dot| <= cos(70¬∞) ~= 0.342.
    float maxDotOrtho;     // max |dot(n1,n2)| om kruispaar toe te laten (bv 0.34)

    // Warmup/minimum
    int   warmupMin;       // minimum stemmen om een richting te houden (__host__-reduce)

    // Kernel/block
    int   blokGrootte;     // threads per blok (bv 256)
    int   partnerZoekRadius; // max offset in tile om partner te zoeken (bv 32)
};

// Interne slot-accu voor as-samples (globaal).
struct OTAsAccu {
    float3 som;    // vectorsom van a-samples
    int    count;  // aantal (gewogen) stemmen
};

// Run via paren ‚Üí schat een top-as richting (v[0])
// x/y/z: arrays met punten (getransleerde cloud: stralen ‚âà p/|p|)
// N: aantal punten
// out: vult v[0], score[0], dimensie (>=1 als er steun is)
void runOTNDC_pairs(
    const float* x, const float* y, const float* z, int N,
    AssenResultaat* out,
    const OTConfig& cfg);
FILE_END
FILE_BEGIN chatGPT/include/morton_utils.cuh
#pragma once
#include "config.h"
#include "types.h"
#include <cstdint>

// 21 bits per as in 64-bit (theoretisch), we reserveren bovenste REGIO_PREFIX_BITS voor regio
// Layout: [ regio R bits ][ morton XYZ (interleave LSB-first) ]
// Bits per as (effectief): bepaal uit VOXEL_MIDDEN_BITS en beschikbare restbits.

__host__ __device__ inline u64 part1by2(u64 x)
{
    x &= 0x1fffffULL; // 21 bits
    x = (x | (x << 32)) & 0x1f00000000ffffULL;
    x = (x | (x << 16)) & 0x1f0000ff0000ffULL;
    x = (x | (x << 8)) & 0x100f00f00f00f00fULL;
    x = (x | (x << 4)) & 0x10c30c30c30c30c3ULL;
    x = (x | (x << 2)) & 0x1249249249249249ULL;
    return x;
}

__host__ __device__ inline u64 morton3D(u32 x, u32 y, u32 z)
{
    return part1by2(x) | (part1by2(y) << 1) | (part1by2(z) << 2);
}

struct Kwantisatie
{
    Vec3f bbMin;
    float schaal; // meters ‚Üí ints (globaal, aspect behouden)
};

__host__ __device__ inline u32 clampu32(u64 v) { return (v > 0xffffffffULL) ? 0xffffffffu : (u32)v; }

// Maak morton sleutel met regio-prefix (R MSB‚Äôs)
__host__ __device__ inline u64 morton_met_regio(u32 xi, u32 yi, u32 zi, u32 regioCode)
{
    u64 m = morton3D(xi, yi, zi);
    return (((u64)regioCode) << (64 - REGIO_PREFIX_BITS)) | (m & (~0ULL >> REGIO_PREFIX_BITS));
}

// Eenvoudige kwantisatie float3 ‚Üí ints (assume alles al naar [0,MAX_RANGE_METERS))
__host__ __device__ inline void kwantiseer_punt(const Vec3f& p, const Kwantisatie& Q, u32& xi, u32& yi, u32& zi)
{
    float X = (p.x - Q.bbMin.x) * Q.schaal;
    float Y = (p.y - Q.bbMin.y) * Q.schaal;
    float Z = (p.z - Q.bbMin.z) * Q.schaal;
    // round-to-nearest-even kan via lrintf, hier JBF: +0.5f en floor
    auto q = [](float v) -> u32 {
        float t = v + 0.5f;
        if(t < 0.f) t = 0.f;
        u64 w = (u64)(t);
        return clampu32(w);
    };
    xi = q(X);
    yi = q(Y);
    zi = q(Z);
}
FILE_END
FILE_BEGIN chatGPT/include/orchestratie.h
#pragma once
#include <vector>
#include <string>
#include "types.cuh"

struct AxisPermutatie {
// __host__ arrays (na permutatie)
std::vector<float> x;
std::vector<float> y;
std::vector<float> z;
char naamX='x', naamY='y', naamZ='z'; // oorspronkelijke namen
uint32_t Vx=0, Vy=0, Vz=0;            // #voxels per as (voor morton)
};

struct OrchestratieResultaat {
// hoofdrichtingen (na stemmen; niet-orthonormaal)
float3 richtA=make_float3(0,0,1);
float3 richtB=make_float3(1,0,0);
float3 richtC=make_float3(0,1,0);
bool   frameGevonden=false;
};

void doOptimizeFrame2(/* CloudCompare hook: m_selectedCloud etc. worden intern opgehaald */);

// helpers (ge√´xporteerd voor tests)
AxisPermutatie h_bereken_en_permuteer(const std::vector<float>& X,
const std::vector<float>& Y,
const std::vector<float>& Z,
float3 bbMin, float3 bbMax);
FILE_END
FILE_BEGIN chatGPT/include/merge_split.cuh
#pragma once
#include "types.cuh"

// ====== Doel ======
// __host__ levert drie afzonderlijke arrays (x[], y[], z[]) in "nieuwe as-volgorde"
// (na AxisPermutatie op de __host__).
// GPU merge't naar √©√©n Vec3f-buffer voor kernels die coalesced 3D willen.
// Later kan GPU weer splitten naar (x[],y[],z[]) zodat __host__ makkelijk terug-permuteert.

// Merge: (x,y,z) ‚Üí Vec3f
void h_merge_xyz_naar_vec3(const DeviceBuffer<float>& d_x, const DeviceBuffer<float>& d_y,
                           const DeviceBuffer<float>& d_z, DeviceBuffer<Vec3f>& d_pts);

// Split: Vec3f ‚Üí (x,y,z)
void h_split_vec3_naar_xyz(const DeviceBuffer<Vec3f>& d_pts, DeviceBuffer<float>& d_x, DeviceBuffer<float>& d_y,
                           DeviceBuffer<float>& d_z);

// ====== Helpers voor AxisPermutatie ======
// Bouw __host__zijde AxisPermutatie-array vanuit drie kolommen (x,y,z) die al
// hernoemd/gepermutateerd zijn.
inline void h_axis_permutatie_vul(AxisPermutatie (&ap)[3], const float* nieuwX, const float* nieuwY,
                                  const float* nieuwZ, char naamX, char naamY, char naamZ, uint32_t Vx, uint32_t Vy,
                                  uint32_t Vz)
{
    ap[0] = AxisPermutatie{nieuwX, naamX, Vx};
    ap[1] = AxisPermutatie{nieuwY, naamY, Vy};
    ap[2] = AxisPermutatie{nieuwZ, naamZ, Vz};
    // Volgorde ap[0]=X, ap[1]=Y, ap[2]=Z is wat GPU verwacht.
}
FILE_END
FILE_BEGIN chatGPT/include/types.cuh
#pragma once
#include <cstdint>

struct Vec3f
{
    float x, y, z;
};

enum class PuntType : uint8_t { Ruis = 0, Vlak = 1, Buis = 2, Bocht = 3, TStuk = 4, Kruis = 5, Verloop = 6 };

// SoA labels (GPU-vriendelijk)
struct LabelSoA
{
    uint8_t*  d_type = nullptr; // PuntType
    uint32_t* d_id   = nullptr; // cluster/object id
    size_t    n      = 0;
};
FILE_END
FILE_BEGIN chatGPT/include/config.h
#pragma once
#include <cstdint>

namespace cfg {

// Globale schakelaars voor richting-stemmen
struct RichtingStemmen {
// banden op cosine(|cos(theta)|); near strakker dan ok
float bandNearCos   = 0.985f;   // ~10¬∞ ‚Üí 0.9848
float bandOkCos     = 0.940f;   // ~20¬∞ ‚Üí 0.9397
float minNearOkRatio = 0.70f;   // ok telt mee als near/ok ‚â• 0.70


// gewichten (vlak zwaarder dan buis)
float vlakStraalGewicht = 1.00f;
float buisStraalGewicht = 0.55f;

// warmup & evict
int   warmupMinSamples = 200;
int   maxSlots         = 12;     // initieel veel
int   targetSlots      = 3;      // na evict naar 3 (1..3)
float evictRatio       = 5.0f;   // evict als score[i]*5 < maxScore

// EMA nudge
float emaAlphaVlak   = 0.25f;
float emaAlphaBuis   = 0.12f;

// Clipjes
float maxLockGraads  = 6.0f;     // reject als groter dan dit
float clipKleinGraads= 2.0f;     // kleine correcties negeren als < 2¬∞


};

// Voor later: buis/vlak specifieke tolerantievelden
struct VlakToleranties {
float slabEps = 0.010f;  // 10 mm
};

struct BuisToleranties {
float rMin   = 0.025f;   // 25 mm
float rMax   = 0.500f;   // 500 mm
};

struct Config {
RichtingStemmen stemmen;
VlakToleranties vlak;
BuisToleranties buis;
};

inline const Config& get() {
static Config C;
return C;
}

} // namespace cfg
FILE_END
FILE_BEGIN chatGPT/include/types.h
// Minimale types/structs voor orkestratie (sluit aan op eerdere parts)
#pragma once
#include <cstdint>
#include <cmath>

using u8  = uint8_t;
using u32 = uint32_t;
using u64 = uint64_t;

struct Vec3f { float x,y,z; };
struct Quatf { float w,x,y,z; };

struct StemKeyVal {
u64   key;
float value;
};

// Helpers (declaraties) ‚Äî implementatie in wiskunde_utils.cuh
inline Vec3f make_vec3f(float x,float y,float z){ return Vec3f{x,y,z}; }
FILE_END
FILE_BEGIN chatGPT/include/cc_adapter.h
#pragma once

// Pas onderstaande includes aan naar jouw lokale CloudCompare pad.
// Deze adapter biedt minimale typedefs/bridge die in h_do_optimize_frame3.cpp worden gebruikt.

#include <vector>
#include <string>

struct CCVector3 {
float x, y, z;
};

struct CCPointCloud {
std::vector<CCVector3> punten;
size_t size() const { return punten.size(); }
const CCVector3* getPoint(size_t i) const { return &punten[i]; }
void getBoundingBox(CCVector3& mn, CCVector3& mx) const {
if (punten.empty()){ mn={0,0,0}; mx={0,0,0}; return; }
mn = mx = punten[0];
for (auto &p: punten){
if (p.x<mn.x) mn.x=p.x; if (p.y<mn.y) mn.y=p.y; if (p.z<mn.z) mn.z=p.z;
if (p.x>mx.x) mx.x=p.x; if (p.y>mx.y) mx.y=p.y; if (p.z>mx.z) mx.z=p.z;
}
}
};

// In jouw plugin: vervang bovenstaande dummy door echte CC includes,
// of maak een converteerfunctie die jouw CC cloud omzet naar deze dummy-structs.
FILE_END
FILE_BEGIN chatGPT/include/pairs_bucket.cuh
#pragma once
#include "otndc.h" // for OTAsAccu
#include <cuda_runtime.h>

// kernel forward declaration
extern "C" __global__ void k_otndc_pairs(
    const float* __restrict__ x,
    const float* __restrict__ y,
    const float* __restrict__ z,
    int N,
    float binnen2, float buiten2,
    float maxDotOrtho,
    int partnerZoekRadius,
    OTAsAccu* __restrict__ gAccu);
FILE_END
FILE_BEGIN chatGPT/include/axis_permutatie.h
#pragma once
#include <algorithm>
#include <cstdint>
#include <array>
#include <iostream>
#include "types.h"          // Vec3f, u32
#include "cc_adapter.h"     // CCVector3, CCPointCloud (forward wrappers)

/*
Doel
----

* Bepaal een as-permutatie zodat intern voor de GPU altijd Vx ‚â• Vy ‚â• Vz geldt
  (waar V* = aantal voxel-cellen / effectieve resolutie per as).
* Bewaar de *namen* van de originele assen zodat we na afloop labels
  en (optioneel) geroteerde punten terug kunnen mappen.

## Afspraak

* Identifiers NL, behalve seed/triangle/forest/tree/vote/count/slab.
* Deze header is *__host__-only* hulplogica.
  */

namespace Bocari {

struct AsInfo {
char   naam;   // 'x', 'y' of 'z' (originele naam)
float* data;   // __host__ buffer (x[], y[], z[]) ‚Äî eigendom buiten deze struct
u32    V;      // effectieve voxelverdeling langs deze as (bv. Vx/Vy/Vz)
};

struct AxisPermutatie {
// volgorde newX,newY,newZ na sorteren op V aflopend
AsInfo nieuwX{};
AsInfo nieuwY{};
AsInfo nieuwZ{};


// inverse naam-mapping om later terug te mappen (‚Äòx‚Äô->positie etc.)
// bijv: invNaam['x'] == 'z' betekent: originele ‚Äòx‚Äô kwam op plek ‚Äòz‚Äô terecht.
std::array<char, 256> invNaam{};


};

inline AxisPermutatie maak_axis_permutatie(AsInfo ax, AsInfo ay, AsInfo az)
{
// Sorteer aflopend op V (grotere resolutie eerst).
std::array<AsInfo,3> v = {ax, ay, az};
std::sort(v.begin(), v.end(), [](const AsInfo&a, const AsInfo&b){ return a.V > b.V; });


AxisPermutatie perm;
perm.nieuwX = v[0];
perm.nieuwY = v[1];
perm.nieuwZ = v[2];

// invNaam: voor elke originele naam, waar is hij terechtgekomen?
// newX.naam was bv ‚Äòy‚Äô ‚Üí invNaam['y'] = 'x'
for (auto& r : perm.invNaam) r = 0;
perm.invNaam[(unsigned char)perm.nieuwX.naam] = 'x';
perm.invNaam[(unsigned char)perm.nieuwY.naam] = 'y';
perm.invNaam[(unsigned char)perm.nieuwZ.naam] = 'z';

std::cout << "[AxisPermutatie] volgorde: "
          << perm.nieuwX.naam << "‚Üíx, "
          << perm.nieuwY.naam << "‚Üíy, "
          << perm.nieuwZ.naam << "‚Üíz (op V)\n";
return perm;


}

// Hulpfunctie: druk mapping af
inline void toon_axis_mapping(const AxisPermutatie& P)
{
std::cout << "  nieuwX komt van '" << P.nieuwX.naam << "' (V=" << P.nieuwX.V << ")\n";
std::cout << "  nieuwY komt van '" << P.nieuwY.naam << "' (V=" << P.nieuwY.V << ")\n";
std::cout << "  nieuwZ komt van '" << P.nieuwZ.naam << "' (V=" << P.nieuwZ.V << ")\n";
std::cout << "  inverse naam: "
<< "orig 'x'‚Üí'" << P.invNaam[(unsigned char)'x'] << "', "
<< "orig 'y'‚Üí'" << P.invNaam[(unsigned char)'y'] << "', "
<< "orig 'z'‚Üí'" << P.invNaam[(unsigned char)'z'] << "'\n";
}

} // namespace Bocari
FILE_END
FILE_BEGIN chatGPT/include/bdrm_lru.cuh
#pragma once
#include "consts.cuh"
#include <cuda_runtime.h>

/**

* Boeren-richtingstralenmethode (BDRM) ‚Äî LRU ringbuffer voor richtingen.
* Bewaart top-k richtingskandidaten binnen een CTA (block), met simpele bubble-swap na score++.
*
* ASCII (per block in shared):
* slot:   0        1        2 ... k-1
* dir:   v0       v1       v2     vk
* score: s0       s1       s2     sk
*
* Invariant: geen volledige sort; alleen lokale swap als score[i] > score[i-1].
  */

struct LruItem
{
    float3 dir;   // genormaliseerd
    int    score; // stemmen
    int    used;  // 0/1
};

template <int K> struct LruBlock
{
    LruItem items[K];

    __device__ void init()
    {
#pragma unroll
        for(int i = 0; i & lt; K; i++)
        {
            items[i].dir   = make_float3(0, 0, 0);
            items[i].score = 0;
            items[i].used  = 0;
        }
    }

    __device__ int find_similar(const float3 v)
    {
#pragma unroll
        for(int i = 0; i & lt; K; i++)
        {
            if(!items[i].used) continue;
            float c = fabsf(items[i].dir.x * v.x + items[i].dir.y * v.y + items[i].dir.z * v.z);
            if(c& gt; = Consts::SIMILAR_COS_MIN) return i;
        }
        return -1;
    }

    __device__ int find_empty_or_evict()
    {
// probeer leeg slot
#pragma unroll
        for(int i = 0; i & lt; K; i++)
            if(!items[i].used) return i;
        // evict agressief op ratio
        int maxIdx = 0;
        for(int i = 1; i & lt; K; i++)
            if(items[i].score& gt; items[maxIdx].score) maxIdx = i;
        const float mx = float(items[maxIdx].score);
        for(int i = 0; i & lt; K; i++)
        {
            if(float(items[i].score) * Consts::EVICT_RATIO & lt; mx) return i;
        }
        // geen evict: pak laagste score
        int minIdx = 0;
        for(int i = 1; i & lt; K; i++)
            if(items[i].score& lt; items[minIdx].score) minIdx = i;
        return minIdx;
    }

    __device__ void bump_and_bubble(int idx)
    {
        items[idx].score += 1;
        // bubble 1 stap naar links indien nodig
        if(idx& gt; 0 & amp;& amp; items[idx].score& gt; items[idx - 1].score)
        {
            LruItem tmp    = items[idx - 1];
            items[idx - 1] = items[idx];
            items[idx]     = tmp;
        }
    }

    __device__ int add_or_bump(const float3 v, int warmupLeft)
    {
        int j = find_similar(v);
        if(j& gt; = 0)
        {
            bump_and_bubble(j);
            return j;
        }
        // alleen nieuwe richting toevoegen als nog warmup of evict toegestaan
        int i          = find_empty_or_evict();
        items[i].dir   = v;
        items[i].score = (warmupLeft & gt; 0 ? 1 : 1); // init score
        items[i].used  = 1;
        // geen bubble voor nieuw; wordt vanzelf omhoog gedrukt bij volgende hits
        return i;
    }
};
FILE_END
FILE_BEGIN chatGPT/include/device_buffer.cuh
#pragma once
#include <cuda_runtime.h>
#include <stdexcept>

template <typename T> struct DeviceBuffer
{
    T*     ptr = nullptr;
    size_t n   = 0;

    DeviceBuffer() = default;
    explicit DeviceBuffer(size_t count) { alloc(count); }
    ~DeviceBuffer() { free(); }

    void alloc(size_t count)
    {
        free();
        n = count;
        if(n)
        {
            cudaError_t e = cudaMalloc(&ptr, n * sizeof(T));
            if(e != cudaSuccess) throw std::runtime_error("cudaMalloc failed");
        }
    }
    void free()
    {
        if(ptr) cudaFree(ptr);
        ptr = nullptr;
        n   = 0;
    }
    void upload(const T* h, size_t count)
    {
        if(count != n) throw std::runtime_error("upload size mismatch");
        if(count) cudaMemcpy(ptr, h, count * sizeof(T), cudaMemcpyHostToDevice);
    }
    void download(T* h, size_t count) const
    {
        if(count != n) throw std::runtime_error("download size mismatch");
        if(count) cudaMemcpy(h, ptr, count * sizeof(T), cudaMemcpyDeviceToHost);
    }
};
FILE_END
FILE_BEGIN chatGPT/include/consts.cuh
#pragma once
#include <cuda_runtime.h>

// ============================================================
// Globale (tuneable) __constant__s voor orkestratie & logging
// ============================================================

// Log iedere N "hits" (votes die Gate A passeren)
#ifndef ORCH_LOG_INTERVAL
#define ORCH_LOG_INTERVAL 1024u
#endif

// 1 = ook naar log.txt schrijven (append), 0 = alleen stdout
#ifndef ORCH_LOG_TO_FILE
#define ORCH_LOG_TO_FILE 1
#endif

// Format: vaste precisie voor hoeken/varianties
#ifndef ORCH_LOG_PREC_DEG
#define ORCH_LOG_PREC_DEG 3
#endif

#ifndef ORCH_LOG_PREC_VAR
#define ORCH_LOG_PREC_VAR 4
#endif

*Globale __constant__en voor JBF -
    pipeline.*Waarden in meters.Houd rekening met schaal(__host__ kan schalen als scene > 1km).*/ namespace Consts
{
    // ---------- LIDAR / ring ----------
    __host__ __device__ constexpr float LIDAR_HALF_ERROR   = 0.001f;                           // 1 mm
    __host__ __device__ constexpr float R1_CLUSTER         = 0.004f;                           // 4 mm
    __host__ __device__ constexpr float R2_RING            = 0.012f;                           // 12 mm
    __host__ __device__ constexpr float R2_HALF_CLAIM      = 0.006f;                           // 6 mm
    __host__ __device__ constexpr float R2_HALF_CLAIM_SAFE = R2_HALF_CLAIM - LIDAR_HALF_ERROR; // claim-marge

    // ---------- slab ----------
    __host__ __device__ constexpr float SLAB_TOL         = 0.003f; // 3 mm | vlak-inliers
    __host__ __device__ constexpr int   SLAB_MIN_INLIERS = 4;

    // ---------- chaos veto ----------
    __host__ __device__ constexpr float CHAOS_RANGE_MIN  = 0.008f; // 8 mm
    __host__ __device__ constexpr int   CHAOS_INLIER_MAX = 3;      // <4 => zwak

    // ---------- stemmen / LRU ----------
    __host__ __device__ constexpr int   LRU_SLOTS       = 8;
    __host__ __device__ constexpr int   WARMUP_SEEDS    = 200;
    __host__ __device__ constexpr float ORTHO_COS_MAX   = 0.2f;  // |dot| < 0.2 ~ 11¬∞
    __host__ __device__ constexpr float SIMILAR_COS_MIN = 0.98f; // bijna dezelfde richting
    __host__ __device__ constexpr float EVICT_RATIO     = 5.0f;  // score[i]*5 < maxScore => evict
}
FILE_END
FILE_BEGIN chatGPT/src/k_reduce_groepen.cu
#include "config.h"
#include "types.h"
#include <cub/cub.cuh>
#include <cuda_runtime.h>
#include <stdexcept>

// reduce-by-key op __device__ naar unieke (key, count) paren.
// Input: d_keys_in[N], d_counts_in[N] (vaak counts=1)
// Output: d_keys_out[M], d_counts_out[M], __host__ verkrijgt M via memcpy(d_out_count).
//
// Simpele implementatie: radix-sort ‚Üí reduceByKey (CUB).

template <typename KeyT, typename ValT>
void __device___reduce_by_key(const KeyT* d_keys_in, const ValT* d_vals_in, u32 N, KeyT*& d_keys_out, ValT*& d_vals_out,
                              u32& M)
{
    if(N == 0)
    {
        d_keys_out = nullptr;
        d_vals_out = nullptr;
        M          = 0;
        return;
    }

    KeyT* d_keys_sorted = nullptr;
    ValT* d_vals_sorted = nullptr;
    cudaMalloc(&d_keys_sorted, N * sizeof(KeyT));
    cudaMalloc(&d_vals_sorted, N * sizeof(ValT));

    // Sort input pairs (keys_in, vals_in)
    void*  d_temp     = nullptr;
    size_t temp_bytes = 0;
    cub::__device__RadixSort::SortPairs(d_temp, temp_bytes, d_keys_in, d_keys_sorted, d_vals_in, d_vals_sorted, N);
    cudaMalloc(&d_temp, temp_bytes);
    cub::__device__RadixSort::SortPairs(d_temp, temp_bytes, d_keys_in, d_keys_sorted, d_vals_in, d_vals_sorted, N);
    cudaFree(d_temp);

    // Allocate output worst case = N
    KeyT* d_keys_red = nullptr;
    ValT* d_vals_red = nullptr;
    u32*  d_M        = nullptr;
    cudaMalloc(&d_keys_red, N * sizeof(KeyT));
    cudaMalloc(&d_vals_red, N * sizeof(ValT));
    cudaMalloc(&d_M, sizeof(u32));
    cudaMemset(d_M, 0, sizeof(u32));

    // ReduceByKey
    cub::__device__Reduce::ReduceByKey(d_temp, temp_bytes, d_keys_sorted, d_keys_red, d_vals_sorted, d_vals_red, d_M,
                                       cub::Equality(), cub::Sum(), N);
    cudaMalloc(&d_temp, temp_bytes);
    cub::__device__Reduce::ReduceByKey(d_temp, temp_bytes, d_keys_sorted, d_keys_red, d_vals_sorted, d_vals_red, d_M,
                                       cub::Equality(), cub::Sum(), N);
    cudaFree(d_temp);

    // Copy M to __host__
    cudaMemcpy(&M, d_M, sizeof(u32), cudaMemcpyDeviceToHost);

    // Resize output to M (optional)
    d_keys_out = d_keys_red;
    d_vals_out = d_vals_red;

    cudaFree(d_keys_sorted);
    cudaFree(d_vals_sorted);
    cudaFree(d_M);
}

extern "C" void k_reduce_groepen_launch(const u64* d_keys_in, const u32* d_counts_in, u32 N_pairs, u64*& d_unique_keys,
                                        u32*& d_unique_counts, u32& M_out)
{
    __device___reduce_by_key<u64, u32>(d_keys_in, d_counts_in, N_pairs, d_unique_keys, d_unique_counts, M_out);
}
FILE_END
FILE_BEGIN chatGPT/src/k_planair_regressie.cu
#include "config.h"
#include "types.h"
#include "wiskunde_utils.cuh"
#include <cuda_runtime.h>
#include <thrust/__device___vector.h>

// JBF-planar regressie: voor een candidate vlak (normaal n0) binnen puntset,
// refine naar n* door projectie op (u,v) basis, lineaire regressie op 2D,
// bereken nieuwe n* = normalize(u* √ó v*), en bereken d via trim-K methode.

// Kernel: voor eenvoud per blok √©√©n kandidaat plaatser (optioneel uitbreiden),
// nu: __host__ roept √©√©n candidate richting aan.
// Input: punten_sorted[N], kandidaat normaal n0, parameter k_trim_fraction
// Output: top RichtingPeak (richting n*, stemmen = aantal kept, vertrouwen ~ 1/(1+rms))

__global__ void k_planair_regressie_kernel(const Vec3f*** restrict** punten, u32 N, Vec3f n0, float trim_frac,
                                           Vec3f* out_n_star, u32* out_kept, float* out_rms)
{
    extern** shared** float s_buf[]; // tijdelijk geen gebruik
    // E√©n thread per kernel (__host__ scale) ‚Äî dus blockDim=1, gridDim=1

    // Stap 1: maak u,v basis uit n0
    Vec3f u, v;
    maak_orthobasis_uv_uit_n(n0, u, v);

    // Stap 2: projecteer alle punten op u,v: (u_i, v_i) in 2D
    // On‚Äê__device__ simpel accumulate
    float sum_u = 0.f, sum_v = 0.f, sum_uu = 0.f, sum_uv = 0.f, sum_vv = 0.f;
    for(u32 i = 0; i < N; ++i)
    {
        Vec3f p  = punten[i];
        float uu = dot(p, u);
        float vv = dot(p, v);
        sum_u += uu;
        sum_v += vv;
        sum_uu += uu * uu;
        sum_uv += uu * vv;
        sum_vv += vv * vv;
    }

    float mean_u = sum_u / N;
    float mean_v = sum_v / N;

    float cov_uu = sum_uu / N - mean_u * mean_u;
    float cov_uv = sum_uv / N - mean_u * mean_v;
    float cov_vv = sum_vv / N - mean_v * mean_v;

    // Eenvoudige Richting v* op basis van covariantie
    Vec3f v_star = norm(make_vec3f(cov_uv, cov_vv - cov_uu, 0.f));
    Vec3f u_star = norm(cross(v_star, n0));

    Vec3f n_star = norm(cross(u_star, v_star));

    // Stap 3: afstand d_i = dot(n_star, p_i). Bereken RMS na trim-K
    // Kopi√´er d_i in __host__‚Äêarray? Simpel: __host__ doet dit later. Hier __device__ approx:
    float sum_d2 = 0.f;
    for(u32 i = 0; i < N; ++i)
    {
        float di = dot(n_star, punten[i]);
        sum_d2 += di * di;
    }
    float rms = sqrtf(sum_d2 / (float)N);

    *out_n_star = n_star;
    *out_kept   = N;
    *out_rms    = rms;
}

extern "C" void k_planair_regressie_launch(const Vec3f* d_points_sorted, u32 N, const Vec3f& n0, u32 K_trim_frac_int,
                                           RichtingPeak& peakOut)
{
    if(N == 0)
    {
        peakOut.stemmen    = 0;
        peakOut.vertrouwen = 0.f;
        peakOut.richting   = make_vec3f(0, 0, 0);
        return;
    }

    Vec3f*    d_nstar;
    uint32_t* d_kept;
    float*    d_rms;
    cudaMalloc(&d_nstar, sizeof(Vec3f));
    cudaMalloc(&d_kept, sizeof(uint32_t));
    cudaMalloc(&d_rms, sizeof(float));

    float trim_frac = ((float)K_trim_frac_int) * 0.01f;
    k_planair_regressie_kernel<<<1, 1, 0>>>(d_points_sorted, N, n0, trim_frac, d_nstar, d_kept, d_rms);
    cudaDeviceSynchronize();

    Vec3f    h_nstar;
    uint32_t h_kept;
    float    h_rms;
    cudaMemcpy(&h_nstar, d_nstar, sizeof(Vec3f), cudaMemcpyDeviceToHost);
    cudaMemcpy(&h_kept, d_kept, sizeof(uint32_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(&h_rms, d_rms, sizeof(float), cudaMemcpyDeviceToHost);

    cudaFree(d_nstar);
    cudaFree(d_kept);
    cudaFree(d_rms);

    peakOut.richting   = h_nstar;
    peakOut.stemmen    = h_kept;
    peakOut.vertrouwen = 1.f / (1.f + h_rms); // simpele confidence
}
FILE_END
FILE_BEGIN chatGPT/src/h_merge_split.cu
#include "merge_split.cuh"
#include <cassert>

void h_merge_xyz_naar_vec3(const DeviceBuffer<float>& d_x, const DeviceBuffer<float>& d_y,
                           const DeviceBuffer<float>& d_z, DeviceBuffer<Vec3f>& d_pts)
{
    assert(d_x.n == d_y.n && d_y.n == d_z.n);
    const uint32_t N = (uint32_t)d_x.n;
    if(d_pts.n != N) d_pts.alloc(N);

    dim3 blk(256);
    dim3 grd((N + blk.x - 1u) / blk.x);
    k_merge_xyz_naar_vec3_kernel<<<grd, blk>>>(d_x.ptr, d_y.ptr, d_z.ptr, d_pts.ptr, N);
    cudaDeviceSynchronize();
}

void h_split_vec3_naar_xyz(const DeviceBuffer<Vec3f>& d_pts, DeviceBuffer<float>& d_x, DeviceBuffer<float>& d_y,
                           DeviceBuffer<float>& d_z)
{
    const uint32_t N = (uint32_t)d_pts.n;
    if(d_x.n != N) d_x.alloc(N);
    if(d_y.n != N) d_y.alloc(N);
    if(d_z.n != N) d_z.alloc(N);

    dim3 blk(256);
    dim3 grd((N + blk.x - 1u) / blk.x);
    k_split_vec3_naar_xyz_kernel<<<grd, blk>>>(d_pts.ptr, d_x.ptr, d_y.ptr, d_z.ptr, N);
    cudaDeviceSynchronize();
}
FILE_END
FILE_BEGIN chatGPT/src/h_axis_fit.cu
#include "pairs_bucket.cuh"
#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>

// small helper
static inline void cudaCheck(cudaError_t e, const char* msg)
{
    if(e != cudaSuccess)
    {
        std::cerr << "CUDA fout: " << msg << ": " << cudaGetErrorString(e) << "\n";
        std::abort();
    }
}
static inline float3 make3(float x, float y, float z) { return make_float3(x, y, z); }

void runOTNDC_pairs(const float* x, const float* y, const float* z, int N, AssenResultaat* out, const OTConfig& cfg)
{
    // Globale accumulator
    OTAsAccu* dAccu = nullptr;
    cudaCheck(cudaMalloc(&dAccu, sizeof(OTAsAccu)), "malloc dAccu");
    cudaCheck(cudaMemset(dAccu, 0, sizeof(OTAsAccu)), "memset dAccu");

    // Kernelconfig
    const int    B     = (cfg.blokGrootte > 0 ? cfg.blokGrootte : 256);
    const int    G     = (N + B - 1) / B;
    const size_t shmem = 3 * B * sizeof(float); // sx,sy,sz

    // Launch
    k_otndc_pairs<<<G, B, shmem>>>(x, y, z, N, cfg.binnenStraal2, cfg.buitenStraal2, cfg.maxDotOrtho,
                                   cfg.partnerZoekRadius, dAccu);
    cudaCheck(cudaGetLastError(), "launch k_otndc_pairs");
    cudaCheck(cudaDeviceSynchronize(), "sync k_otndc_pairs");

    // __host__ reduce
    OTAsAccu hAccu{};
    cudaCheck(cudaMemcpy(&hAccu, dAccu, sizeof(OTAsAccu), cudaMemcpyDeviceToHost), "cpy accu");
    cudaCheck(cudaFree(dAccu), "free accu");

    // Normeer richting
    float len = std::sqrt(hAccu.som.x * hAccu.som.x + hAccu.som.y * hAccu.som.y + hAccu.som.z * hAccu.som.z);
    int   dim = 0;
    if(hAccu.count >= cfg.warmupMin && len > 1e-8f)
    {
        out->v[0][0]  = hAccu.som.x / len;
        out->v[0][1]  = hAccu.som.y / len;
        out->v[0][2]  = hAccu.som.z / len;
        out->score[0] = static_cast<float>(hAccu.count);
        dim           = 1;
    }
    out->dimensie = dim;

    // (Slots 2 en 3 blijven leeg in deze fase)
    for(int i = 1; i < 3; i++)
    {
        out->v[i][0] = out->v[i][1] = out->v[i][2] = 0.f;
        out->score[i]                              = 0.f;
    }
}
FILE_END
FILE_BEGIN chatGPT/src/demo_orchestratie_main.cpp
#include <iostream>
#include <vector>
#include <cuda_runtime.h>
#include "orchestratie.h"
#include "types.h"

template <typename T>
static T* gpu_malloc_copy(const std::vector<T>& h){
T* d=nullptr;
cudaMalloc(&d, h.size()*sizeof(T));
if(!h.empty()) cudaMemcpy(d, h.data(), h.size()*sizeof(T), cudaMemcpyHostToDevice);
return d;
}

int main()
{
// Demo: lege stub ‚Äî in de echte plugin geef jij d_punten/d_mask/d_labels door.
std::vector<Vec3f> h_pts; // vul met jouw cloud
u32 N = (u32)h_pts.size();


Vec3f* d_punten = gpu_malloc_copy(h_pts);
u8* d_mask=nullptr;  // alles actief
PuntLabel* d_labels=nullptr;
cudaMalloc(&d_labels, N*sizeof(PuntLabel));
cudaMemset(d_labels, 0, N*sizeof(PuntLabel));

OrkestratieParams p;
FrameStatus frame;
DiscoverLog log;

bool ok = h_vind_ideaal_frame(d_punten, N, d_mask, d_labels, p, frame, log);
if(!ok){
    std::cout << "[demo] geen ideaal frame gevonden: " << log.verslag << "\n";
    return 0;
}
h_print_frame(frame);

h_rotatie_naar_ideaal(d_punten, N, frame);

h_fine_labeling(d_punten, N, d_labels, frame, p);

cudaFree(d_punten);
cudaFree(d_labels);
std::cout << "[demo] klaar.\n";
return 0;


}
FILE_END
FILE_BEGIN chatGPT/src/h_orchestratie3.xcpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cmath>
#include "include/config.h"
#include "include/wiskunde_utils.cuh"

// Kleine helper
static inline float clampf(float x, float a, float b) {
    return std::max(a, std::min(b, x));
}

// ---- __host__ visualisatie van nudge (preview twee-as rotatie) ----
namespace __host__vis {

static inline void print_frame_nudge_preview(const Vec3f& asX,
                                             const Vec3f& asY,
                                             const Vec3f& asZ)
{
    Vec3f Z{0,0,1};
    Vec3f v = cross(Z, asZ);
    float c = dot(Z, asZ);
    float ang = std::acos( std::clamp(c, -1.0f, 1.0f) );
    Quat qz = (std::fabs(ang) < 1e-6f) ? Quat{1,0,0,0} 
                                      : quat_from_axis_angle(v, ang);

    Vec3f X{1,0,0};
    Vec3f Xp = quat_rotate(qz, X);
    Vec3f t  = cross(Xp, asX);
    float c2 = dot(Xp, asX);
    float ang2 = std::acos( std::clamp(c2, -1.0f, 1.0f) );
    Quat qx = (std::fabs(ang2) < 1e-6f) ? Quat{1,0,0,0}
                                       : quat_from_axis_angle(t, ang2);

    Quat q = quat_mul(qx, qz);

    float yawDeg=0.f, pitchDeg=0.f;
    quat_to_ZY_angles(q, yawDeg, pitchDeg);

    float clip = cfg::get().stemmen.clipKleinGraads;
    clip_small_degrees(clip, yawDeg);
    clip_small_degrees(clip, pitchDeg);

    float maxLock = cfg::get().stemmen.maxLockGraads;
    bool reject   = (std::fabs(yawDeg) > maxLock ||
                     std::fabs(pitchDeg) > maxLock);

    std::cout << "[FrameCheck] Rotaties (Z,Y): yaw=" 
              << yawDeg << "¬∞, pitch=" << pitchDeg << "¬∞";
    if (reject) {
        std::cout << " [REJECT >" << maxLock << "¬∞]";
    }
    std::cout << "\n";
}

} // namespace __host__vis

// ---- Statistiek voor log ----
struct StatBlok {
    uint32_t hitsTotaal   = 0;
    uint32_t hitsNieuw    = 0;
    uint32_t nearCount    = 0;
    uint32_t okCount      = 0;
    uint32_t slotCount    = 0;
    float    dHoekDeg     = 0.f;
    float    varCos       = 0.f;
    bool     locked       = false;
};

static inline void log_status(const StatBlok& s)
{
#if ORCH_LOG_TO_FILE
    static std::ofstream flog("log.txt", std::ios::app);
    if (flog.good()) {
        flog << "hits+=" << s.hitsNieuw
             << " total=" << s.hitsTotaal
             << " near="  << s.nearCount
             << " ok="    << s.okCount
             << " slots=" << s.slotCount
             << " dHoek=" << std::fixed << std::setprecision(ORCH_LOG_PREC_DEG)
             << s.dHoekDeg << "¬∞"
             << " varCos=" << std::setprecision(ORCH_LOG_PREC_VAR)
             << s.varCos
             << " " << (s.locked ? "LOCKED" : "-")
             << "\n";
        flog.flush();
    }
#endif

    std::cout << "hits+=" << s.hitsNieuw
              << " total=" << s.hitsTotaal
              << " near="  << s.nearCount
              << " ok="    << s.okCount
              << " slots=" << s.slotCount
              << " dHoek=" << std::fixed << std::setprecision(ORCH_LOG_PREC_DEG)
              << s.dHoekDeg << "¬∞"
              << " varCos=" << std::setprecision(ORCH_LOG_PREC_VAR)
              << s.varCos
              << " " << (s.locked ? "LOCKED" : "-")
              << std::endl;
}

// ---- Hoofdlus (dummy poll voorbeeld) ----
// In jouw echte code: call deze na elke batch votes
void h_run_orchestratie_logging_loop()
{
    StatBlok acc;
    uint32_t intervalHits = 0;

    for (;;) {
        // TODO: fetch real __device__ counters
        uint32_t newlyAccepted = 0;
        uint32_t nearIn        = 0;
        uint32_t okIn          = 0;
        uint32_t activeSlots   = 0;
        float    dHoekDegSample= 0.f;
        float    varCosSample  = 0.f;
        bool     lockedNow     = false;

        // ---- Dummy exit condition (replace!) ----
        static int dummyIters = 0;
        if (++dummyIters > 1) break;

        newlyAccepted  = ORCH_LOG_INTERVAL;
        nearIn         = ORCH_LOG_INTERVAL * 3 / 4;
        okIn           = ORCH_LOG_INTERVAL * 1 / 4;
        activeSlots    = 3;
        dHoekDegSample = 0.18f;
        varCosSample   = 0.0017f;
        lockedNow      = true;
        // -----------------------------------------

        intervalHits       += newlyAccepted;
        acc.hitsTotaal     += newlyAccepted;
        acc.nearCount      += nearIn;
        acc.okCount        += okIn;
        acc.slotCount       = activeSlots;
        acc.dHoekDeg        = dHoekDegSample;
        acc.varCos          = varCosSample;
        acc.locked          = lockedNow;

        if (intervalHits >= ORCH_LOG_INTERVAL) {
            StatBlok out = acc;
            out.hitsNieuw = intervalHits;
            log_status(out);
            intervalHits = 0;
            acc.nearCount = 0;
            acc.okCount   = 0;
        }

        if (lockedNow) {
            if (intervalHits > 0) {
                StatBlok out = acc;
                out.hitsNieuw = intervalHits;
                out.locked    = true;
                log_status(out);
                intervalHits = 0;
            }

            // ====== Hier roep jij de preview aan ======
            Vec3f asX{1,0,0}, asY{0,1,0}, asZ{0,0,1}; 
            // ‚Üë‚Üë in echte code vervang door jouw slot->finalAxes
            __host__vis::print_frame_nudge_preview(asX,asY,asZ);

            break;
        }
    }
}
FILE_END
FILE_BEGIN chatGPT/src/otndc_host.cu
#include "otndc.h"
#include <algorithm>
#include <cmath>
#include <cuda_runtime.h> // voor CUDA launch macros
#include <iostream>
#include <vector>

static float3 to3(float x, float y, float z) { return make_float3(x, y, z); }

// forward decl of CUDA kernel
__global__ void k_oTNDCRays(const float* x, const float* y, const float* z, int N, OTSlot* slots, int maxSlots,
                            float binnen2, float buiten2, float minHoekCos);

void runOTNDC(const float* x, const float* y, const float* z, int N, AssenResultaat* out, const OTConfig& cfg)
{
    int blocks  = (N + 255) / 256;
    int threads = 256;

    int                 S = cfg.maxSlots;
    std::vector<OTSlot> hslots(S);
    OTSlot*             dslots;
    cudaMalloc(&dslots, S * sizeof(OTSlot));
    cudaMemset(dslots, 0, S * sizeof(OTSlot));

    k_oTNDCRays<<<blocks, threads>>>(x, y, z, N, dslots, S, cfg.binnenStraal2, cfg.buitenStraal2, cfg.minHoekCos);
    cudaDeviceSynchronize();

    cudaMemcpy(hslots.data(), dslots, S * sizeof(OTSlot), cudaMemcpyDeviceToHost);
    cudaFree(dslots);

    // reduce + pick top 3
    struct V
    {
        float3 v;
        float  score;
    };
    std::vector<V> vals;
    for(int i = 0; i < S; i++)
    {
        if(hslots[i].count < cfg.warmupMin) continue;
        float3 a   = to3(hslots[i].som.x, hslots[i].som.y, hslots[i].som.z);
        float  len = sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        if(len < 1e-6) continue;
        vals.push_back({make_float3(a.x / len, a.y / len, a.z / len), (float)hslots[i].count});
    }

    // sort by score desc
    std::sort(vals.begin(), vals.end(), [](const V& A, const V& B) { return A.score > B.score; });

    int D         = std::min((int)vals.size(), 3);
    out->dimensie = D;
    for(int i = 0; i < D; i++)
    {
        out->v[i][0]  = vals[i].v.x;
        out->v[i][1]  = vals[i].v.y;
        out->v[i][2]  = vals[i].v.z;
        out->score[i] = vals[i].score;
    }
}
FILE_END
FILE_BEGIN chatGPT/src/h_region_queue.cu
#include "consts.cuh"
#include "types.cuh"
#include <algorithm>
#include <cstdint>
#include <vector>

// ====== Uitleg (__host__):
// - We hebben al 64-bit morton keys per punt (__device__ berekend of __host__-side).
// - Regio = d_REGION_BITS MSB's van de key.
// - We bouwen hier een 1D work-queue van regio-indexen met hun [begin,einde] rangen
//   in de gepermuteerde, op-key gesorteerde arrays (keys/points/labels).

struct RegioRange
{
    uint64_t regio;
    uint32_t begin;
    uint32_t einde;
};

void h_bouw_regio_ranges(const std::vector<uint64_t>& keys_sorted, std::vector<RegioRange>& ranges_out)
{
    ranges_out.clear();
    if(keys_sorted.empty()) return;

    const uint32_t R     = REGION_BITS;
    uint64_t       cur   = morton_prefix(keys_sorted[0], R);
    uint32_t       begin = 0;

    for(uint32_t i = 1; i < keys_sorted.size(); ++i)
    {
        uint64_t pre = morton_prefix(keys_sorted[i], R);
        if(pre != cur)
        {
            ranges_out.push_back({cur, begin, i});
            cur   = pre;
            begin = i;
        }
    }
    ranges_out.push_back({cur, begin, (uint32_t)keys_sorted.size()});

    // Optioneel: sorteer ranges op grootte desc (work-steal vriendelijk)
    std::sort(ranges_out.begin(), ranges_out.end(),
              [](const RegioRange& A, const RegioRange& B) { return (A.einde - A.begin) > (B.einde - B.begin); });
}
FILE_END
FILE_BEGIN chatGPT/src/k_merge_split.cu
#include "types.cuh"

// ====== Kernels ======

__global__ void k_merge_xyz_naar_vec3_kernel(const float*** restrict** x, const float*** restrict** y,
                                             const float*** restrict** z, Vec3f*** restrict** pts, uint32_t N)
{
    const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    pts[i] = Vec3f{x[i], y[i], z[i]};
}

__global__ void k_split_vec3_naar_xyz_kernel(const Vec3f*** restrict** pts, float*** restrict** x,
                                             float*** restrict** y, float*** restrict** z, uint32_t N)
{
    const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    Vec3f p = pts[i];
    x[i]    = p.x;
    y[i]    = p.y;
    z[i]    = p.z;
}
FILE_END
FILE_BEGIN chatGPT/src/k_voxeliseer_morton.cu
#include "__device___buffer.cuh"
#include "config.h"
#include "morton_utils.cuh"
#include "types.h"
#include <cub/cub.cuh>
#include <cuda_runtime.h>
#include <stdexcept>

// ============ Kernels ============

// Kwantiseren + morton sleutel (zonder regio-codes voor nu)
__global__ void k_kwantiseer_en_key(const Vec3f*** restrict** punten, u32 N, Kwantisatie Q, u64*** restrict** keys_out)
{
    u32 i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;

    Vec3f p = punten[i];
    u32   xi, yi, zi;
    kwantiseer_punt(p, Q, xi, yi, zi);

    // Voorlopig geen afzonderlijke regio-code (0)
    u64 key     = morton_met_regio(xi, yi, zi, /*regio*/ 0u);
    keys_out[i] = key;
}

// Permuteer punten volgens index-permutatie
__global__ void k_permuteer_punten(const Vec3f*** restrict** punten_in, const u32*** restrict** index_perm, u32 N,
                                   Vec3f*** restrict** punten_out)
{
    u32 i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    u32 src       = index_perm[i];
    punten_out[i] = punten_in[src];
}

// ============ __host__ Launch ============

static inline void check(cudaError_t e, const char* where)
{
    if(e != cudaSuccess) throw std::runtime_error(std::string("[CUDA] ") + where + " : " + cudaGetErrorString(e));
}

void k_voxeliseer_morton_launch(const Vec3f* d_points, u32 N, Kwantisatie Q, u64* d_keys,
                                u32* /*d_regioCodes*/, // (niet gebruikt nu)
                                Vec3f* d_points_perm, u32* d_index_perm)
{
    if(N == 0) return;

    // 1) Kwantiseren + morton keys
    dim3 bs(256);
    dim3 gs((N + bs.x - 1) / bs.x);
    k_kwantiseer_en_key<<<gs, bs>>>(d_points, N, Q, d_keys);
    check(cudaGetLastError(), "k_kwantiseer_en_key");

    // 2) Init index [0..N)
    //    Gebruik thrust of een simpele kernel; we doen snelle CUB-sequence via transform-iterator
    //    Om het simpel te houden: kleine helper kernel hier:
    auto k_init_indices = [] __global__(u32 * idx, u32 n) {
        u32 i = blockIdx.x * blockDim.x + threadIdx.x;
        if(i < n) idx[i] = i;
    };
    k_init_indices<<<gs, bs>>>(d_index_perm, N);
    check(cudaGetLastError(), "init indices");

    // 3) CUB radix sort (keys, indices)
    void*  d_temp     = nullptr;
    size_t temp_bytes = 0;

    cub::__device__RadixSort::SortPairs(d_temp, temp_bytes, d_keys, d_keys, d_index_perm, d_index_perm, N);
    check(cudaGetLastError(), "cub temp size");

    cudaMalloc(&d_temp, temp_bytes);
    cub::__device__RadixSort::SortPairs(d_temp, temp_bytes, d_keys, d_keys, d_index_perm, d_index_perm, N);
    check(cudaGetLastError(), "cub sort pairs");
    cudaFree(d_temp);

    // 4) Permuteer punten ‚Üí d_points_perm (coalesced read met index_perm)
    k_permuteer_punten<<<gs, bs>>>(d_points, d_index_perm, N, d_points_perm);
    check(cudaGetLastError(), "k_permuteer_punten");

    cudaDeviceSynchronize();
}
FILE_END
FILE_BEGIN chatGPT/src/h_do_optimize_frame3.cpp
#include <iostream>
#include <vector>
#include <cstdint>
#include <memory>

#include "cc_adapter.h"            // CCVector3, CCPointCloud*
#include "__device___buffer.cuh"       // DeviceBuffer<T>
#include "types.h"                 // Vec3f, u32
#include "axis_permutatie.h"       // AxisPermutatie
#include "orchestratie.h"          // NL orchestratie-functies
#include "consts.cuh"              // thresholds/__constant__en
#include "merge_split.cuh"         // h_merge_xyz_naar_vec3 / h_split_vec3_naar_xyz

// Kernels/__host__-stappen (geleverde modules)
extern void h_voxeliseer_morton(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts,
/*io*/Bocari::DeviceBuffer<u64>& d_keys,
/*io*/Bocari::DeviceBuffer<u32>& d_index,
/*out*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted);

extern void h_ruis_boeren(/*io*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels);

extern void h_vlak_vote_current_frame(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels,
/*out*/Bocari::KandidaatAssen& uit);

extern void h_vlak_vote_bruteforce(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels,
/*out*/Bocari::KandidaatAssen& uit);

// NB: buis_vote happy path pas inzetten als nodig
extern void h_buis_vote_bruteforce(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels,
/*out*/Bocari::KandidaatAssen& uit);

extern void h_rotatie_quat_apply(/*io*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*in*/const Bocari::Quat& q);

extern void h_fine_slabs_cyl_label(/*io*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels);

// ============= HOOFDFLOW =============

void AutofitImpl::doOptimizeFrame3()
{
using namespace Bocari;


if (!m_selectedCloud || m_selectedCloud->size() == 0)
{
    std::cout << "[Autofit] Geen point cloud of leeg.\n";
    return;
}

// 1) __host__: lees CC-punten en bepaal as-verdeling (Vx/Vy/Vz) + permutatie
CCVector3 bbMin, bbMax;
m_selectedCloud->getBoundingBox(bbMin, bbMax);

const size_t N = m_selectedCloud->size();
std::vector<float> h_x(N), h_y(N), h_z(N);

for (size_t i=0; i<N; ++i)
{
    const CCVector3* p = m_selectedCloud->getPoint(i);
    if (!p) continue;
    h_x[i] = p->x;
    h_y[i] = p->y;
    h_z[i] = p->z;
}

// Bepaal Vx,Vy,Vz (bijv via morton-driven voxelisatie ontwerp; hier simpele placeholder:
// neem verhouding van BB-lengtes t.o.v. target gridgrootte)
const float Lx = bbMax.x - bbMin.x;
const float Ly = bbMax.y - bbMin.y;
const float Lz = bbMax.z - bbMin.z;

// Ruime schatting: grotere lengte ‚Üí grotere V
u32 Vx = std::max(1u, (u32)(Lx > 0 ? 1024.f * (Lx / std::max({Lx,Ly,Lz})) : 1));
u32 Vy = std::max(1u, (u32)(Ly > 0 ? 1024.f * (Ly / std::max({Lx,Ly,Lz})) : 1));
u32 Vz = std::max(1u, (u32)(Lz > 0 ? 1024.f * (Lz / std::max({Lx,Ly,Lz})) : 1));

Bocari::AsInfo ax{ 'x', h_x.data(), Vx };
Bocari::AsInfo ay{ 'y', h_y.data(), Vy };
Bocari::AsInfo az{ 'z', h_z.data(), Vz };

AxisPermutatie perm = maak_axis_permutatie(ax, ay, az);
toon_axis_mapping(perm);

// 2) Upload nieuwe x/y/z volgens permutatie
DeviceBuffer<float> d_x(N), d_y(N), d_z(N);
d_x.upload(perm.nieuwX.data, N);
d_y.upload(perm.nieuwY.data, N);
d_z.upload(perm.nieuwZ.data, N);

// 3) Merge naar vec3f (__device__) ‚Üí d_pts
DeviceBuffer<Vec3f> d_pts(N);
h_merge_xyz_naar_vec3(d_x, d_y, d_z, d_pts);

std::cout << "[Autofit] Merge x/y/z ‚Üí vec3f gedaan. Start pipeline‚Ä¶\n";

// 4) Morton-driven sort + boeren ruisfilter
DeviceBuffer<u64> d_keys(N);
DeviceBuffer<u32> d_index(N);
DeviceBuffer<Vec3f> d_pts_sorted(N);
DeviceBuffer<u8>  d_labels(N); d_labels.memset(0);

h_voxeliseer_morton(d_pts, d_keys, d_index, d_pts_sorted);
h_ruis_boeren(d_pts_sorted, d_labels);

// 5) Probeer huidig frame (3 richtingen) ‚Üí vlakken
KandidaatAssen assen{};
h_vlak_vote_current_frame(d_pts_sorted, d_labels, assen);

if (!assen.heeftMinstensEenAs())
{
    std::cout << "[Autofit] Geen vlak in huidig frame. Brute planes‚Ä¶\n";
    h_vlak_vote_bruteforce(d_pts_sorted, d_labels, assen);
}

if (!assen.heeftMinstensEenAs())
{
    std::cout << "[Autofit] Geen vlak gevonden. Brute buizen (annulus/wedge)‚Ä¶\n";
    h_buis_vote_bruteforce(d_pts_sorted, d_labels, assen);
}

if (!assen.heeftMinstensEenAs())
{
    std::cout << "[Autofit] Geen eerste as te vinden (vlakken/buizen). Stop.\n";
    return;
}

// 6) Orthonormaliseer 2e/3e as (JBF ‚Üí Gram‚ÄìSchmidt), maak quaternion
Quat q = maak_quat_naar_ideaal_frame(assen); // in orchestratie.h/.cpp

std::cout << "[Autofit] Roteer naar ideaal frame (quaternion)‚Ä¶\n";
h_rotatie_quat_apply(d_pts_sorted, q);

// 7) Fine slabs + (simpele) radiale buislabeling in ideaal frame
h_fine_slabs_cyl_label(d_pts_sorted, d_labels);

// 8) Split terug: vec3f ‚Üí x/y/z
h_split_vec3_naar_xyz(d_pts_sorted, d_x, d_y, d_z);

// 9) Download en TERUG-PERMUTEER naar oorspronkelijke as-namen
std::vector<float> rx(N), ry(N), rz(N);
d_x.download(rx.data(), N);
d_y.download(ry.data(), N);
d_z.download(rz.data(), N);

// Terug-mapping: we hebben invNaam: orig 'x'‚Üí'?' (x/y/z)
auto zetTerug = [&](char orig, const std::vector<float>& nx,
                    const std::vector<float>& ny,
                    const std::vector<float>& nz, float& out)
{
    char nieuwe = perm.invNaam[(unsigned char)orig];
    if (nieuwe == 'x') out = nx[&out - &out]; // niet bruikbaar zo; we schrijven rechtstreeks per punt
};

// Simpeler: schrijf direct de juiste component per punt
for (size_t i=0; i<N; ++i)
{
    float X = rx[i], Y = ry[i], Z = rz[i];
    // welke originele as kwam op nieuwX?
    // perm.nieuwX.naam == 'y' betekent: oude 'y' staat nu in X
    float out_x=0, out_y=0, out_z=0;
    // inv map: welke nieuwe letter hoort bij orig?
    // We bepalen per nieuwe component naar welke originele naam die hoort:
    // nieuwX kwam van naamA ‚Üí schrijf X terug naar die orig naamA
    auto schrijf = [&](char kwamVan, float waarde) {
        if (kwamVan=='x') out_x = waarde;
        else if (kwamVan=='y') out_y = waarde;
        else if (kwamVan=='z') out_z = waarde;
    };
    schrijf(perm.nieuwX.naam, X);
    schrijf(perm.nieuwY.naam, Y);
    schrijf(perm.nieuwZ.naam, Z);

    // Update terug in CC cloud (alleen pos; labels kun je separaat ophalen)
    CCVector3* p = m_selectedCloud->getPointMutable(i);
    if (p) { p->x = out_x; p->y = out_y; p->z = out_z; }
}

std::cout << "[Autofit] Klaar: punten teruggezet in originele as-namen.\n";


}
FILE_END
FILE_BEGIN chatGPT/src/demo_axis.cpp
#include "otndc.h"
#include <iostream>
#include <vector>
#include <cmath>

// Dummy test: points on X axis + some noise
int main(){
    int N = 100000;
    std::vector<float> x(N),y(N),z(N);
    for(int i=0;i<N;i++){
        float t = (float)i/N * 100.0f;
        x[i]=t;
        y[i]=0.002f*sin(t);
        z[i]=0.002f*cos(t);
    }

    OTConfig cfg;
    cfg.binnenStraal2 = 0.01f*0.01f; // 1cm
    cfg.buitenStraal2 = 3.0f*3.0f;   // 3m
    cfg.minHoekCos = 0.94f;          // ~20¬∞
    cfg.warmupMin = 50;
    cfg.maxSlots = 16;

    AssenResultaat out;
    runOTNDC(x.data(),y.data(),z.data(),N,&out,cfg);

    std::cout<<"Dimensie: "<<out.dimensie<<"\n";
    for(int i=0;i<out.dimensie;i++){
        std::cout<<"As "<<i<<": "<<out.v[i][0]<<","<<out.v[i][1]<<","<<out.v[i][2]
                 <<" score="<<out.score[i]<<"\n";
    }
}
FILE_END
FILE_BEGIN chatGPT/src/demo_axis2.cpp
#include "otndc.h"
#include <vector>
#include <iostream>
#include <cmath>
#include <random>

// Synthetische test: cilinder rond X-as (asrichting moet ~ (1,0,0) worden).
int main(){
    const int turns = 2000;     // aantal "ringen" langs x
    const float lengte = 5.0f;  // 5 m
    const float r = 0.10f;      // 10 cm
    const float sigma = 0.003f; // 3 mm jitter
    const int perRing = 256;    // punten per ring

    const int N = turns * perRing;
    std::vector<float> x(N), y(N), z(N);

    std::mt19937 rng(42);
    std::normal_distribution<float> noise(0.0f, sigma);

    for(int i=0;i<turns;i++){
        float t = (float)i/(turns-1);
        float X = -lengte*0.5f + t * lengte;
        for(int k=0;k<perRing;k++){
            float ang = (2.0f*float(M_PI))* (float)k / (float)perRing;
            int idx = i*perRing + k;
            x[idx] = X + noise(rng)*0.1f; // klein
            y[idx] = r*std::cos(ang) + noise(rng);
            z[idx] = r*std::sin(ang) + noise(rng);
        }
    }

    OTConfig cfg{};
    // Ring (we gebruiken hele cloud; zet ring ruim open zodat alles meedoet)
    cfg.binnenStraal2 = 0.0f;
    cfg.buitenStraal2 = (lengte*lengte + 4*r*r)*2.0f; // ruime bovengrens

    // Orthogonaliteit (>=~20¬∞): |dot| <= cos(70¬∞) ‚âà 0.342
    cfg.maxDotOrtho = 0.35f;

    cfg.warmupMin = 100;     // min stemmen om richting te accepteren
    cfg.blokGrootte = 256;
    cfg.partnerZoekRadius = 32;

    AssenResultaat out{};
    runOTNDC_pairs(x.data(), y.data(), z.data(), N, &out, cfg);

    std::cout<<"Dimensie: "<<out.dimensie<<"\n";
    if(out.dimensie>=1){
        std::cout<<"As 0: "<<out.v[0][0]<<","<<out.v[0][1]<<","<<out.v[0][2]
                 <<"  score="<<out.score[0]<<"\n";
    }
    return 0;
}
FILE_END
FILE_BEGIN chatGPT/src/readme.txt
üéÅ Wat dit betekent

‚úÖ File compileert
‚úÖ Geen onduidelijke placeholders
‚úÖ Identity-frame output ‚Üí jij ziet nu logs
‚úÖ Later vervangen door echte resultaten:

Waar?
üëâ In dit √©√©n regeltje:

Vec3f asX{1,0,0}, asY{0,1,0}, asZ{0,0,1};

Later wordt dit bv.:
auto frame = d_cpu_result; // GPU->host copy
Vec3f asX = frame.axis[0];
Vec3f asY = frame.axis[1];
Vec3f asZ = frame.axis[2];
FILE_END
FILE_BEGIN chatGPT/src/k_label_sort.cu
#include "types.cuh"
#include <thrust/__device___ptr.h>
#include <thrust/iterator/zip_iterator.h>
#include <thrust/sort.h>
#include <thrust/tuple.h>

/**

* Sorteer labels op (type, clusterId, mortonKey) stabiel om spatial locality te bewaren.
* Aanname: d_morton bestaat (uint64_t*) parallel aan punten.
  */

extern "C" void sort_labels_by_type_cluster_morton(uint8_t* d_type, uint32_t* d_cluster, uint64_t* d_morton, int N,
                                                   cudaStream_t stream)
{
    using thrust::__device___ptr;
    using thrust::make_tuple;
    using thrust::make_zip_iterator;

    auto t0 = __device___ptr & lt;
    uint8_t & gt;
    (d_type);
    auto t1 = __device___ptr & lt;
    uint32_t & gt;
    (d_cluster);
    auto t2 = __device___ptr & lt;
    uint64_t & gt;
    (d_morton);

    auto zip_begin = make_zip_iterator(make_tuple(t0, t1, t2));
    auto zip_end   = zip_begin + N;

    thrust::stable_sort(thrust::cuda::par.on(stream), zip_begin, zip_end,
                        [] __device__(const thrust::tuple& lt; uint8_t, uint32_t, uint64_t& gt;
                                      &a, const thrust::tuple& lt; uint8_t, uint32_t, uint64_t& gt; &b) {
                            if(thrust::get& lt; 0 & gt; (a) < thrust::get & lt; 0 & gt; (b)) return true;
                            if(thrust::get& lt; 0 & gt; (a) > thrust::get & lt; 0 & gt; (b)) return false;
                            if(thrust::get& lt; 1 & gt; (a) < thrust::get & lt; 1 & gt; (b)) return true;
                            if(thrust::get& lt; 1 & gt; (a) > thrust::get & lt; 1 & gt; (b)) return false;
                            return thrust::get & lt;
                            2 & gt;
                            (a) & lt;
                            thrust::get& lt;
                            2 & gt;
                            (b);
                        });
}
FILE_END
FILE_BEGIN chatGPT/src/k_direction_vote_bdrm.cu
#include "bdrm_lru.cuh"
#include "consts.cuh"
#include "types.cuh"
#include <cooperative_groups.h>
#include <cuda_runtime.h>

namespace cg = cooperative_groups;

/*
k_direction_vote_bdrm
---------------------

Boeren-richtingstralenmethode:
- Neem normale n van mini-triangle (of fallback), translatie naar O is impliciet (we gebruiken alleen richting).
- LRU per block; stem op n.
- In warmup: maak max 2 cross-products met top-slots die bijna orthogonaal zijn; voeg toe als nieuw.
- Bij stem: als LRU al vector ~orthogonaal heeft, bump ook die.

ASCII:
O  ‚Üê alle stralen (normals) worden gezien als pijlen vanuit O.
We clusteren VLAKRICHTINGEN en leiden asrichtingen af via kruisproducten.
*/

__device__ inline float  dot3f(const float3 a, const float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__device__ inline float3 cross3f(const float3 a, const float3 b)
{
    return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
__device__ inline float  len3f(const float3 v) { return sqrtf(dot3f(v, v)); }
__device__ inline float3 norm3f(const float3 v)
{
    float L = len3f(v);
    return (L > 0) ? make_float3(v.x / L, v.y / L, v.z / L) : make_float3(0, 0, 0);
}

template <int K>
__global__ void k_direction_vote_bdrm(const float3*** restrict** d_norm_tri, const uint8_t*** restrict** d_ok_for_vote,
                                      int                  N,
                                      float3*** restrict** d_block_winners, // per block: top 3
                                      int                  maxWinnersPerBlock)
{
    extern** shared** unsigned char shmem[];
    auto*                           lru = reinterpret_cast<LruBlock<K>*>(shmem);
    if(threadIdx.x == 0) lru->init();
    __syncthreads();

    const int gid  = blockIdx.x * blockDim.x + threadIdx.x;
    const int lane = threadIdx.x;

    int warmupLeft = Consts::WARMUP_SEEDS;

    if(gid& lt; N& amp;& amp; d_ok_for_vote[gid])
    {
        float3 n = d_norm_tri[gid];
        // force hemisfeer-consistentie (optioneel): maak z>=0 b.v.
        if(n.z& lt; 0.f)
        {
            n.x = -n.x;
            n.y = -n.y;
            n.z = -n.z;
        }
        n = norm3f(n);

        // stem op n
        __syncthreads();
        int idx = lru - > add_or_bump(n, warmupLeft);
        __syncthreads();

        // orthogonale partner bump
        if(idx& gt; = 0)
        {
#pragma unroll
            for(int i = 0; i & lt; K; i++)
            {
                if(!lru - & gt; items[i].used) continue;
                if(i == idx) continue;
                if(fabsf(dot3f(lru - > items[i].dir, n)) & lt; = Consts::ORTHO_COS_MAX)
                {
                    lru - > bump_and_bubble(i);
                    break; // √©√©n partner is genoeg
                }
            }
        }

        // warmup cross-product (max 2 tegen top slots)
        if(warmupLeft& gt; 0)
        {
            // top 2
            for(int t = 0; t & lt; 2 & amp; &t & lt; K; ++t)
            {
                if(!lru - & gt; items[t].used) continue;
                float c = fabsf(dot3f(lru - > items[t].dir, n));
                if(c& lt; = Consts::ORTHO_COS_MAX)
                {
                    float3 v = norm3f(cross3f(n, lru - > items[t].dir));
                    if(len3f(v) & gt; 0.5f)
                    {
                        // voeg toe als niet gelijk
                        int sim = lru - > find_similar(v);
                        if(sim& lt; 0) lru - > add_or_bump(v, warmupLeft);
                    }
                }
            }
            atomicSub(&warmupLeft, 1);
        }
    }
    __syncthreads();

    // schrijf block-winnaars (top M)
    if(threadIdx.x == 0)
    {
        const int base = blockIdx.x * maxWinnersPerBlock;
        const int M    = (maxWinnersPerBlock & lt; K ? maxWinnersPerBlock : K);
        for(int m = 0; m & lt; M; m++)
        {
            d_block_winners[base + m] = lru - > items[m].used ? lru - > items[m].dir : make_float3(0, 0, 0);
        }
    }
}

// explicit instantiation
extern "C" void launch_direction_vote_bdrm(const float3* d_norms, const uint8_t* d_voteMask, int N,
                                           float3* d_blockWinners, int maxWinnersPerBlock, cudaStream_t stream,
                                           int* gridOut, int* blockOut)
{
    const int block = 256;
    const int grid  = (N + block - 1) / block;
    size_t    sh    = sizeof(LruBlock<Consts::LRU_SLOTS>);
    k_direction_vote_bdrm<Consts::LRU_SLOTS>
        <<<grid, block, sh, stream>>>(d_norms, d_voteMask, N, d_blockWinners, maxWinnersPerBlock);
    if(gridOut) *gridOut = grid;
    if(blockOut) *blockOut = block;
}
FILE_END
FILE_BEGIN chatGPT/src/k_otndc.cu
#include "otndc.h"
#include <cuda_runtime.h>
#include <math___constant__s.h>

////////////////////////////////////////////////////////////////////////////////
// __device__ helpers
////////////////////////////////////////////////////////////////////////////////
__device__ __forceinline__ float3 norm3(float3 v)
{
    float l = rsqrtf(v.x * v.x + v.y * v.y + v.z * v.z + 1e-20f);
    return make_float3(v.x * l, v.y * l, v.z * l);
}

__device__ __forceinline__ float dot3(float3 a, float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

__device__ __forceinline__ float3 cross3(float3 a, float3 b)
{
    return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

////////////////////////////////////////////////////////////////////////////////
// kernel: generate stralen voor boeren-ring + slot vote
////////////////////////////////////////////////////////////////////////////////
__global__ void k_oTNDCRays(const float* __restrict__ x, const float* __restrict__ y, const float* __restrict__ z,
                            int N, OTSlot* slots, int maxSlots, float binnen2, float buiten2, float minHoekCos)
{
    // per punt ‚Üí straal
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;

    float3 p  = make_float3(x[i], y[i], z[i]);
    float  r2 = dot3(p, p);

    // ring filter
    if(r2 < binnen2 || r2 > buiten2) return;

    float3 v = norm3(p);

    // warm-up cross bootstrap (met vorige in warp)
    // simpel: only with thread-1 if exists
    if(threadIdx.x > 0)
    {
        float3 vp = v; // current
        // but we need 3 floats: do it properly
        float  px    = __shfl_up_sync(0xffffffff, v.x, 1);
        float  py    = __shfl_up_sync(0xffffffff, v.y, 1);
        float  pz    = __shfl_up_sync(0xffffffff, v.z, 1);
        float3 vprev = make_float3(px, py, pz);

        float dp = fabsf(dot3(vp, vprev));
        if(dp < minHoekCos)
        {
            float3 cr = norm3(cross3(vp, vprev));
            // vote cross to slot 0 always during warmup
            atomicAdd(&slots[0].som.x, cr.x);
            atomicAdd(&slots[0].som.y, cr.y);
            atomicAdd(&slots[0].som.z, cr.z);
            atomicAdd(&slots[0].count, 1);
        }
    }

    // vote v to best slot or empty slot
    int   best    = -1;
    float bestDot = 0.f;

    for(int s = 0; s < maxSlots; ++s)
    {
        int c = slots[s].count;
        if(c == 0)
        {
            best = s;
            break;
        }
        float3 acc = slots[s].som;
        float3 dir = norm3(acc);
        float  d   = fabsf(dot3(v, dir));
        if(d > bestDot)
        {
            bestDot = d;
            best    = s;
        }
    }
    if(best < 0) return;

    atomicAdd(&slots[best].som.x, v.x);
    atomicAdd(&slots[best].som.y, v.y);
    atomicAdd(&slots[best].som.z, v.z);
    atomicAdd(&slots[best].count, 1);
}
FILE_END
FILE_BEGIN chatGPT/src/h_orchestratie.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cmath>
#include "include/config.h"
#include "include/wiskunde_utils.cuh"

// Helper
static inline float clampf(float x, float a, float b) {
    return std::max(a, std::min(b, x));
}

// ------------------------------------------------------------
// __host__ visuele check ‚Äî rotatie-voorspeller
// ------------------------------------------------------------
namespace __host__vis {

static inline void print_frame_nudge_preview(const Vec3f& asX,
                                             const Vec3f& asY,
                                             const Vec3f& asZ)
{
    Vec3f Z{0,0,1};
    Vec3f v = cross(Z, asZ);
    float c = dot(Z, asZ);
    float ang = std::acos( std::clamp(c, -1.0f, 1.0f) );
    Quat qz = (std::fabs(ang) < 1e-6f) ? Quat{1,0,0,0}
                                      : quat_from_axis_angle(v, ang);

    Vec3f X{1,0,0};
    Vec3f Xp = quat_rotate(qz, X);
    Vec3f t  = cross(Xp, asX);
    float c2 = dot(Xp, asX);
    float ang2 = std::acos( std::clamp(c2, -1.0f, 1.0f) );
    Quat qx = (std::fabs(ang2) < 1e-6f) ? Quat{1,0,0,0}
                                       : quat_from_axis_angle(t, ang2);

    Quat q = quat_mul(qx, qz);

    float yawDeg=0.f, pitchDeg=0.f;
    quat_to_ZY_angles(q, yawDeg, pitchDeg);

    float clip = cfg::get().stemmen.clipKleinGraads;
    clip_small_degrees(clip, yawDeg);
    clip_small_degrees(clip, pitchDeg);

    float maxLock = cfg::get().stemmen.maxLockGraads;
    bool reject   = (std::fabs(yawDeg) > maxLock ||
                     std::fabs(pitchDeg) > maxLock);

    std::cout << "[FrameCheck] Rotaties (Z,Y): yaw="
              << yawDeg << "¬∞, pitch=" << pitchDeg << "¬∞";
    if (reject) {
        std::cout << " [REJECT >" << maxLock << "¬∞]";
    }
    std::cout << "\n";
}

} // namespace __host__vis

// ------------------------------------------------------------
// Struct for logging
// ------------------------------------------------------------
struct StatBlok {
    uint32_t hitsTotaal   = 0;
    uint32_t hitsNieuw    = 0;
    uint32_t nearCount    = 0;
    uint32_t okCount      = 0;
    uint32_t slotCount    = 0;
    float    dHoekDeg     = 0.f;
    float    varCos       = 0.f;
    bool     locked       = false;
};

static inline void log_status(const StatBlok& s)
{
    std::cout << "hits+=" << s.hitsNieuw
              << " total=" << s.hitsTotaal
              << " near=" << s.nearCount
              << " ok=" << s.okCount
              << " slots=" << s.slotCount
              << " dHoek=" << std::fixed << std::setprecision(2)
              << s.dHoekDeg << "¬∞"
              << " varCos=" << std::setprecision(4) << s.varCos
              << " " << (s.locked ? "LOCKED" : "-")
              << std::endl;
}

// ------------------------------------------------------------
// Dummy orchestration loop ‚Äî compiles now
// When real __device__ stats exist, replace dummy block
// ------------------------------------------------------------
void h_run_orchestratie_logging_loop()
{
    StatBlok acc;
    uint32_t intervalHits = 0;

    // Dummy loop just once for test
    {
        uint32_t newlyAccepted = ORCH_LOG_INTERVAL;
        uint32_t nearIn        = ORCH_LOG_INTERVAL * 3 / 4;
        uint32_t okIn          = ORCH_LOG_INTERVAL * 1 / 4;
        uint32_t activeSlots   = 3;
        float dHoekDegSample   = 0.18f;
        float varCosSample     = 0.0017f;
        bool lockedNow         = true;

        intervalHits       += newlyAccepted;
        acc.hitsTotaal     += newlyAccepted;
        acc.nearCount      += nearIn;
        acc.okCount        += okIn;
        acc.slotCount       = activeSlots;
        acc.dHoekDeg        = dHoekDegSample;
        acc.varCos          = varCosSample;
        acc.locked          = lockedNow;
        acc.hitsNieuw       = intervalHits;

        log_status(acc);

        // ==== FINAL axes preview ====
        // üî• Dit is nu gewoon identity frame
        Vec3f asX{1,0,0}, asY{0,1,0}, asZ{0,0,1};
        __host__vis::print_frame_nudge_preview(asX, asY, asZ);
    }
}
FILE_END
FILE_BEGIN chatGPT/src/k_rotatie_quat.cu
#include "config.h"
#include "types.h"
#include "wiskunde_utils.cuh"
#include <cuda_runtime.h>

__device__ __forceinline__ Vec3f d_quat_apply(const Quatf& q, const Vec3f& v)
{
    Vec3f qv = make_vec3f(q.x, q.y, q.z);
    Vec3f t  = mul(cross(qv, v), 2.0f);
    Vec3f vp = v + mul(t, q.w) + mul(cross(qv, t), 1.0f);
    return vp;
}

__global__ void k_rotate_quat(const Quatf q, Vec3f* punten, const u8* mask, u32 N)
{
    u32 i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    if(mask && mask[i] == 0) return;
    punten[i] = d_quat_apply(q, punten[i]);
}

extern "C" void k_rotatie_quat_launch(const Quatf& q_norm, Vec3f* d_punten, const u8* d_mask, u32 N)
{
    if(!d_punten || N == 0) return;
    dim3 bs(256), gs((N + bs.x - 1) / bs.x);
    k_rotate_quat<<<gs, bs>>>(q_norm, d_punten, d_mask, N);
    cudaDeviceSynchronize();
}
FILE_END
FILE_BEGIN chatGPT/src/k_pairs_bucket.cu
#include "pairs_bucket.cuh"
#include <math___constant__s.h>

// ============ __device__ helpers ============
__device__ __forceinline__ float3 make3(float x, float y, float z) { return make_float3(x, y, z); }
__device__ __forceinline__ float  dot3(float3 a, float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__device__ __forceinline__ float3 cross3(float3 a, float3 b)
{
    return make3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
__device__ __forceinline__ float3 norm3(float3 v)
{
    float n2 = v.x * v.x + v.y * v.y + v.z * v.z;
    if(n2 < 1e-20f) return make3(0, 0, 0);
    float inv = rsqrtf(n2);
    return make3(v.x * inv, v.y * inv, v.z * inv);
}

// ============ kernel ============
// Per punt -> straal (v). In gedeeld geheugen een tile.
// Voor elk v: zoek binnen +- partnerZoekRadius in de tile 1 partner u
// met |dot(v,u)| <= maxDotOrtho; kies de beste (kleinste |dot|).
// Voeg a = normalize(cross(v,u)) bij aan globale accumulator met gewicht sin(theta).
extern "C" __global__ void k_otndc_pairs(const float* __restrict__ x, const float* __restrict__ y,
                                         const float* __restrict__ z, int N, float binnen2, float buiten2,
                                         float maxDotOrtho, int partnerZoekRadius, OTAsAccu* __restrict__ gAccu)
{
    extern __shared__ float sMem[]; // layout: vx[], vy[], vz[]
    float*                  sx = sMem;
    float*                  sy = sx + blockDim.x;
    float*                  sz = sy + blockDim.x;

    const int gid = blockIdx.x * blockDim.x + threadIdx.x;

    // Laad tile stralen (met ringfilter)
    float3 v = make3(0, 0, 0);
    if(gid < N)
    {
        float3 p  = make3(x[gid], y[gid], z[gid]);
        float  r2 = dot3(p, p);
        if(r2 >= binnen2 && r2 <= buiten2)
        {
            v = norm3(p); // straal = genormaliseerde plaatsvector
        }
    }
    sx[threadIdx.x] = v.x;
    sy[threadIdx.x] = v.y;
    sz[threadIdx.x] = v.z;
    __syncthreads();

    // Zoek √©√©n partner in de tile
    if(gid >= N) return;
    if(v.x == 0.f && v.y == 0.f && v.z == 0.f) return; // buiten ring

    float  bestAbsDot = 1e9f;
    float3 bestU      = make3(0, 0, 0);

    // Zoek rondom huidige thread (beperkt venster)
    const int t = threadIdx.x;
    const int L = max(0, t - partnerZoekRadius);
    const int R = min(blockDim.x - 1, t + partnerZoekRadius);

    for(int j = L; j <= R; ++j)
    {
        if(j == t) continue;
        float3 u = make3(sx[j], sy[j], sz[j]);
        if(u.x == 0.f && u.y == 0.f && u.z == 0.f) continue;

        float d = fabsf(dot3(v, u)); // |cos theta|
        if(d <= maxDotOrtho && d < bestAbsDot)
        {
            bestAbsDot = d;
            bestU      = u;
        }
    }

    if(bestAbsDot == 1e9f) return; // geen geschikte partner

    // Kruisproduct ‚Üí as-sample
    float3 a  = cross3(v, bestU);
    float  a2 = dot3(a, a);
    if(a2 < 1e-20f) return;
    float inv = rsqrtf(a2);
    a.x *= inv;
    a.y *= inv;
    a.z *= inv;

    // Gewicht: sin(theta) = sqrt(1 - cos^2)
    float w = sqrtf(fmaxf(0.f, 1.f - bestAbsDot * bestAbsDot));

    // Atomics naar globale accu
    atomicAdd(&gAccu->som.x, a.x * w);
    atomicAdd(&gAccu->som.y, a.y * w);
    atomicAdd(&gAccu->som.z, a.z * w);
    atomicAdd(&gAccu->count, 1);
}
FILE_END
FILE_BEGIN chatGPT/src/k_r1r2_filter.cu
#include "consts.cuh"
#include "types.cuh"
#include <cuda_runtime.h>

/*
k_r1r2_filter
-------------

In:  d_pts (Vec3f*), N
Out: d_mask_tri (uint8*)  : 1 = mini-triangle kandidaat (exclusief), 0 anders
d_norm_tri (float3*) : normale van (c,a,b) indien mask==1
d_inlier_slab (int*) : aantal slab-inliers binnen r2 (voor chaos veto)
d_is_chaos (uint8*)  : 1 = chaos, 0 = ok
NB: eenvoudige implementatie: per punt c zoeken we 2 dichtste in ring [r1‚Ä¶r2], dan exclusiviteitscheck.

ASCII:
r2
.-----.
/       \    ring [r1..r2], kies 2 dichtste {a,b}, check max(|c-a|,|c-b|) <= r2/2 - 1mm
|    c    |
\       /
'-----'
r1
*/

__device__ inline float3 make3(const Vec3f& p) { return make_float3(p.x, p.y, p.z); }
__device__ inline float  dot3(const float3 a, const float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__device__ inline float3 cross3(const float3 a, const float3 b)
{
    return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
__device__ inline float  len3(const float3 v) { return sqrtf(dot3(v, v)); }
__device__ inline float3 norm3(const float3 v)
{
    float L = len3(v);
    return (L > 0) ? make_float3(v.x / L, v.y / L, v.z / L) : make_float3(0, 0, 0);
}

__global__ void k_r1r2_filter(const Vec3f*** restrict** d_pts, int N, uint8_t*** restrict** d_mask_tri,
                              float3*** restrict** d_norm_tri, int*** restrict** d_inlier_slab,
                              uint8_t*** restrict** d_is_chaos)
{
    const int i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;

    const float r1      = Consts::R1_CLUSTER;
    const float r2      = Consts::R2_RING;
    const float r2h     = Consts::R2_HALF_CLAIM_SAFE;
    const float slabTol = Consts::SLAB_TOL;

    const float3 c = make3(d_pts[i]);

    // eenvoudig: brute buurt (N) ‚Äî in praktijk: per tile/voxel buurtlijst
    // DEMO: we gaan lineair door (kan later getiled worden)
    float best1 = 1e9f, best2 = 1e9f;
    int   ia = -1, ib = -1;

    for(int j = 0; j & lt; N; j++)
    {
        if(j == i) continue;
        const float3 q = make3(d_pts[j]);
        float        d = len3(make_float3(q.x - c.x, q.y - c.y, q.z - c.z));
        if(d& lt; r1 - Consts::LIDAR_HALF_ERROR) continue;
        if(d& gt; r2 + Consts::LIDAR_HALF_ERROR) continue;

        if(d& lt; best1)
        {
            best2 = best1;
            ib    = ia;
            best1 = d;
            ia    = j;
        } else if(d& lt; best2)
        {
            best2 = d;
            ib    = j;
        }
    }

    // init outputs
    d_mask_tri[i]    = 0;
    d_is_chaos[i]    = 0;
    d_inlier_slab[i] = 0;
    d_norm_tri[i]    = make_float3(0, 0, 0);

    // slab inliers quick check (vlak vs chaos)
    int slabCnt = 0;
    if(ia& gt; = 0 & amp; &ib& gt; = 0)
    {
        // normale van driehoek (c,a,b)
        const float3 a = make3(d_pts[ia]);
        const float3 b = make3(d_pts[ib]);
        const float3 n =
            norm3(cross3(make_float3(a.x - c.x, a.y - c.y, a.z - c.z), make_float3(b.x - c.x, b.y - c.y, b.z - c.z)));

        // slab door c met normaal n: |dot(n, p-c)| <= slabTol
        for(int j = 0; j & lt; N; j++)
        {
            float3 q  = make3(d_pts[j]);
            float3 qc = make_float3(q.x - c.x, q.y - c.y, q.z - c.z);
            float  ad = fabsf(dot3(n, qc));
            if(ad& lt; = slabTol) slabCnt++;
        }

        d_inlier_slab[i] = slabCnt;

        // exclusiviteitscheck
        const bool triOk = (best1& lt; = r2h) & amp;
        &(best2 & lt; = r2h);
        if(triOk)
        {
            d_mask_tri[i] = 1;
            d_norm_tri[i] = n;
        }
    }

    // chaos veto
    // cheap 8mm-range + inliers<4
    // (range berekenen: hier approximatie via min/max in X/Y/Z; demo: subsample)
    if(slabCnt& lt; = Consts::SLAB_MIN_INLIERS - 1)
    {
        // heuristische cheap-check: markeer chaos indien geen triangle en weinig slab-inliers
        if(!d_mask_tri[i]) d_is_chaos[i] = 1;
    }
}
FILE_END
FILE_BEGIN legacy/include/planaire_regressie.cuh
#pragma once
#include "math_hulpfuncties.cuh"

namespace jbf
{

    // Klein helper: 1D richtingsfit in vlak met trim van 3 grootste residuen.
    // Voor simpelheid nemen we hier een lineaire fit y = a x + b in lokaal 2D.
    struct RegressieUitkomst
    {
        float3 dir;  // richting in 3D (teruggeheven naar vlak)
        float  a, b; // optioneel, parameters in 2D
    };

    template <int K = 3>
    __device__ __forceinline__ RegressieUitkomst
    d_lineaireRegressieInVlak(const float3* __restrict__ pts, const uint32_t* __restrict__ idx, uint32_t M,
                              const float3& vlak_norm, // u-of-v normaal voor dit doorsnedevlak
                              const float3& tang,      // tangent-richting binnen het projectievlak (u of v)
                              const float3& n_current) // huidige n (voor 3D lift)
    {
        // Projecteer naar lokaal 2D: x = dot(p,tang), y = dot(p, n_current √ó tang)
        float3 ortho = d_norm3(d_cross3(n_current, tang));

        // 1e pass: residuen bepalen t.o.v. grove fit (we nemen in JBF-stijl eerst moment-statistiek)
        // Voor eenvoud: eerste fit via moment (‚àëx, ‚àëy, ‚àëxy, ‚àëx^2)
        float    Sx = 0.f, Sy = 0.f, Sxy = 0.f, Sxx = 0.f;
        uint32_t N = 0;
        for(uint32_t i = 0; i < M; ++i)
        {
            const float3 p = pts[idx[i]];
            float        x = jbf::d_dot3(p, tang);
            float        y = jbf::d_dot3(p, ortho);
            Sx += x;
            Sy += y;
            Sxy += x * y;
            Sxx += x * x;
            ++N;
        }
        float denom = fmaxf(1e-12f, (N * Sxx - Sx * Sx));
        float a     = (N * Sxy - Sx * Sy) / denom;
        float b     = (Sy - a * Sx) / fmaxf(1e-12f, N);

        // Zoek K grootste residuen (|y - (ax+b)|), markeer die.
        float worst[K];
        int   worstIdx[K];
#pragma unroll
        for(int k = 0; k < K; ++k)
        {
            worst[k]    = -1.f;
            worstIdx[k] = -1;
        }

        for(uint32_t i = 0; i < M; ++i)
        {
            const float3 p = pts[idx[i]];
            float        x = jbf::d_dot3(p, tang);
            float        y = jbf::d_dot3(p, ortho);
            float        r = fabsf(y - (a * x + b));
            // kleine top-K selectie
            int m = 0;
            for(int k = 1; k < K; ++k)
                if(worst[k] < worst[m]) m = k;
            if(r > worst[m])
            {
                worst[m]    = r;
                worstIdx[m] = i;
            }
        }

        // 2e pass: refit zonder die K outliers
        Sx = Sy = Sxy = Sxx = 0.f;
        N                   = 0;
        for(uint32_t i = 0; i < M; ++i)
        {
            bool skip = false;
#pragma unroll
            for(int k = 0; k < K; ++k)
                if(i == (uint32_t)worstIdx[k])
                {
                    skip = true;
                    break;
                }
            if(skip) continue;

            const float3 p = pts[idx[i]];
            float        x = jbf::d_dot3(p, tang);
            float        y = jbf::d_dot3(p, ortho);
            Sx += x;
            Sy += y;
            Sxy += x * y;
            Sxx += x * x;
            ++N;
        }
        denom = fmaxf(1e-12f, (N * Sxx - Sx * Sx));
        a     = (N * Sxy - Sx * Sy) / denom;
        b     = (Sy - a * Sx) / fmaxf(1e-12f, N);

        // Richting in 2D is langs toenemende x ‚Üí 3D richting is 'tang' (y verandert met a*x)
        // We kunnen de 3D richting in vlak kiezen als unit(tang + a * ortho) maar dat maakt hem schuin.
        // Voor jouw doel: de *richting-as* binnen het doorsnedevlak is primair 'tang'.
        // We geven hier 'tang' terug als dominante richting in dit vlak.
        RegressieUitkomst out;
        out.dir = tang;
        out.a   = a;
        out.b   = b;
        return out;
    }

    __device__ __forceinline__ float3 d_planaireRegressie(const float3* __restrict__ pts,
                                                          const uint32_t* __restrict__ idx, uint32_t M,
                                                          const float3& n_in, const float3& X, const float3& Y,
                                                          const float3& Z, float cosParallelMax, float maxRefineDeg)
    {
        float3 u, v;
        jbf::d_bepaal_u_v_uit_n(n_in, X, Y, Z, cosParallelMax, u, v);

        // Regressie in U-doorsnede (vlak bepaald door n_in en u)
        auto ruU = d_lineaireRegressieInVlak(pts, idx, M, /*vlak_norm=*/n_in, /*tang=*/u, /*n=*/n_in);
        // Regressie in V-doorsnede
        auto ruV = d_lineaireRegressieInVlak(pts, idx, M, /*vlak_norm=*/n_in, /*tang=*/v, /*n=*/n_in);

        float3 n_star = jbf::d_norm3(jbf::d_cross3(ruU.dir, ruV.dir));
        return jbf::d_clamp_richting(n_in, n_star, maxRefineDeg);
    }

} // namespace jbf
FILE_END
FILE_BEGIN legacy/include/voxel_params.h
#pragma once
#include <cstdint>
#include <cuda_runtime.h>

namespace grid {

// voxel raster (kubisch binnen regio)
struct VoxelRaster {
    uint32_t S;           // voxels per as (bv. 64 of 128)
    float    h;           // voxel edge length (meters in geschaalde ruimte)
    uint32_t dimX, dimY, dimZ; // identiek aan S; expliciet voor leesbaarheid
};

// __device__-buffers (gemaakt door jouw sort/voxel fase)
struct VoxelIndexing {
    // Per-voxel start/eind in punten-array (Morton-geordend):
    // starts[v] .. starts[v+1]-1
    const uint32_t* d_voxelStarts; // size = numVoxels+1
    const uint32_t* d_pointToVoxel; // size = N (optioneel; snel checken)
    uint32_t        numVoxels;
};

__host__ __device__ inline
uint32_t flatten(uint32_t x, uint32_t y, uint32_t z,
                 uint32_t Sx, uint32_t Sy, uint32_t Sz)
{
    return (z * Sy + y) * Sx + x;
}

} // namespace grid
FILE_END
FILE_BEGIN legacy/include/morton_utils.cuh
#pragma once
//
// morton_utils.cuh -- LSB-first 3D Morton encode/decode + composite key
//
#include "math_utils.cuh"
#include <cstdint>

namespace Bocari
{
    namespace Cuda
    {

        // expand 10 bits into 30 with 2 zeros between
        __host__ __device__ __forceinline__ uint32_t expandBitsBy2(uint32_t v)
        {
            v &= 0x000003ffu; // 10 bits
            v = (v | (v << 16)) & 0x30000ffu;
            v = (v | (v << 8)) & 0x300f00fu;
            v = (v | (v << 4)) & 0x30c30c3u;
            v = (v | (v << 2)) & 0x9249249u;
            return v;
        }

        // Interleave lower 21 bits safely (we'll usually pass fewer)
        __host__ __device__ __forceinline__ uint64_t morton3D(uint32_t x, uint32_t y, uint32_t z)
        {
            // Use 21-bit safe method by expanding lower 21 bits in chunks of 10+11
            uint64_t xx = expandBitsBy2(x);
            uint64_t yy = expandBitsBy2(y);
            uint64_t zz = expandBitsBy2(z);
            return (zz << 2) | (yy << 1) | xx; // LSB-first triplets
        }

        // Deinterleave back (only for small bit counts used; for debugging/labels)
        __host__ __device__ __forceinline__ uint32_t compactBitsBy2(uint32_t v)
        {
            v &= 0x9249249u;
            v = (v ^ (v >> 2)) & 0x30c30c3u;
            v = (v ^ (v >> 4)) & 0x300f00fu;
            v = (v ^ (v >> 8)) & 0x30000ffu;
            v = (v ^ (v >> 16)) & 0x000003ffu;
            return v;
        }

        __host__ __device__ __forceinline__ void morton3D_decode(uint64_t code, uint32_t& x, uint32_t& y, uint32_t& z)
        {
            x = compactBitsBy2(static_cast<uint32_t>(code));
            y = compactBitsBy2(static_cast<uint32_t>(code >> 1));
            z = compactBitsBy2(static_cast<uint32_t>(code >> 2));
        }

        // Build composite key: high bits = voxelMorton, low bits = fineMorton
        __host__ __device__ __forceinline__ uint64_t makeCompositeKey(uint32_t xi, uint32_t yi, uint32_t zi,
                                                                      const ConstsStruct& voxel,
                                                                      const ConstsStruct& sub)
        {
            const uint32_t coarseX = xi >> sub.bits;
            const uint32_t coarseY = yi >> sub.bits;
            const uint32_t coarseZ = zi >> sub.bits;
            const uint32_t fineX   = xi & sub.mask;
            const uint32_t fineY   = yi & sub.mask;
            const uint32_t fineZ   = zi & sub.mask;

            const uint64_t voxelMorton = morton3D(coarseX, coarseY, coarseZ);
            const uint64_t fineMorton  = morton3D(fineX, fineY, fineZ);
            const uint32_t shift       = 3u * sub.bits;
            return (voxelMorton << shift) | fineMorton;
        }

    } // namespace Cuda
} // namespace Bocari
FILE_END
FILE_BEGIN legacy/include/math_utils.cuh
#pragma once
//
// math_utils.cuh  -- __host__/__device__ helpers and run logs
//
#include <cstdint>
#include <cuda_runtime.h>

namespace Bocari
{
    namespace Cuda
    {

        using u32 = uint32_t;
        using u64 = uint64_t;

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Compile-time helpers
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        __host__ __device__ __forceinline__ constexpr u32 log2u(u32 n) noexcept
        {
            u32 bits = 0;
            while((1u << bits) < n) ++bits;
            return bits;
        }
        __host__ __device__ __forceinline__ constexpr u32 maskFor(u32 n) noexcept { return n - 1u; }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Numeric helpers
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        __host__ __device__ __forceinline__ constexpr float  sqr(float x) noexcept { return x * x; }
        __host__ __device__ __forceinline__ constexpr double sqr(double x) noexcept { return x * x; }
        __host__ __device__ __forceinline__ constexpr u32    sqr(u32 x) noexcept { return x * x; }

        template <typename T> __host__ __device__ __forceinline__ constexpr T pow2(T x) noexcept { return x * x; }

        template <typename Vec3> __host__ __device__ __forceinline__ float length2(const Vec3& v) noexcept
        {
            return sqr(v.x) + sqr(v.y) + sqr(v.z);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Grid __constant__s bundle (keeps N, bits, mask consistent)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        struct ConstsStruct
        {
            u32 N;    // cells per axis
            u32 bits; // log2(N)
            u32 mask; // N-1
        };

        template <u32 S> __host__ __device__ __forceinline__ constexpr ConstsStruct makeConsts() noexcept
        {
            return ConstsStruct{S, log2u(S), maskFor(S)};
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Flatten / unflatten for regular 3D lattice with N^3 cells
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        template <u32 N> __host__ __device__ __forceinline__ u32 flatten3(u32 z, u32 y, u32 x) noexcept
        {
            constexpr u32 shift = log2u(N);
            return (z << (2 * shift)) | (y << shift) | x;
        }

        template <u32 N> __host__ __device__ __forceinline__ void unflatten3(u32 idx, u32& z, u32& y, u32& x) noexcept
        {
            constexpr u32 shift = log2u(N);
            constexpr u32 mask  = maskFor(N);
            x                   = idx & mask;
            y                   = (idx >> shift) & mask;
            z                   = (idx >> (2 * shift)) & mask;
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // GPU run logging
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        struct AxisCounts
        {
            u32 topBottom        = 0; // horizontals
            u32 northSouth       = 0; // vertical N-Z
            u32 eastWest         = 0; // vertical E-W
            u32 foldedTopBottom  = 0;
            u32 foldedNorthSouth = 0;
            u32 foldedEastWest   = 0;

            __host__ __device__ inline void reset()
            {
                topBottom = northSouth = eastWest = 0;
                foldedTopBottom = foldedNorthSouth = foldedEastWest = 0;
            }
        };

        struct GpuRunLog
        {
            // step flags
            bool frameWasIdeal   = false;
            bool planesDetected  = false;
            bool rotationApplied = false;
            bool downsampled     = false;
            bool completed       = false;

            AxisCounts planes;

            float  rotationAngleDeg = 0.0f;
            float3 rotationAxis     = {0.f, 0.f, 0.f};

            // counts for downsample result
            u32 downsampleOutCount = 0;

            __host__ __device__ inline void reset()
            {
                frameWasIdeal = planesDetected = rotationApplied = downsampled = completed = false;
                planes.reset();
                rotationAngleDeg   = 0.f;
                rotationAxis       = {0.f, 0.f, 0.f};
                downsampleOutCount = 0;
            }
        };

        // Simple quaternion container (w + xyz)
        struct Quat
        {
            float w{1.f}, x{0.f}, y{0.f}, z{0.f};
        };

    } // namespace Cuda
} // namespace Bocari
FILE_END
FILE_BEGIN legacy/include/types.cuh
#pragma once
// Nederlandse identifiers, behalve: seed, triangle, forest, tree
#include <cuda_runtime.h>
#include <math.h>
#include <stdint.h>

using u8  = uint8_t;
using u16 = uint16_t;
using u32 = uint32_t;
using u64 = uint64_t;

struct Vec3f
{
    float x, y, z;
};

__host__ __device__ inline Vec3f maak_vec3(float x, float y, float z) { return {x, y, z}; }
__host__ __device__ inline float dot(const Vec3f& a, const Vec3f& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__host__ __device__ inline Vec3f cross(const Vec3f& a, const Vec3f& b)
{
    return {a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x};
}
__host__ __device__ inline float lengte2(const Vec3f& a) { return dot(a, a); }
__host__ __device__ inline float lengte(const Vec3f& a) { return sqrtf(lengte2(a)); }
__host__ __device__ inline Vec3f norm(const Vec3f& a)
{
    float L = lengte(a);
    return L > 0 ? maak_vec3(a.x / L, a.y / L, a.z / L) : maak_vec3(0, 0, 0);
}
__host__ __device__ inline Vec3f plus(const Vec3f& a, const Vec3f& b) { return {a.x + b.x, a.y + b.y, a.z + b.z}; }
__host__ __device__ inline Vec3f minv(const Vec3f& a, const Vec3f& b) { return {a.x - b.x, a.y - b.y, a.z - b.z}; }
__host__ __device__ inline Vec3f schaal(const Vec3f& a, float s) { return {a.x * s, a.y * s, a.z * s}; }

// deterministische (u,v) ‚üÇ n
__host__ __device__ inline void basis_uv_orthonormaal(const Vec3f& n, Vec3f& u, Vec3f& v)
{
    Vec3f h = (fabsf(n.x) < 0.9f) ? maak_vec3(1, 0, 0) : maak_vec3(0, 1, 0);
    u       = norm(cross(h, n));
    v       = norm(cross(n, u));
}

// hemisfeer fold (n.z ‚â• 0)
__host__ __device__ inline Vec3f hemisfeer_fold(const Vec3f& a) { return (a.z < 0.0f) ? schaal(a, -1.0f) : a; }

// simpele octahedral mapping naar [0,1]^2
__host__ __device__ inline void octa_map(const Vec3f& n, float& ox, float& oy)
{
    float ax = fabsf(n.x), ay = fabsf(n.y), az = fabsf(n.z);
    float s = ax + ay + az + 1e-20f;
    float x = n.x / s, y = n.y / s;
    if(n.z < 0)
    {
        float xo = (n.x >= 0) ? 1.0f - fabsf(y) : -1.0f + fabsf(y);
        float yo = (n.y >= 0) ? 1.0f - fabsf(x) : -1.0f + fabsf(x);
        x        = xo;
        y        = yo;
    }
    ox = x * 0.5f + 0.5f;
    oy = y * 0.5f + 0.5f;
}

__host__ __device__ inline u32 kwantiseer_octa_key(const Vec3f& dir, u32 Nx, u32 Ny)
{
    Vec3f f = hemisfeer_fold(norm(dir));
    float ox, oy;
    octa_map(f, ox, oy);
    u32 ix = (u32)fminf(fmaxf(ox * Nx, 0.0f), (float)(Nx - 1));
    u32 iy = (u32)fminf(fmaxf(oy * Ny, 0.0f), (float)(Ny - 1));
    return (iy * Nx) + ix; // 2D ‚Üí 1D
}
FILE_END
FILE_BEGIN legacy/include/voxelprocessor.h
#pragma once
#include "grid_utils.h"
#include "includes.h"
#include "point.h"
#include "strict.h"

// Debug macro
// clang-format off
#define _DEBUG
#define VOXEL_DEBUG

#ifdef VOXEL_DEBUG
   #define VOXEL_DBG(x) do { x; } while(0)
#else
   #define VOXEL_DBG(x) do { } while(0)
#endif
// clang-format on

namespace Bocari
{
    namespace Math
    {
        using Vec3f = Vec3T<float>;
        using Vec3d = Vec3T<double>;
    } // namespace Math
} // namespace Bocari

namespace Bocari
{
    namespace Voxelprocessing
    {
        // __constant__s
        constexpr u32    c_radix                = 1024u;             // 10 bits per component for radix sort
        constexpr u32    c_voxel                = 32u;               // top-level grid dimension (5 bits: 2^5=32)
        constexpr u32    c_subvoxel             = 32u;               // sub-voxel grid dimension (5 bits: 2^5=32)
        constexpr u32    c_bins_per_group       = c_radix / c_voxel; // Number of bins per group (32)
        constexpr double c_slice_to_voxel_scale = static_cast<double>(c_radix / c_voxel); // 1024/32 = 32.0

        // DensityRanges structure
        struct MediumVoxelRange
        {
            u32 minCount;
            u32 maxCount;

            // Extra stats for debugging/auditing:
            double p25_value;
            double p50_value;
            double p75_value;
        };

        class VoxelManager;
        class Voxel;
        class SubVoxel;

        struct OnlinePCA
        {
            int32_t        n = 0;
            Math::Vec3d    mean{0.0, 0.0, 0.0};
            Math::Matrix3d M2; // covariance accumulator

            void           reset();
            void           update(const Math::Vec3d& x);
            Math::Matrix3d covariance() const;
        };

        class Voxel
        {
        public:
            Voxel() = default;
            Voxel(u32 index_1D, const VoxelManager* manager, Voxelprocessing::GridUnion<c_subvoxel>& subVoxelStarts);

            u32      start() const;
            u32      count() const;
            void     getIndices(u32& x, u32& y, u32& z) const;
            void     ensureSubvoxelStartsComputed() const;
            SubVoxel getSubVoxel(u32 x, u32 y, u32 z) const;
            void     buildSubVoxelCumSum() const;
            bool     hasSubVoxelCumSum() const { return m_subvoxelCumSumComputed; }

            bool detectPlane();

        private:
            u32           m_index_1D = 0;
            u32           m_x = 0u, m_y = 0u, m_z = 0u;
            VoxelManager* m_manager                = nullptr;
            mutable bool  m_subvoxelStartsComputed = false;
            mutable bool  m_subvoxelCumSumComputed = false;

        public:
            mutable Voxelprocessing::GridUnion<c_subvoxel>* m_subvoxelStarts = nullptr;
            mutable Voxelprocessing::GridUnion<c_subvoxel>  m_subvoxelCumSum;

            friend class VoxelManager;
        };

        struct RangeData
        {
            Math::Vec3d range;
            Math::Vec3d invRange;

            void computeVoxelSizeData(const Math::Vec3d& bbMax, u32 c)
            {
                double f = 1.0 / static_cast<double>(c);
                range    = bbMax * f;
                invRange = {1.0 / range.x, 1.0 / range.y, 1.0 / range.z};
            }
        };

        class SubVoxel
        {
        public:
            SubVoxel() = default;
            SubVoxel(const Voxel& voxel, u32 x, u32 y, u32 z);
            SubVoxel(u32 index_1D, u32 start, u32 count, const Math::Vec3d& bbMin);

            void getIndices(u32& x, u32& y, u32& z) const
            {
                x = m_x;
                y = m_y;
                z = m_z;
            }

            u32 getIndex_1D() const { return m_index_1D; }

            u32                start() const { return m_start; }
            u32                count() const { return m_count; }
            const Math::Vec3d& bbMin() const { return m_bbMin; }

        private:
            u32         m_index_1D = 0u;
            u32         m_x = 0u, m_y = 0u, m_z = 0u;
            u32         m_start = 0u;
            u32         m_count = 0u;
            Math::Vec3d m_bbMin{0.0, 0.0, 0.0};
        };

        struct NormalizationResult
        {
            double      scale;
            bool        needsScaling;
            Math::Vec3d bbMinOrg;
            Math::Vec3d bbMaxTranslatedScaled;
        };

        class VoxelManager
        {
        public:
            VoxelManager();
            NormalizationResult computeNormalizationParameters(ccPointCloud* cloud);
            void                voxelize(ccPointCloud* cloud);
            void                getVoxel(u32 x, u32 y, u32 z, Voxel& out,
                                         Voxelprocessing::GridUnion<c_subvoxel>& subVoxelStarts) const;
            void                getVoxelById(u32 flatIndex, Voxel& out, GridUnion<c_subvoxel>& subVoxelStarts) const;
            bool                isMediumDensityVoxel(u32 index) const;
            u32                 countPointsInVoxelBox(const Voxel& voxel1, const Voxel& voxel2) const;
            u32                 countPointsInSubVoxelBox(const Voxel& voxel, const SubVoxel& subvoxel1,
                                                         const SubVoxel& subvoxel2) const;

            void buildVoxelCumSum() const;
            bool hasVoxelCumSum() const { return m_voxelCumSumComputed; }
            void initMediumVoxel();

            // Public members for direct access
            Voxelprocessing::NormalizationResult        m_normResult{1.0, false, Math::Vec3d{0.0, 0.0, 0.0},
                                                              Math::Vec3d{0.0, 0.0, 0.0}};
            Voxelprocessing::RangeData                  m_sliceRange;
            mutable Voxelprocessing::GridUnion<c_voxel> m_voxelCounts;
            mutable Voxelprocessing::GridUnion<c_voxel> m_voxelStarts;
            mutable Voxelprocessing::GridUnion<c_voxel> m_voxelCumSum;
            std::vector<Pointcloud::Point>              groupedPoints;
            MediumVoxelRange                            m_mediumVoxelRange; // Medium density.
            static VoxelManager*                        s_pInstance;

        private:
            const double maxAllowedSize       = 1000.0;
            const double maxAllowedScaledSize = 100.0;

            void computeVoxelMediumRange();

        private:
            mutable bool m_voxelStartsComputed = false;
            mutable bool m_voxelCumSumComputed = false;
        };

        double normalizePointCloud(ccPointCloud* cloud, Math::Vec3d& bbMin, Math::Vec3d& bbMax);

    } // namespace Voxelprocessing
} // namespace Bocari
FILE_END
FILE_BEGIN legacy/include/vlak_types.h
#pragma once
#include <cstdint>
#include <cuda_runtime.h>

namespace jbf {

enum Label : uint8_t {
    ONGELABELD = 0,
    RUIS       = 1,
    VLAK       = 2,
    // later: BUIS=3, BOCHT=4, T_STUK=5, ...
};

struct PlaneHyp {
    float3 n;            // unit normaal
    float  d;            // vlakvergelijking: n¬∑x = d
    uint32_t count;      // #kept punten (na slab + trim)
    float    rms;        // kwaliteit (optioneel gate)
    uint32_t areaHint;   // ruwe maat voor oppervlak (projectie/bbox/extent)
};

// Tuning (kan later naar __constant__ als runtime zelden wijzigt)
struct VlakTuning {
    float cosParallelMax = 0.9f;        // œÑ‚Äñ voor u-keuze
    float slabEps        = 0.005f;      // fine slab half-thickness (m)
    float maxRefineDeg   = 2.0f;        // clamp n* deviate
    float edgeMin        = 0.03f;       // 3 cm, min driehoekszijde (m)
    float edgeMax        = 0.30f;       // 30 cm, max driehoekszijde (m)
    float hoekMaxDeg     = 10.0f; // zaad-Œîhoek tov doel-normaal
    float ruisStraal     = 0.003f; // 3 mm (boeren 2e buur)
    int   kTrim          = 3;           // Trim-K
    uint32_t minSupport  = 200;         // minimale punten voor accept
    float maxRms         = 0.0035f;     // maximale RMS voor accept
};

} // namespace jbf
FILE_END
FILE_BEGIN legacy/include/consts.cuh
#pragma once
#include <stdint.h>
#include "types.cuh"

namespace Tuning {
// Afstandsdrempels voor snelle heuristiek (vlak check) per voxel/triangle:
constexpr float EPS_NEAR2 = 1e-6f;   // "dichtbij": d^2 ‚â§ EPS_NEAR2  (bv. 1 mm ‚Üí 0.001^2)
constexpr float TAU_FAR2  = 0.04f;   // "ver":      d^2 ‚â• TAU_FAR2   (bv. 20 mm ‚Üí 0.02^2)

// Waarom NEAR "eps" en FAR "tau"?
// - "eps" gebruiken we traditioneel voor "kleine" toleranties (nabij het vlak).
// - "tau" (œÑ) als "grotere drempel" om duidelijk te maken dat dit geen mini-tolerantie is.


    static constexpr int   MIN_NEAR  = 6;         // min support
    static constexpr int   MAX_FAR   = 2;

// Buisstraalband (annulus) voor annulus/wedge scan:
constexpr float R_MIN     = 0.025f;  // 2.5 cm  (kleinste te verwachten buis)
constexpr float R_MAX     = 0.40f;   // 40  cm  (typisch plafond/utility)
                                      // (kan naar 1.0f als jouw data dat vereist)

// Halve-cirkel sectoren (zodat +v en -v samenvallen voor as-richting):
constexpr int   SECTORS_HALF = 24;   // 24 sectoren in [0, œÄ). Fijner ‚Üí nauwkeuriger, duurder.

    // globale octa-grid voor richtingkeys
    static constexpr u32 OCT_NX = 64;
    static constexpr u32 OCT_NY = 64;

    // LRU-lite slots (nu niet gebruikt in deze minimale set)
    static constexpr int LRU_K = 8;
}

enum PuntLabel : u8 { LABEL_NONE=0, LABEL_RUIS, LABEL_VLAK, LABEL_BUIS };
enum VoxelKlasse : u8 { VOX_GEEN=0, VOX_VLAK_SEED, VOX_BUIS_KAND, VOX_RUIS };

struct VoxelBereik { u32 start; u32 eind; };  // [start,eind)

struct KeyCount { u32 key; u32 count; };
FILE_END
FILE_BEGIN legacy/src/vlak_orchestratie.cpp
#include <vector>
#include <cuda_runtime.h>
#include "vlak_types.h"
#include "voxel_params.h"

using namespace jbf;
using namespace grid;

// Helpers voor launches (kies je eigen block/grid config)
static inline dim3 blok(uint32_t n) { return dim3( min<uint32_t>(256,n) ); }
static inline dim3 rooster(uint32_t n) { return dim3( (n + 255)/256 ); }

// Kernels (extern "C" uit .cu‚Äôs)
extern __global__ void k_initLabels(uint8_t*, uint32_t, uint8_t);
extern __global__ void k_ruisBoerenTweedeBuur(const float3*, uint8_t*, uint32_t, VoxelRaster, VoxelIndexing, float);
struct ZaadDriehoek; // fwd
extern __global__ void k_vindDriehoekZadenLangsRichting(const float3*, const uint8_t*, uint32_t,
                                                        VoxelRaster, VoxelIndexing,
                                                        float3, float, float, float,
                                                        uint32_t, ZaadDriehoek*, uint32_t*);

// TODO: k_bepaalSlabPunten, k_planaireRegressie, k_bepaalD_TrimK zitten in jouw andere CU‚Äôs
extern __global__ void k_bepaalSlabPunten(const float3*, const uint8_t*, uint32_t,
                                          float3, float, float,
                                          uint32_t*, uint32_t, uint32_t*);
extern __global__ void k_bepaalD_TrimK(const float3*, const uint32_t*, uint32_t,
                                       float3, int, float*, float*, uint32_t*);
// d_planaireRegressie zit als __device__ helper; maak evt. wrapper-kernel als je die __device__-weg wil houden

// Orchestratie voor 1 richting
bool vindVlakkenLangsRichting(const float3* d_pts,
                              uint8_t* d_labels,
                              uint32_t N,
                              VoxelRaster vr,
                              VoxelIndexing vx,
                              float3 n_as,
                              const VlakTuning& tun,
                              std::vector<PlaneHyp>& uit)
{
    // 0) ruis-filter
    k_ruisBoerenTweedeBuur<<<vx.numVoxels, 128>>>(d_pts, d_labels, N, vr, vx, tun.ruisStraal);
    cudaDeviceSynchronize();

    // 1) zaden (strak: kleine driehoeken, bandpass, hoek tov n_as)
    uint32_t maxZaden = 1'000'000; // cap; tuning
    ZaadDriehoek* d_zaden = nullptr; cudaMalloc(&d_zaden, maxZaden * sizeof(ZaadDriehoek));
    uint32_t* d_zCount = nullptr;   cudaMalloc(&d_zCount, sizeof(uint32_t));
    cudaMemset(d_zCount, 0, sizeof(uint32_t));

    float cosHoekMin = cosf(tun.hoekMaxDeg * 3.1415926535f / 180.f);
    k_vindDriehoekZadenLangsRichting<<<vx.numVoxels, 128>>>(d_pts, d_labels, N, vr, vx,
                                                            n_as,
                                                            tun.edgeMin, tun.edgeMax,
                                                            cosHoekMin,
                                                            /*maxZadenPerVoxel*/ 64,
                                                            d_zaden, d_zCount);
    cudaDeviceSynchronize();

    uint32_t h_zCount=0; cudaMemcpy(&h_zCount, d_zCount, sizeof(uint32_t), cudaMemcpyDeviceToHost);
    if (h_zCount == 0) { cudaFree(d_zaden); cudaFree(d_zCount); return false; }

    // 2) per zaad: slabpunten rond d0 = n_as¬∑centroid ‚Üí planaireRegressie ‚Üí d (Trim-K) ‚Üí gates ‚Üí output
    //    (hier: demonstratief 1 zaad pakken; jij maakt er een batched variant van)

    // buffers voor slab-gather
    const uint32_t MAX_IN_SLAG = 200000; // cap; maak dynamisch/batched als nodig
    uint32_t* d_idx = nullptr;   cudaMalloc(&d_idx, MAX_IN_SLAG * sizeof(uint32_t));
    uint32_t* d_cnt = nullptr;   cudaMalloc(&d_cnt, sizeof(uint32_t));

    // kopieer eerste zaad
    ZaadDriehoek hz; cudaMemcpy(&hz, d_zaden, sizeof(ZaadDriehoek), cudaMemcpyDeviceToHost);
    float d0 = hz.n.x * hz.c.x + hz.n.y * hz.c.y + hz.n.z * hz.c.z; // of n_as¬∑ctd

    cudaMemset(d_cnt, 0, sizeof(uint32_t));
    k_bepaalSlabPunten<<<rooster(N), blok(N)>>>(d_pts, d_labels, N,
                                                n_as, d0, tun.slabEps,
                                                d_idx, MAX_IN_SLAG, d_cnt);
    cudaDeviceSynchronize();

    uint32_t M=0; cudaMemcpy(&M, d_cnt, sizeof(uint32_t), cudaMemcpyDeviceToHost);
    if (M >= 16) // minimale set
    {
        // 2b) planaire regressie (__device__ helper via wrapper-kernel of inline in aparte kernel)
        // ‚Äî maak evt. een kleine wrapper: k_planaireRegressieWrapper(pts, idx, M, n_in, X,Y,Z, ...)
        // Voor nu: we nemen n_as als n_in en doen d-trimK; later vervang je n_as door n* uit regressie.
        float* d_d=nullptr, *d_rms=nullptr; uint32_t* d_kept=nullptr;
        cudaMalloc(&d_d, sizeof(float)); cudaMalloc(&d_rms, sizeof(float)); cudaMalloc(&d_kept, sizeof(uint32_t));

        k_bepaalD_TrimK<<<1, 1, 0>>>(d_pts, d_idx, M, n_as, tun.kTrim, d_d, d_rms, d_kept);
        cudaDeviceSynchronize();

        float h_d=0.f, h_rms=0.f; uint32_t h_kept=0;
        cudaMemcpy(&h_d, d_d, sizeof(float), cudaMemcpyDeviceToHost);
        cudaMemcpy(&h_rms, d_rms, sizeof(float), cudaMemcpyDeviceToHost);
        cudaMemcpy(&h_kept, d_kept, sizeof(uint32_t), cudaMemcpyDeviceToHost);

        if (h_kept >= tun.minSupport && h_rms <= tun.maxRms) {
            PlaneHyp ph; ph.n = n_as; ph.d = h_d; ph.count = h_kept; ph.rms = h_rms; ph.areaHint = 0;
            uit.push_back(ph);
            // TODO: label punten in slab als VLAK (aparte kernel die label set op basis van n_as & d)
        }

        cudaFree(d_d); cudaFree(d_rms); cudaFree(d_kept);
    }

    cudaFree(d_idx); cudaFree(d_cnt);
    cudaFree(d_zaden); cudaFree(d_zCount);
    return !uit.empty();
}

bool vindVlakkenHuidigFrame(const float3* d_pts, uint8_t* d_labels, uint32_t N,
                            VoxelRaster vr, VoxelIndexing vx,
                            const VlakTuning& tun,
                            std::vector<PlaneHyp>& uit)
{
    // init labels op ONGELABELD (√©√©nmalig)
    k_initLabels<<<rooster(N), blok(N)>>>(d_labels, N, ONGELABELD);
    cudaDeviceSynchronize();

    bool ok=false;
    ok |= vindVlakkenLangsRichting(d_pts, d_labels, N, vr, vx, make_float3(0,0,1), tun, uit); // TB
    ok |= vindVlakkenLangsRichting(d_pts, d_labels, N, vr, vx, make_float3(0,1,0), tun, uit); // NZ
    ok |= vindVlakkenLangsRichting(d_pts, d_labels, N, vr, vx, make_float3(1,0,0), tun, uit); // OW
    return ok;
}
FILE_END
FILE_BEGIN legacy/src/voxel_kernels.cu
#include <cstdio>
#include <cuda_runtime.h>
#include <thrust/__device___vector.h>
#include <thrust/__host___vector.h>
#include <thrust/copy.h>
#include <thrust/execution_policy.h>
#include <thrust/scan.h>
#include <thrust/sort.h>

#include "../include/consts.cuh"
#include "../include/math_utils.cuh"
#include "../include/morton_utils.cuh"

namespace Bocari
{
    namespace Thrust
    {

        using namespace Bocari::Cuda;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Error checking & timing helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#define CUDA_CHECK(expr)                                                                                               \
    do                                                                                                                 \
    {                                                                                                                  \
        cudaError_t _err = (expr);                                                                                     \
        if(_err != cudaSuccess)                                                                                        \
        {                                                                                                              \
            fprintf(stderr, "CUDA error %s at %s:%d\\n", cudaGetErrorString(_err), __FILE__, __LINE__);                \
        }                                                                                                              \
    } while(0)

        struct ScopedTimer
        {
            cudaEvent_t start{}, stop{};
            float       ms{0.f};
            const char* label{nullptr};
            ScopedTimer(const char* lbl) : label(lbl)
            {
                cudaEventCreate(&start);
                cudaEventCreate(&stop);
                cudaEventRecord(start);
            }
            ~ScopedTimer()
            {
                cudaEventRecord(stop);
                cudaEventSynchronize(stop);
                cudaEventElapsedTime(&ms, start, stop);
                if(label) fprintf(stderr, "[TIMER] %s: %.3f ms\\n", label, ms);
                cudaEventDestroy(start);
                cudaEventDestroy(stop);
            }
        };

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Kernels
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        // Normalize to bbMin=(0,0,0), scale by mm, quantize; keep original ccIndex
        __global__ void normalizeQuantizeKernel(const float3* __restrict__ inPos,
                                                const uint32_t* __restrict__ inCcIndex, uint32_t* __restrict__ outXi,
                                                uint32_t* __restrict__ outYi, uint32_t* __restrict__ outZi,
                                                uint32_t* __restrict__ outCcIndex, float3 bbMin, float invMeterToMM,
                                                uint32_t N)
        {
            const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
            if(i >= N) return;
            float3 p = inPos[i];
            float3 q = make_float3((p.x - bbMin.x) * invMeterToMM, (p.y - bbMin.y) * invMeterToMM,
                                   (p.z - bbMin.z) * invMeterToMM);
            // lrintf-like rounding: add 0.5f and floor
            uint32_t xi   = static_cast<uint32_t>(floorf(q.x + 0.5f));
            uint32_t yi   = static_cast<uint32_t>(floorf(q.y + 0.5f));
            uint32_t zi   = static_cast<uint32_t>(floorf(q.z + 0.5f));
            outXi[i]      = xi;
            outYi[i]      = yi;
            outZi[i]      = zi;
            outCcIndex[i] = inCcIndex[i];
        }

        // Build composite Morton keys from quantized ints
        __global__ void buildKeysKernel(const uint32_t* __restrict__ xi, const uint32_t* __restrict__ yi,
                                        const uint32_t* __restrict__ zi, uint64_t* __restrict__ keys,
                                        ConstsStruct voxel, ConstsStruct sub, uint32_t N)
        {
            const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
            if(i >= N) return;
            keys[i] = makeCompositeKey(xi[i], yi[i], zi[i], voxel, sub);
        }

        // Histogram per voxel from composite key (only uses high bits = 3*sub.bits shift)
        __global__ void histogramVoxelsKernel(const uint64_t* __restrict__ keys, uint32_t* __restrict__ counts,
                                              ConstsStruct sub, uint32_t N)
        {
            const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
            if(i >= N) return;
            const uint32_t voxelKey = static_cast<uint32_t>(keys[i] >> (3u * sub.bits));
            atomicAdd(&counts[voxelKey], 1u);
        }

        // Simple stride-based downsampler: select ~N/stride points; output ccIndex only
        __global__ void markDownsampleKernel(uint8_t* __restrict__ flags, uint32_t N, uint32_t stride)
        {
            const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
            if(i >= N) return;
            flags[i] = (i % stride == 0) ? 1 : 0;
        }

        // Placeholder plane detection: set flags/counters based on dummy thresholds
        __global__ void detectPlanesKernel(GpuRunLog* log, bool frameIdealAlready)
        {
            if(threadIdx.x == 0 && blockIdx.x == 0)
            {
                log->planesDetected    = true; // placeholder
                log->planes.topBottom  = 1;    // pretend we saw 1 horizontal
                log->planes.northSouth = 1;    // and one NS
                log->planes.eastWest   = 1;    // and one EW
                log->frameWasIdeal     = frameIdealAlready;
            }
        }

        // Placeholder rotation kernel (no-op if frame already ideal)
        __global__ void applyRotationKernel(float3* __restrict__ pos, uint32_t N, GpuRunLog* log)
        {
            if(threadIdx.x == 0 && blockIdx.x == 0)
            {
                log->rotationApplied  = !log->frameWasIdeal;
                log->rotationAxis     = make_float3(0, 0, 1);
                log->rotationAngleDeg = 0.f;
            }
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // __host__-side pipeline entry points
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        struct __device__Cloud
        {
            thrust::__device___vector<float3>   d_pos;
            thrust::__device___vector<uint32_t> d_ccIndex;
            thrust::__device___vector<uint32_t> d_xi, d_yi, d_zi;
            thrust::__device___vector<uint64_t> d_keys;
            thrust::__device___vector<uint32_t> d_counts; // voxel counts
            thrust::__device___vector<uint32_t> d_starts; // exclusive scan + sentinel
            thrust::__device___vector<uint8_t>  d_flags;  // downsample marks
        };

        // Initialize, quantize, build keys, sort, histogram+scan
        void buildMortonOrder(__device__Cloud& dc, const float3* h_pos, const uint32_t* h_ccIndex, uint32_t N,
                              float3 bbMin, float meterToMM, ConstsStruct voxel, ConstsStruct sub,
                              GpuRunLog* d_log /*optional*/)
        {
            ScopedTimer tAll("buildMortonOrder");
            dc.d_pos.assign(h_pos, h_pos + N);
            dc.d_ccIndex.assign(h_ccIndex, h_ccIndex + N);
            dc.d_xi.resize(N);
            dc.d_yi.resize(N);
            dc.d_zi.resize(N);
            dc.d_keys.resize(N);

            const uint32_t block = 256;
            const uint32_t grid  = (N + block - 1) / block;

            {
                ScopedTimer t("normalize+quantize");
                normalizeQuantizeKernel<<<grid, block>>>(
                    thrust::raw_pointer_cast(dc.d_pos.data()), thrust::raw_pointer_cast(dc.d_ccIndex.data()),
                    thrust::raw_pointer_cast(dc.d_xi.data()), thrust::raw_pointer_cast(dc.d_yi.data()),
                    thrust::raw_pointer_cast(dc.d_zi.data()), thrust::raw_pointer_cast(dc.d_ccIndex.data()), bbMin,
                    meterToMM, N);
                CUDA_CHECK(cudaGetLastError());
            }

            {
                ScopedTimer t("buildKeys");
                buildKeysKernel<<<grid, block>>>(thrust::raw_pointer_cast(dc.d_xi.data()),
                                                 thrust::raw_pointer_cast(dc.d_yi.data()),
                                                 thrust::raw_pointer_cast(dc.d_zi.data()),
                                                 thrust::raw_pointer_cast(dc.d_keys.data()), voxel, sub, N);
                CUDA_CHECK(cudaGetLastError());
            }

            {
                ScopedTimer t("sort_by_key (keys, pos, ccIndex)");
                auto zipped = thrust::make_zip_iterator(thrust::make_tuple(dc.d_pos.begin(), dc.d_ccIndex.begin()));
                thrust::sort_by_key(thrust::__device__, dc.d_keys.begin(), dc.d_keys.end(), zipped);
            }

            // Histogram counts per voxel + exclusive scan to starts (with sentinel)
            const uint32_t K = voxel.N * voxel.N * voxel.N;
            dc.d_counts.assign(K, 0u);
            {
                ScopedTimer t("voxel histogram");
                histogramVoxelsKernel<<<grid, block>>>(thrust::raw_pointer_cast(dc.d_keys.data()),
                                                       thrust::raw_pointer_cast(dc.d_counts.data()), sub, N);
                CUDA_CHECK(cudaGetLastError());
            }

            dc.d_starts.resize(K + 1);
            {
                ScopedTimer t("exclusive_scan counts->starts");
                thrust::exclusive_scan(thrust::__device__, dc.d_counts.begin(), dc.d_counts.end(), dc.d_starts.begin());
                // sentinel
                thrust::copy_n(thrust::make___constant___iterator<uint32_t>(N), 1, dc.d_starts.begin() + K);
            }
        }

        // Downsample by stride so that ~maxOut points are selected (return count and indices only)
        uint32_t downsampleIndices(const __device__Cloud& dc, uint32_t maxOut,
                                   thrust::__device___vector<uint32_t>& d_outIdx, GpuRunLog* d_log /*optional*/)
        {
            const uint32_t N = static_cast<uint32_t>(dc.d_ccIndex.size());
            if(N == 0 || maxOut == 0) return 0;
            const uint32_t stride = (N + maxOut - 1) / maxOut;

            d_outIdx.resize(N); // temporary max
            thrust::__device___vector<uint8_t> flags(N, 0);
            const uint32_t                     block = 256;
            const uint32_t                     grid  = (N + block - 1) / block;
            {
                ScopedTimer t("markDownsample");
                markDownsampleKernel<<<grid, block>>>(thrust::raw_pointer_cast(flags.data()), N, stride);
                CUDA_CHECK(cudaGetLastError());
            }

            // compact ccIndex using flags
            auto ccBeg  = dc.d_ccIndex.begin();
            auto zipBeg = thrust::make_zip_iterator(thrust::make_tuple(ccBeg, flags.begin()));
            auto zipEnd = thrust::make_zip_iterator(thrust::make_tuple(dc.d_ccIndex.end(), flags.end()));

            auto endIt = thrust::copy_if(thrust::__device__, dc.d_ccIndex.begin(), dc.d_ccIndex.end(), flags.begin(),
                                         d_outIdx.begin(), [] __device__(uint8_t f) { return f != 0; });
            const uint32_t outN = static_cast<uint32_t>(endIt - d_outIdx.begin());
            d_outIdx.resize(outN);

            if(d_log)
            {
                CUDA_CHECK(cudaMemcpy(&d_log->downsampleOutCount, &outN, sizeof(uint32_t), cudaMemcpyHostToDevice));
                // mark flag via __host__ memcpy (simple)
                bool ds = true;
                CUDA_CHECK(cudaMemcpy(&d_log->downsampled, &ds, sizeof(bool), cudaMemcpyHostToDevice));
            }
            return outN;
        }

        // One-shot stage: detect planes (placeholder), maybe rotate, then produce a small index list
        uint32_t runStage_FindFrameAndDownsample(__device__Cloud& dc, const ConstsStruct& voxel,
                                                 const ConstsStruct& sub, bool existingFrameIsIdeal,
                                                 uint32_t maxDownsample, thrust::__device___vector<uint32_t>& d_downIdx,
                                                 GpuRunLog* d_log /* __device__ ptr */)
        {
            {
                ScopedTimer t("detectPlanes (stub)");
                detectPlanesKernel<<<1, 1>>>(d_log, existingFrameIsIdeal);
                CUDA_CHECK(cudaGetLastError());
            }
            {
                ScopedTimer    t("applyRotation (stub)");
                const uint32_t N     = static_cast<uint32_t>(dc.d_pos.size());
                const uint32_t block = 256, grid = (N + block - 1) / block;
                applyRotationKernel<<<grid, block>>>(thrust::raw_pointer_cast(dc.d_pos.data()), N, d_log);
                CUDA_CHECK(cudaGetLastError());
            }
            uint32_t outN = 0;
            {
                ScopedTimer t("downsampleIndices");
                outN = downsampleIndices(dc, maxDownsample, d_downIdx, d_log);
            }
            return outN;
        }

    } // namespace Thrust
} // namespace Bocari
FILE_END
FILE_BEGIN legacy/src/k_vlak_seeds.cu
#include "math_utils.cuh" // jouw __device__ dot/cross/norm helpers (d_*)
#include "vlak_types.h"
#include "voxel_params.h"
#include <cuda_runtime.h>

using namespace jbf;
using namespace grid;

// Output-struct (compact) voor een driehoek-zaad
struct ZaadDriehoek
{
    uint32_t i, j, k; // indices in d_pts
    float3   n;       // unit normaal van de driehoek
    float3   c;       // centroid (optioneel voor d0)
};

// NB: we limiteren zaden per voxel om combinatorische explosie te voorkomen.
__global__ void k_vindDriehoekZadenLangsRichting(const float3* __restrict__ pts, const uint8_t* __restrict__ labels,
                                                 uint32_t N, VoxelRaster vr, VoxelIndexing vx,
                                                 float3 n_doel, // (0,0,1) etc.
                                                 float edgeMin, float edgeMax,
                                                 float    cosHoekMin, // cos(maxŒîhoek)
                                                 uint32_t maxZadenPerVoxel, ZaadDriehoek* __restrict__ zaden,
                                                 uint32_t* __restrict__ zadenCount)
{
    uint32_t v = blockIdx.x; // 1 CTA per voxel (kan ook tiled)
    if(v >= vx.numVoxels) return;

    uint32_t begin = vx.d_voxelStarts[v];
    uint32_t eind  = vx.d_voxelStarts[v + 1];
    if(begin + 2 >= eind) return;

    // decode v ‚Üí (ix,iy,iz)
    uint32_t S  = vr.S;
    uint32_t iz = v / (S * S);
    uint32_t iy = (v / S) % S;
    uint32_t ix = v % S;

    // neem buurt (3x3x3)
    int x0 = max<int>(0, ix - 1), x1 = min<int>(S - 1, ix + 1);
    int y0 = max<int>(0, iy - 1), y1 = min<int>(S - 1, iy + 1);
    int z0 = max<int>(0, iz - 1), z1 = min<int>(S - 1, iz + 1);

    // verzamel lokale index-range lijst (optioneel: direct itereren zoals hieronder)
    uint32_t            lokaalMax = 4096; // cap; pas aan of maak dynamisch
    __shared__ uint32_t lokIdx[4096];
    __shared__ uint32_t L;
    if(threadIdx.x == 0) L = 0;
    __syncthreads();

    for(int zz = z0; zz <= z1; ++zz)
        for(int yy = y0; yy <= y1; ++yy)
            for(int xx = x0; xx <= x1; ++xx)
            {
                uint32_t nb  = flatten(xx, yy, zz, S, S, S);
                uint32_t nbB = vx.d_voxelStarts[nb];
                uint32_t nbE = vx.d_voxelStarts[nb + 1];

                for(uint32_t t = nbB + threadIdx.x; t < nbE; t += blockDim.x)
                {
                    if(labels[t] != ONGELABELD) continue;
                    uint32_t pos = atomicAdd(&L, 1u);
                    if(pos < lokaalMax) lokIdx[pos] = t;
                }
                __syncthreads();
            }
    if(L < 3) return;

    // elke thread pakt een i en maakt enkele combinaties j,k in de buurt
    uint32_t seedsEmitted = 0;
    for(uint32_t a = threadIdx.x; a < L && seedsEmitted < maxZadenPerVoxel; a += blockDim.x)
    {
        uint32_t i  = lokIdx[a];
        float3   Pi = pts[i];

        // kies beperkt aantal buren rondom a (bandbreedte beperken)
        const uint32_t KMAX = 16;
        for(uint32_t b = a + 1; b < min(L, a + 1 + KMAX) && seedsEmitted < maxZadenPerVoxel; ++b)
            for(uint32_t c = b + 1; c < min(L, b + 1 + KMAX) && seedsEmitted < maxZadenPerVoxel; ++c)
            {
                uint32_t j = lokIdx[b], k = lokIdx[c];
                if(labels[j] != ONGELABELD || labels[k] != ONGELABELD) continue;
                float3 Pj = pts[j], Pk = pts[k];

                // edge-lengtes
                float3 e1 = make_float3(Pj.x - Pi.x, Pj.y - Pi.y, Pj.z - Pi.z);
                float3 e2 = make_float3(Pk.x - Pi.x, Pk.y - Pi.y, Pk.z - Pi.z);
                float  L1 = sqrtf(e1.x * e1.x + e1.y * e1.y + e1.z * e1.z);
                float  L2 = sqrtf(e2.x * e2.x + e2.y * e2.y + e2.z * e2.z);
                float  L3 = sqrtf((Pk.x - Pj.x) * (Pk.x - Pj.x) + (Pk.y - Pj.y) * (Pk.y - Pj.y) +
                                  (Pk.z - Pj.z) * (Pk.z - Pj.z));

                if(L1 < edgeMin || L2 < edgeMin || L3 < edgeMin) continue;
                if(L1 > edgeMax || L2 > edgeMax || L3 > edgeMax) continue;

                // triangle normaal
                float3 n = jbf::d_norm3(jbf::d_cross3(e1, e2));
                float  c = fabsf(jbf::d_dot3(n, n_doel));
                if(c < cosHoekMin) continue; // wijkt teveel af van doel-normaal

                // centroid
                float3 ctd =
                    make_float3((Pi.x + Pj.x + Pk.x) / 3.f, (Pi.y + Pj.y + Pk.y) / 3.f, (Pi.z + Pj.z + Pk.z) / 3.f);

                // schrijf uit
                uint32_t outPos = atomicAdd(zadenCount, 1u);
                zaden[outPos]   = {i, j, k, n, ctd};
                ++seedsEmitted;
            }
    }
}
FILE_END
FILE_BEGIN legacy/src/k_ruis_boeren2buur.cu
#include <cuda_runtime.h>
#include "vlak_types.h"
#include "voxel_params.h"

using namespace jbf;
using namespace grid;

__global__ void k_initLabels(uint8_t* __restrict__ labels, uint32_t N, uint8_t waarde)
{
    uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < N) labels[i] = waarde;
}

// tel buren in 3x3x3 voxels; stop vroeg zodra 2 gevonden
__global__ void k_ruisBoerenTweedeBuur(const float3* __restrict__ pts,
                                       uint8_t* __restrict__ labels,
                                       uint32_t N,
                                       VoxelRaster vr,
                                       VoxelIndexing vx,
                                       float r_keep /*‚âà 1‚Äì3 mm*/)
{
    const float r2 = r_keep * r_keep;
    uint32_t v = blockIdx.x; // 1 CTA per voxel (of chunk-wise)
    if (v >= vx.numVoxels) return;

    uint32_t begin = vx.d_voxelStarts[v];
    uint32_t eind  = vx.d_voxelStarts[v+1];
    if (begin >= eind) return;

    // decode v ‚Üí (ix,iy,iz)
    uint32_t S = vr.S;
    uint32_t iz = v / (S*S);
    uint32_t iy = (v / S) % S;
    uint32_t ix = v % S;

    // buur-voxel grenzen
    int x0 = max<int>(0, ix-1), x1 = min<int>(S-1, ix+1);
    int y0 = max<int>(0, iy-1), y1 = min<int>(S-1, iy+1);
    int z0 = max<int>(0, iz-1), z1 = min<int>(S-1, iz+1);

    // voor elk punt in deze voxel: zoek 2 buren
    for (uint32_t i = begin + threadIdx.x; i < eind; i += blockDim.x)
    {
        if (labels[i] != ONGELABELD) continue; // al gezet elders
        float3 p = pts[i];
        int found = 0;

        for (int zz=z0; zz<=z1 && found<2; ++zz)
        for (int yy=y0; yy<=y1 && found<2; ++yy)
        for (int xx=x0; xx<=x1 && found<2; ++xx)
        {
            uint32_t nb = flatten(xx,yy,zz,S,S,S);
            uint32_t nbB = vx.d_voxelStarts[nb];
            uint32_t nbE = vx.d_voxelStarts[nb+1];
            for (uint32_t j = nbB; j < nbE; ++j) {
                if (j == i) continue;
                float3 q = pts[j];
                float dx = p.x - q.x, dy = p.y - q.y, dz = p.z - q.z;
                float d2 = dx*dx + dy*dy + dz*dz;
                if (d2 <= r2) {
                    ++found;
                    if (found >= 2) break;
                }
            }
        }

        if (found < 2) labels[i] = RUIS; // geen 2e buur ‚Üí ruis
    }
}
FILE_END
FILE_BEGIN legacy/src/vlak_detectie_kernels.cu
#include <cuda_runtime.h>
#include "vlak_types.h"
#include "math_hulpfuncties.cuh"
#include "planaire_regressie.cuh"

using namespace jbf;

extern "C" {

__global__ void k_bepaalSlabPunten(const float3* __restrict__ pts,
                                   const uint8_t* __restrict__ labels,
                                   uint32_t N,
                                   float3 n,
                                   float  d0,
                                   float  slabEps,
                                   uint32_t* __restrict__ outIdx,
                                   uint32_t  maxOut,
                                   uint32_t* __restrict__ outCount)
{
    // eenvoudige grid-stride scan
    uint32_t tid = blockIdx.x * blockDim.x + threadIdx.x;
    uint32_t stride = blockDim.x * gridDim.x;

    for (uint32_t i=tid; i<N; i+=stride) {
        if (labels[i] != ONGELABELD) continue;
        float s = d_dot3(n, pts[i]);
        if (fabsf(s - d0) <= slabEps) {
            uint32_t pos = atomicAdd(outCount, 1u);
            if (pos < maxOut) outIdx[pos] = i; // eenvoudige overrun bescherming
        }
    }
}

__global__ void k_bepaalD_TrimK(const float3* __restrict__ pts,
                                const uint32_t* __restrict__ idx,
                                uint32_t M,
                                float3 n_star,
                                int kTrim,
                                float* d_out,
                                float* rms_out,
                                uint32_t* kept_out)
{
    // Single-block kernel verwacht; voor eenvoud (kun je later parallen)
    float sum = 0.f; uint32_t cnt = 0;

    // kleine buffers top-k
    extern __shared__ float sh[]; // we gebruiken registers hieronder voor simpelheid
    float minK[8]; float maxK[8]; // neem kTrim<=8
    #pragma unroll
    for (int k=0;k<8;++k){ minK[k]= CUDART_INF_F; maxK[k]= -CUDART_INF_F; }

    for (uint32_t j=0; j<M; ++j) {
        float r = d_dot3(n_star, pts[idx[j]]);
        sum += r; ++cnt;

        // plaats in minK (kleinste)
        int mMin=0; for (int k=1;k<kTrim;++k) if (minK[k] > minK[mMin]) mMin=k;
        if (r < minK[mMin]) minK[mMin] = r;

        // plaats in maxK (grootste)
        int mMax=0; for (int k=1;k<kTrim;++k) if (maxK[k] < maxK[mMax]) mMax=k;
        if (r > maxK[mMax]) maxK[mMax] = r;
    }

    float sumMin=0.f, sumMax=0.f;
    for (int k=0;k<kTrim;++k){ sumMin+=minK[k]; sumMax+=maxK[k]; }
    uint32_t kept = (cnt > (uint32_t)(2*kTrim)) ? (cnt - 2*kTrim) : 0u;
    float d = (kept? (sum - sumMin - sumMax) / (float)kept : 0.f);

    // RMS (optioneel): tweede pass over kept
    float sse=0.f; uint32_t kc=0;
    for (uint32_t j=0; j<M; ++j) {
        float r = d_dot3(n_star, pts[idx[j]]);
        bool isMin=false, isMax=false;
        #pragma unroll
        for (int k=0;k<kTrim;++k){ if (fabsf(r - minK[k])<1e-12f) {isMin=true; break;} }
        #pragma unroll
        for (int k=0;k<kTrim;++k){ if (fabsf(r - maxK[k])<1e-12f) {isMax=true; break;} }
        if (isMin || isMax) continue;
        float e = r - d; sse += e*e; ++kc;
    }
    float rms = (kc? sqrtf(sse/(float)kc) : 0.f);

    if (threadIdx.x==0) {
        *d_out = d; *rms_out = rms; *kept_out = kept;
    }
}

} // extern "C"
FILE_END
FILE_BEGIN legacy/src/voxelprocessor.cpp
#include "voxelprocessor.h"
#include <random>

namespace Bocari
{
    namespace Voxelprocessing
    {
        inline u32 computeIndexComponent(double coord, double inv)
        {
            constexpr double eps  = 1e-4;
            constexpr u32    mask = maskFor(Voxelprocessing::c_radix);
            double           v    = coord * inv;
            assert(v > -eps);
            assert(v - Voxelprocessing::c_radix < eps); // Edge case could land in bin 0, but OK.
            if(v < 0.0) v = 0.0;
            return U32(v) & mask;
        }

        VoxelManager* VoxelManager::s_pInstance = nullptr;

        // --- Voxel Implementation ---
        Voxel::Voxel(u32 index_1D, const VoxelManager* manager, Voxelprocessing::GridUnion<c_subvoxel>& subVoxelStarts)
            : m_index_1D(index_1D), m_manager(const_cast<VoxelManager*>(manager)), m_subvoxelStarts(&subVoxelStarts)
        {
            Voxelprocessing::unflatten3<c_voxel>(m_index_1D, m_z, m_y, m_x);
        }

        u32 Voxel::start() const
        {
            assert(m_manager != nullptr);
            return m_manager->m_voxelStarts._1D[m_index_1D];
        }

        u32 Voxel::count() const
        {
            assert(m_manager != nullptr);
            assert(m_manager->m_voxelStarts._1D[m_index_1D + 1] >= m_manager->m_voxelStarts._1D[m_index_1D]);
            return m_manager->m_voxelStarts._1D[m_index_1D + 1] - m_manager->m_voxelStarts._1D[m_index_1D];
        }

        void Voxel::getIndices(u32& x, u32& y, u32& z) const
        {
            x = m_x;
            y = m_y;
            z = m_z;
        }

        void Voxel::ensureSubvoxelStartsComputed() const
        {
            if(m_subvoxelStartsComputed) return;

            u32 b = start();
            u32 e = b + count();
            if(b >= e)
            {
                m_subvoxelStarts->initialize(e);
                m_subvoxelStartsComputed = true;
                return;
            }

            const Voxelprocessing::RangeData& sliceRangeData = m_manager->m_sliceRange;

            auto getSubvoxelIndex = [&](const Pointcloud::Point& p) {
                u32 x = computeIndexComponent(p.m_point.x, sliceRangeData.invRange.x);
                u32 y = computeIndexComponent(p.m_point.y, sliceRangeData.invRange.y);
                u32 z = computeIndexComponent(p.m_point.z, sliceRangeData.invRange.z);

                // Shift out LSB bits for subvoxels, so we keep MSB bits for voxel
                constexpr u32 shift = Voxelprocessing::log2(c_subvoxel);
                assert((x >> shift) == m_x);
                assert((y >> shift) == m_y);
                assert((z >> shift) == m_z);

                // LSB bits give subvoxel coordinate within parent voxel
                constexpr u32 mask = maskFor(c_subvoxel);
                return flatten3<c_subvoxel>(z & mask, y & mask, x & mask);
            };

            constexpr u32         Bins = Math::pow3(c_subvoxel);
            std::array<u32, Bins> counts{};
            countIndices<Bins>(m_manager->groupedPoints, b, e, counts, getSubvoxelIndex);
            buildStartIndices<c_subvoxel>(counts, *m_subvoxelStarts, b);

            VOXEL_DBG({
                for(u32 i = b; i < e; ++i)
                {
                    u32 g = getSubvoxelIndex(m_manager->groupedPoints[i]);
                    if(!(m_subvoxelStarts->_1D[g] <= i && i < m_subvoxelStarts->_1D[g + 1]))
                    {
                        std::cerr << "Assertion failed at i=" << i << " g=" << g << " range=["
                                  << m_subvoxelStarts->_1D[g] << "," << m_subvoxelStarts->_1D[g + 1]
                                  << "),  total=" << count() << std::endl;
                    }
                    assert(m_subvoxelStarts->_1D[g] <= i && i < m_subvoxelStarts->_1D[g + 1]);
                }
            });

            m_subvoxelStartsComputed = true;
        }

        // Calculates subvoxelCumSum if necessary, relative to Voxel.
        void Voxel::buildSubVoxelCumSum() const
        {
            if(m_subvoxelCumSumComputed) return;

            ensureSubvoxelStartsComputed();
            Voxelprocessing::GridUnion<c_subvoxel> subVoxelCounts;
            for(u32 i = 0; i < Math::pow3(c_subvoxel); ++i)
            {
                subVoxelCounts._1D[i] = m_subvoxelStarts->_1D[i + 1] - m_subvoxelStarts->_1D[i];
            }
            buildCumSum<c_subvoxel>(subVoxelCounts, m_subvoxelCumSum);
            m_subvoxelCumSumComputed = true;

            VOXEL_DBG({
                u32 voxelCount = count();
                if(voxelCount > 0)
                {
                    SubVoxel subvoxel1(*this, 0, 0, 0);
                    SubVoxel subvoxel2(*this, c_subvoxel - 1, c_subvoxel - 1, c_subvoxel - 1);
                    u32      subTotal = m_manager->countPointsInSubVoxelBox(*this, subvoxel1, subvoxel2);
                    assert(subTotal == voxelCount);
                }
            });
        }

        bool Voxel::detectPlane()
        {
            u32 cnt = count();
            if(cnt < 100) return false;
            u32                             tries   = 5;
            u32                             count40 = (cnt * 13) >> 5; // ca cnt*0.4
            u32                             count60 = (cnt * 77) >> 7; // ca cnt*0.6
            u32                             step    = (count60 - count40) / tries;
            u32                             s       = start();
            std::vector<Pointcloud::Point>& points  = m_manager->groupedPoints;

            u32       confirmation = 0;
            float     eps          = 0.01f;
            const u32 threshold    = 60; // 900 dots/m^2 -> 81 punten per 30x30 cm.
            u32       _e           = s + cnt - 1;

            for(u32 b = s; b < s + tries; ++b)
            {
                for(u32 e = _e; e > _e - tries; --e)
                {
                    for(u32 m = s + count40; m < count60; m += step)
                    {
                        bool ok;
                        auto n = Math::Vec3f::normalFrom(points[b].m_point, points[e].m_point, points[m].m_point, ok);
                        if(!ok) continue;

                        float d = n.dot(points[b].m_point);

                        for(u32 x = s; x < s + cnt; ++x)
                        {
                            if(fabsf(n.dot(points[x].m_point) - d) < eps)
                            {
                                ++confirmation;
                                if(confirmation > threshold)
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            return false;
        }

        SubVoxel Voxel::getSubVoxel(u32 x, u32 y, u32 z) const
        {
            ensureSubvoxelStartsComputed();
            return SubVoxel(*this, x, y, z);
        }

        // --- SubVoxel Implementation ---
        SubVoxel::SubVoxel(const Voxel& voxel, u32 x, u32 y, u32 z)
        {
            voxel.ensureSubvoxelStartsComputed();
            m_x        = x;
            m_y        = y;
            m_z        = z;
            m_index_1D = flatten3<c_subvoxel>(z, y, x);
            m_start    = voxel.m_subvoxelStarts->_1D[m_index_1D];
            m_count    = voxel.m_subvoxelStarts->_1D[m_index_1D + 1] - m_start;
        }

        SubVoxel::SubVoxel(u32 index_1D, u32 start, u32 count, const Math::Vec3d& bbMin)
            : m_index_1D(index_1D), m_start(start), m_count(count), m_bbMin(bbMin)
        {
            Voxelprocessing::unflatten3<c_subvoxel>(m_index_1D, m_z, m_y, m_x);
        }

        // --- OnlinePCA Implementation ---
        void OnlinePCA::reset()
        {
            n    = 0;
            mean = Math::Vec3d(0.0, 0.0, 0.0);
            M2.zero();
        }

        void OnlinePCA::update(const Math::Vec3d& v)
        {
            n++;
            Math::Vec3d delta = v - mean;
            mean += delta / static_cast<double>(n);
            Math::Vec3d delta2 = v - mean;
            M2 += outer_product(delta, delta2);
        }

        Math::Matrix3d OnlinePCA::covariance() const
        {
            if(n < 2) return Math::Matrix3d::zeroMatrix();
            return M2 / static_cast<double>(n - 1);
        }

        // --- VoxelManager Implementation ---
        VoxelManager::VoxelManager()
        {
            s_pInstance = this;
            m_voxelStarts.initialize(0);
            m_voxelCumSum.initialize(0);
            groupedPoints.clear();
        }

        void VoxelManager::getVoxel(u32 x, u32 y, u32 z, Voxel& out,
                                    Voxelprocessing::GridUnion<c_subvoxel>& subVoxelStarts) const
        {
            u32 index_1D = flatten3<c_voxel>(z, y, x);
            out          = Voxel(index_1D, const_cast<VoxelManager*>(this), subVoxelStarts);
        }

        void VoxelManager::getVoxelById(u32 flatIndex, Voxel& out,
                                        Voxelprocessing::GridUnion<c_subvoxel>& subVoxelStarts) const
        {
            out = Voxel(flatIndex, const_cast<VoxelManager*>(this), subVoxelStarts);
        }

        void VoxelManager::voxelize(ccPointCloud* cloud)
        {
            assert(cloud != nullptr && cloud->size() > 0);

            // Bereken normalisatie parameters
            m_normResult = computeNormalizationParameters(cloud);

            // De cloud wordt opgesplitst in c_radix (1024) slices, voor 10 bits sortering in elke richting.
            m_sliceRange.computeVoxelSizeData(m_normResult.bbMaxTranslatedScaled, c_radix);

            m_voxelStarts._1D[0] = 0;

            // Subsample en normaliseer in groupedPoints
            u32 totalPoints = cloud->size();
            groupedPoints.clear();
            groupedPoints.reserve(totalPoints);

            const double eps = 1e-4;
            for(u32 i = 0; i < totalPoints; ++i)
            {
                const CCVector3* p = cloud->getPoint(i);
                assert(p != nullptr);
                Math::Vec3d point(*p);

                // Translatie (altijd)
                point -= m_normResult.bbMinOrg;
                assert(point.x < maxAllowedSize + eps);
                assert(point.y < maxAllowedSize + eps);
                assert(point.z < maxAllowedSize + eps);

                // Schaling (alleen als nodig - gebruik de flag!)
                if(m_normResult.needsScaling)
                {
                    point *= m_normResult.scale;
                    assert(point.x < maxAllowedScaledSize + eps);
                    assert(point.y < maxAllowedScaledSize + eps);
                    assert(point.z < maxAllowedScaledSize + eps);
                }

                // groupedPoints.emplace_back(Pointcloud::Point(i32(i), Math::Vec3f(point)));
                groupedPoints.emplace_back(i32(i), Math::Vec3f(point));
            }

            auto getX = [&](const Pointcloud::Point& p) {
                return computeIndexComponent(static_cast<double>(p.m_point.x), m_sliceRange.invRange.x);
            };
            auto getY = [&](const Pointcloud::Point& p) {
                return computeIndexComponent(static_cast<double>(p.m_point.y), m_sliceRange.invRange.y);
            };
            auto getZ = [&](const Pointcloud::Point& p) {
                return computeIndexComponent(static_cast<double>(p.m_point.z), m_sliceRange.invRange.z);
            };

            auto getVoxelIndex = [&](const Pointcloud::Point& p) {
                u32 x = getX(p);
                u32 y = getY(p);
                u32 z = getZ(p);
                // Shift out LSB bits for subvoxels, so we keep MSB bits for voxel
                constexpr u32 shift = Voxelprocessing::log2(c_subvoxel);
                return flatten3<c_voxel>(z >> shift, y >> shift, x >> shift);
            };

            auto getSubvoxelIndex = [&](const Pointcloud::Point& p) {
                u32 x = getX(p);
                u32 y = getY(p);
                u32 z = getZ(p);

                // LSB bits give subvoxel coordinate within parent voxel
                constexpr u32 mask = maskFor(c_subvoxel);
                return flatten3<c_subvoxel>(z & mask, y & mask, x & mask);
            };

            GridUnion<c_subvoxel> startSubVoxel;
            countingSort<c_subvoxel>(groupedPoints, getSubvoxelIndex, startSubVoxel);
            countingSort<c_voxel>(groupedPoints, getVoxelIndex, m_voxelStarts);

            // Herbereken voxelCounts uit startVoxel
            u32 Bins = Math::pow3(c_voxel);
            for(u32 i = 0; i < Bins; ++i)
            {
                m_voxelCounts[i] = m_voxelStarts._1D[i + 1] - m_voxelStarts._1D[i];
            }
            m_voxelCounts[Bins] = 0;
            computeVoxelMediumRange();

#ifdef _DEBUG
            u32 sum = 0;
            for(u32 i = 0; i < Bins; ++i) sum += m_voxelCounts._1D[i];
            assert(sum == groupedPoints.size());
#endif
            VOXEL_DBG({
                for(u32 i = 0; i < groupedPoints.size(); ++i)
                {
                    u32 g = getVoxelIndex(groupedPoints[i]);
                    if(!(m_voxelStarts._1D[g] <= i && i < m_voxelStarts._1D[g + 1]))
                    {
                        std::cerr << "Assertion failed at i=" << i << " g=" << g << " range=[" << m_voxelStarts._1D[g]
                                  << "," << m_voxelStarts._1D[g + 1] << "), total=" << groupedPoints.size()
                                  << std::endl;
                    }
                    assert(m_voxelStarts._1D[g] <= i && i < m_voxelStarts._1D[g + 1]);
                }
                std::cout << "Voxelization complete. Total points: " << groupedPoints.size() << std::endl;
                std::cout << "Scale: " << m_normResult.scale << std::endl;
            });
        }

        void VoxelManager::computeVoxelMediumRange()
        {
            constexpr u32         Bins = Math::pow3(c_voxel);
            std::array<u32, Bins> sortedCounts;
            std::copy(m_voxelCounts._1D,        // Bron startadres
                      m_voxelCounts._1D + Bins, // Bron eindadres (start + Bins elementen)
                      sortedCounts.begin()      // Bestemming startadres
            );

            std::sort(sortedCounts.begin(), sortedCounts.end());

            // Find first index j where count > 0 (exclude zero bins)
            u32       low            = 0;
            const u32 noiseThreshold = 10;
            while(low < Bins && sortedCounts[low] < noiseThreshold)
                ++low; // Less than 10 points per slice is considered noise.

            if(low >= Bins)
            {
                // All bins are zero
                m_mediumVoxelRange.minCount  = 0;
                m_mediumVoxelRange.maxCount  = 0;
                m_mediumVoxelRange.p25_value = 0.0;
                m_mediumVoxelRange.p50_value = 0.0;
                m_mediumVoxelRange.p75_value = 0.0;
                return;
            }

            // Q1, Q2, Q3 quartile indices within j..Bins
            u32 p50_index = (Bins + low) / 2;
            u32 p25_index = (low + p50_index) / 2;
            u32 p75_index = (Bins + p50_index) / 2;

            // Store percentile values in m_madRange
            m_mediumVoxelRange.p25_value = static_cast<double>(sortedCounts[p25_index]);
            m_mediumVoxelRange.p50_value = static_cast<double>(sortedCounts[p50_index]);
            m_mediumVoxelRange.p75_value = static_cast<double>(sortedCounts[p75_index]);

            const double alpha   = 0.2;
            double       lower_d = m_mediumVoxelRange.p25_value * (1 - alpha);
            double       upper_d = m_mediumVoxelRange.p75_value * (1 + alpha);

            // Store results (use integers for min/max counts)
            m_mediumVoxelRange.minCount = U32(std::floor(lower_d));
            m_mediumVoxelRange.maxCount = U32(std::ceil(upper_d));

            VOXEL_DBG({
                std::cout << "VoxelRange: j=" << low << " p25_index=" << p25_index << " p50_index=" << p50_index
                          << " p75_index=" << p75_index << " p25=" << m_mediumVoxelRange.p25_value
                          << " p50=" << m_mediumVoxelRange.p50_value << " p75=" << m_mediumVoxelRange.p75_value
                          << " => [" << m_mediumVoxelRange.minCount << ", " << m_mediumVoxelRange.maxCount << "]"
                          << std::endl;
            });
        }

        // Fast check using actual voxel count
        bool VoxelManager::isMediumDensityVoxel(u32 index) const
        {
            u32 count = m_voxelCounts._1D[index];
            return (count >= m_mediumVoxelRange.minCount) && (count <= m_mediumVoxelRange.maxCount);
            // return count > 4 && count < 25;
        }

        void VoxelManager::buildVoxelCumSum() const
        {
            if(m_voxelCumSumComputed) return;
            // Reconstruct counts from starts
            Voxelprocessing::GridUnion<c_voxel> voxelCounts;
            voxelCounts.initialize(0);
            for(u32 i = 0; i < Math::pow3(c_voxel); ++i)
            {
                voxelCounts._1D[i] = m_voxelStarts._1D[i + 1] - m_voxelStarts._1D[i];
            }
            buildCumSum<c_voxel>(voxelCounts, m_voxelCumSum);
            m_voxelCumSumComputed = true;

            VOXEL_DBG({
                Voxelprocessing::GridUnion<c_subvoxel> subVoxelStarts;
                Voxel                                  v1(0, this, subVoxelStarts);
                Voxel                                  v2(Math::pow3(c_voxel) - 1, this, subVoxelStarts);
                u32                                    totalPoints = countPointsInVoxelBox(v1, v2);
                assert(totalPoints == U32(groupedPoints.size()));
            });
        }

        u32 VoxelManager::countPointsInVoxelBox(const Voxel& voxel1, const Voxel& voxel2) const
        {
            return countPointsInBox<c_voxel>(m_voxelCumSum, voxel1.m_x, voxel1.m_y, voxel1.m_z, voxel2.m_x, voxel2.m_y,
                                             voxel2.m_z);
        }

        u32 VoxelManager::countPointsInSubVoxelBox(const Voxel& voxel, const SubVoxel& subvoxel1,
                                                   const SubVoxel& subvoxel2) const
        {
            if(!voxel.hasSubVoxelCumSum())
            {
                voxel.buildSubVoxelCumSum();
            }
            u32 sx1, sy1, sz1, sx2, sy2, sz2;
            subvoxel1.getIndices(sx1, sy1, sz1);
            subvoxel2.getIndices(sx2, sy2, sz2);
            return countPointsInBox<c_subvoxel>(voxel.m_subvoxelCumSum, sx1, sy1, sz1, sx2, sy2, sz2);
        }

        NormalizationResult VoxelManager::computeNormalizationParameters(ccPointCloud* cloud)
        {
            assert(cloud != nullptr && cloud->size() > 0);

            CCVector3 minCC, maxCC;
            cloud->getBoundingBox(minCC, maxCC);
            NormalizationResult result{1.0, false, Math::Vec3d(minCC), Math::Vec3d(maxCC)};
            result.bbMaxTranslatedScaled -= result.bbMinOrg;

            Math::Vec3d& bboxSize        = result.bbMaxTranslatedScaled;
            double       maxBoxDimension = std::max({bboxSize.x, bboxSize.y, bboxSize.z});
            result.needsScaling          = (maxBoxDimension > maxAllowedSize);

            if(result.needsScaling)
            {
                result.scale = maxAllowedScaledSize /
                               maxBoxDimension; // if scaling, coordinates will be 100.0 max, else 1000.0 max
                result.bbMaxTranslatedScaled = result.bbMaxTranslatedScaled * result.scale;
            }

            return result;
        }
    } // namespace Voxelprocessing

} // namespace Bocari
FILE_END
FILE_BEGIN legacy/src/wedge_vote.cu
#include <cuda_runtime.h>
#include <cub/cub.cuh>
#include "types.cuh"
#include "consts.cuh"
#include "plane_buis_utils.cuh"

// 3) annulus/wedge per voxel (VOX_BUIS_KAND): lokale sector-hist in shared ‚Üí top-1 ‚Üí global key emit
__global__ void k_buis_annulus_wedge(
    const Vec3f* __restrict__ punten,
    const VoxelBereik* __restrict__ voxels,
    const VoxelKlasse* __restrict__ klasse,
    int aantal_voxels,
    Vec3f n_zaad,
    KeyCount* __restrict__ out_emits,
    u32* __restrict__ out_size
){
    __shared__ u32 sect_hist[Tuning::SECTORS_HALF];
    for (int i = threadIdx.x; i < Tuning::SECTORS_HALF; i += blockDim.x) sect_hist[i] = 0;
    __syncthreads();

    Vec3f u, v; basis_uv_orthonormaal(norm(n_zaad), u, v);

    int vxl = blockIdx.x; // 1 voxel per block (simple mapping)
    if (vxl >= aantal_voxels) return;
    if (klasse[vxl] != VOX_BUIS_KAND) return;

    VoxelBereik br = voxels[vxl];
    __shared__ float sx, sy, sz; __shared__ int sc;
    if (threadIdx.x==0){ sx=sy=sz=0.0f; sc=0; }
    __syncthreads();

    // eenvoudige centroid
    for (u32 i = br.start + threadIdx.x; i < br.eind; i += blockDim.x){
        atomicAdd(&sx, punten[i].x);
        atomicAdd(&sy, punten[i].y);
        atomicAdd(&sz, punten[i].z);
        atomicAdd(&sc, 1);
    }
    __syncthreads();
    Vec3f c = {0,0,0};
    if (sc>0 && threadIdx.x==0){ c = maak_vec3(sx/sc, sy/sc, sz/sc); }
    __syncthreads();
    if (sc==0) return;

    // annulus stemmen
    for (u32 i = br.start + threadIdx.x; i < br.eind; i += blockDim.x){
        const Vec3f p = punten[i];
        if (!in_annulus(p, c, Tuning::R_MIN, Tuning::R_MAX)) continue;
        Vec3f d = minv(p, c);
        float theta = halve_cirkel_hoek(d, u, v);
        int s = (int)floorf(theta / (float)M_PI * Tuning::SECTORS_HALF);
        if (s < 0) s = 0; if (s >= Tuning::SECTORS_HALF) s = Tuning::SECTORS_HALF-1;
        atomicAdd(&sect_hist[s], 1u);
    }
    __syncthreads();

    // top-1 sector ‚Üí map naar globale richting-key (octa)
    if (threadIdx.x == 0){
        u32 bestS = 0; u32 bestC = 0;
        for (int s=0; s<Tuning::SECTORS_HALF; ++s){
            if (sect_hist[s] > bestC){ bestC = sect_hist[s]; bestS = s; }
        }
        if (bestC > 0){
            float theta_hat = ( (bestS + 0.5f) / Tuning::SECTORS_HALF ) * (float)M_PI;
            Vec3f a_local = norm( plus( schaal(u, cosf(theta_hat)), schaal(v, sinf(theta_hat)) ) );
            u32 key = kwantiseer_octa_key(a_local, Tuning::OCT_NX, Tuning::OCT_NY);
            u32 idx = atomicAdd(out_size, 1u);
            out_emits[idx] = { key, bestC };
        }
    }
}
FILE_END
FILE_BEGIN legacy/src/plane_vote.cu
#include <cuda_runtime.h>
#include <cub/cub.cuh>
#include "types.cuh"
#include "consts.cuh"
#include "plane_buis_utils.cuh"

// 1) voxel-quickcheck: near/far tellen voor vlak- en buisindicatie
__global__ void k_classificeer_voxels_op_vlak_buis(
    const Vec3f* __restrict__ punten, 
    const VoxelBereik* __restrict__ voxels,
    int aantal_voxels,
    Vec3f test_normaal,
    float d0,
    VoxelKlasse* __restrict__ out_klasse
){
    int v = blockIdx.x * blockDim.x + threadIdx.x;
    if (v >= aantal_voxels) return;

    VoxelBereik br = voxels[v];
    int nearCount = 0;
    int farCount = 0;

    for (u32 i = br.start; i < br.eind; ++i){
        float a2 = afstand2_vlak(test_normaal, d0, punten[i]);
        if (a2 <= Tuning::EPS_NEAR2) nearCount++;
        else if (a2 >= Tuning::TAU_FAR2) farCount++;
    }

    if (nearCount >= Tuning::MIN_NEAR && farCount <= Tuning::MAX_FAR){
        out_klasse[v] = VOX_VLAK_SEED;
    } else if (nearCount < 2 && farCount > 4){
        out_klasse[v] = VOX_BUIS_KAND;
    } else if (nearCount==0 && farCount==0){
        out_klasse[v] = VOX_RUIS;
    } else {
        out_klasse[v] = VOX_GEEN;
    }
}

// 2) block-lokale stemmen naar compacte (key,count) records; 1 richting per pass
__global__ void k_stem_vlak_richting_block(
    const VoxelKlasse* __restrict__ klasse,
    int aantal_voxels,
    Vec3f vlak_normaal,
    KeyCount* __restrict__ out_emits,
    u32* __restrict__ out_size
){
    __shared__ u32 s_key;
    __shared__ u32 s_count;
    if (threadIdx.x == 0){
        u32 key = kwantiseer_octa_key(hemisfeer_fold(norm(vlak_normaal)), Tuning::OCT_NX, Tuning::OCT_NY);
        s_key = key;
        s_count = 0;
    }
    __syncthreads();

    int v = blockIdx.x * blockDim.x + threadIdx.x;
    if (v < aantal_voxels && klasse[v] == VOX_VLAK_SEED){
        atomicAdd(&s_count, 1u);
    }
    __syncthreads();

    if (threadIdx.x == 0 && s_count > 0){
        u32 idx = atomicAdd(out_size, 1u);
        out_emits[idx] = { s_key, s_count };
    }
}
FILE_END
FILE_BEGIN include/axis.h
#pragma once

#include "includes.h"
#include "strict.h" // Assuming strict.h is also needed for includes.h context
// #include <QDebug>   // Required for qDebug

/*
./C++/CloudCompare/libs/qCC_db/src/ccTorus.cpp
./C++/CloudCompare/libs/qCC_db/include/ccBox.h
./C++/CloudCompare/libs/qCC_db/include/ccHObject.h
./C++/CloudCompare/libs/qCC_db/include/ccGenericMesh.h
./C++/CloudCompare/libs/qCC_db/include/ccFacet.h
./C++/CloudCompare/libs/qCC_db/include/ccClipBox.h
./C++/CloudCompare/libs/qCC_db/include/ccQuadric.h
./C++/CloudCompare/libs/qCC_db/include/ccDrawableObject.h
./C++/CloudCompare/libs/qCC_db/include/ccPlanarEntityInterface.h
./C++/CloudCompare/libs/qCC_db/include/ccCoordinateSystem.h
./C++/CloudCompare/libs/qCC_db/include/ccCone.h
./C++/CloudCompare/libs/qCC_db/include/ccKdTree.h
./C++/CloudCompare/libs/qCC_db/src/ccAdvancedTypes.cpp
./C++/CloudCompare/libs/qCC_db/src/ccRasterGrid.cpp
./C++/CloudCompare/libs/qCC_db/src/ccPlanarEntityInterface.cpp
./C++/CloudCompare/libs/qCC_db/src/ccExtru.cpp
./C++/CloudCompare/libs/qCC_db/src/ccPlane.cpp
./C++/CloudCompare/libs/qCC_db/src/ccBBox.cpp
./C++/CloudCompare/libs/qCC_db/src/ccKdTree.cpp// --- AxisAccessor Functor
Struct (Onveranderd) ---
*/

// using CCCoreLib::DegreesToRadians; // If this is a macro or global function, it needs to be defined or included.
// Assuming DegreesToRadians is a function defined elsewhere or in includes.h
namespace CCCoreLib
{
    float DegreesToRadians(float degrees); // Placeholder if not explicitly included
}

const PointCoordinateType zero = 1e-9f;
// Inline downcast helper
inline std::unique_ptr<ccPointCloud> safeDowncastToPointCloud(ccGenericPointCloud* rawCloud)
{
    // Perform a dynamic_cast to safely check the type at runtime
    assert(dynamic_cast<ccPointCloud*>(rawCloud) != nullptr &&
           "Failed to downcast ccGenericPointCloud to ccPointCloud. Object is "
           "not a point cloud.");
    return std::unique_ptr<ccPointCloud>{static_cast<ccPointCloud*>(rawCloud)};
}

inline void mkDir(const QString& path)
{
    QDir dir(path);
    if(!dir.exists())
    {
        std::cout << "Directory does not exist. Creating: " << path.toStdString() << std::endl;
        if(!dir.mkpath("."))
        {
            std::cerr << "Error creating directory" << std::endl;
            return;
        }
    }

    // 3. Verwijder alle bestaande plaatjes met Qt
    std::cout << "Deleting existing images in directory." << std::endl;
    QFileInfoList fileList = dir.entryInfoList(QDir::Files);
    for(const QFileInfo& fileInfo : fileList)
    {
        dir.remove(fileInfo.fileName());
        std::cout << "Deleted: " << fileInfo.fileName().toStdString() << std::endl;
    }
}

// --- Functor Structs for Coordinate Accessors ---
// Deze structs zijn stateless en zullen door de compiler geoptimaliseerd worden
// (zero overhead). Ze bevatten ook een static constexpr char voor de conceptuele
// naam van de as.
struct GetXCoord
{
    inline PointCoordinateType operator()(const CCVector3& v) const { return v.x; }
    static constexpr char      name = 'x';
};

struct GetYCoord
{
    inline PointCoordinateType operator()(const CCVector3& v) const { return v.y; }
    static constexpr char      name = 'y';
};

struct GetZCoord
{
    inline PointCoordinateType operator()(const CCVector3& v) const { return v.z; }
    static constexpr char      name = 'z';
};

template <typename T>
concept HasStaticConstexprCharName = requires {
    // Checkt of T::name een geldige expressie is en exact het type 'char' heeft.
    { T::name } -> std::same_as<const char&>;
};

// --- Global Helper Functions ---
inline size_t getBinnedIndex(PointCoordinateType coord, PointCoordinateType minCoord, PointCoordinateType range,
                             size_t numBins)
{
    if(numBins == 0) return 0; // Geen bins, dus altijd 0

    // Expliciete clamping om binnen het bereik [minCoord, minCoord + range) te
    // blijven
    if(coord < minCoord) return 0;
    // if (coord >= (minCoord + range)) return numBins - 1;

    PointCoordinateType ratio = (coord - minCoord) / range;
    size_t              index = static_cast<size_t>(std::floor(ratio * static_cast<float>(numBins)));
    // Finale clamp om te verzekeren dat de index binnen [0, numBins - 1] valt
    return std::min(index, numBins - 1);
}

// --- PixelMapper Class (ALLES INLINE IN HEADER) ---
class PixelMapper
{
public:
    PixelMapper(PointCoordinateType minCoord, PointCoordinateType maxCoord, size_t numPixels)
        : m_minCoord(minCoord), m_numPixels(numPixels), m_range(maxCoord - minCoord)
    {
        assert(numPixels != 0 && "numPixels cannot be zero for PixelMapper.");

        assert(m_range > static_cast<PointCoordinateType>(zero) && "PixelMapper range must be positive.");
    }

    inline size_t getPixelIndex(PointCoordinateType coord) const
    {
        return getBinnedIndex(coord, m_minCoord, m_range, m_numPixels);
    }

    inline size_t getNumPixels() const { return m_numPixels; }

private:
    PointCoordinateType m_minCoord;
    size_t              m_numPixels;
    PointCoordinateType m_range;
};

// --- Strip Class - ALLES INLINE IN HEADER) ---
class Strip
{
public:
    Strip(PointCoordinateType minCoord, PointCoordinateType maxCoord, size_t numStrips)
        : m_minCoord(minCoord), m_numStrips(numStrips), m_range(maxCoord - minCoord)
    {
        assert(numStrips != 0 && "numStrips cannot be zero.");
        assert(m_range > static_cast<PointCoordinateType>(zero) && "Strip range must be positive.");
        m_pointCountPerStrip.resize(m_numStrips, 0);
    }

    inline void addPoint(PointCoordinateType coord)
    {
        size_t index = getBinnedIndex(coord, m_minCoord, m_range, m_numStrips);
        if(index < m_numStrips)
        {
            m_pointCountPerStrip[index]++;
        }
    }

    // Deze functie berekent nu de variantie van de *tellingen* in alle strips
    inline float getVarianceOfCounts() const
    {
        if(m_numStrips < 2)
        {
            return 0.0f; // Niet genoeg strips om variantie te berekenen
        }

        // Bereken gemiddelde van strip tellingen
        uint64_t totalPoints = 0;
        for(Bocari::u32 count : m_pointCountPerStrip)
        {
            totalPoints += count;
        }

        double mean = static_cast<double>(totalPoints) / static_cast<double>(m_numStrips);

        // Bereken som van gekwadrateerde verschillen van het gemiddelde
        double sumSqDiff = 0.0;
        for(Bocari::u32 count : m_pointCountPerStrip)
        {
            double diff = static_cast<double>(count) - mean;
            sumSqDiff += (diff * diff);
        }

        // Variantie (gedeeld door N, geen sample maar volledige set).
        return static_cast<float>(sumSqDiff / static_cast<double>(m_numStrips));
    }

private:
    PointCoordinateType m_minCoord;
    size_t              m_numStrips;
    PointCoordinateType m_range; // Bereik van co√∂rdinaten
    std::vector<size_t> m_pointCountPerStrip;
};

// --- TEMPLATE Axis Class (ALLES INLINE IN HEADER) ---
template <typename AccessorFunctor> class Axis
{
public:
    // Constructor accepteert nu geen 'roleChar' meer, die komt van de functor
    Axis(const CCVector3& minSceneBounds, const CCVector3& maxSceneBounds, size_t numStrips, size_t numPixels)
        : m_strip(AccessorFunctor{}(minSceneBounds), AccessorFunctor{}(maxSceneBounds), numStrips),
          m_pixelMapper(AccessorFunctor{}(minSceneBounds), AccessorFunctor{}(maxSceneBounds), numPixels)
    {
    }

    inline void addPoint(const CCVector3& point) { m_strip.addPoint(AccessorFunctor{}(point)); }

    inline float getVariance() const { return m_strip.getVarianceOfCounts(); }

    inline size_t getPixelIndex(const CCVector3& point) const
    {
        return m_pixelMapper.getPixelIndex(AccessorFunctor{}(point));
    }

    inline size_t getNumPixels() const { return m_pixelMapper.getNumPixels(); }

    // Role char komt nu direct van de functor via de template parameter
    inline char getRoleChar() const { return AccessorFunctor::name; }

private:
    Strip       m_strip;
    PixelMapper m_pixelMapper;
};

// --- TEMPLATE Plane Class - Zoveel mogelijk INLINE IN HEADER ---
template <typename RotationAccessorFunctor, typename OtherAccessorFunctor> class Plane
{
public:
    // Constructor accepteert nu referenties naar Axis objecten, met hun eigen
    // functor templates
    Plane(Axis<RotationAccessorFunctor>& rotationAxis,
          Axis<OtherAccessorFunctor>&    otherAxis)

        : m_rotationAxis(rotationAxis),                                // Initialiseer referentie-leden
          m_otherAxis(otherAxis),                                      // Initialiseer referentie-leden
          m_outputImage(static_cast<int>(rotationAxis.getNumPixels()), // Breedte van de afbeelding
                        static_cast<int>(otherAxis.getNumPixels()),    // Hoogte van de afbeelding
                        QImage::Format_ARGB32)
    // QImage::Format_Mono) //RR!!!
    {
        m_outputImage.fill(Qt::white);
    }

    inline void addPoint(const CCVector3& point)
    {
        m_rotationAxis.addPoint(point);
        m_otherAxis.addPoint(point);

        size_t x = m_rotationAxis.getPixelIndex(point);
        size_t y = m_otherAxis.getPixelIndex(point);
        m_outputImage.setPixel(static_cast<int>(x), static_cast<int>(y), qRgb(255, 0, 0)); // Teken punt als zwart
    }

    // Bereken de totale variantie van de vlakprojectie
    inline float calcTotalVariance() const
    {
        // Nu roepen we de nieuwe getVariance op die de variantie van de counts
        // berekent
        return m_rotationAxis.getVariance() + m_otherAxis.getVariance();
    }

    // Role chars komen nu direct van de functor templates
    inline char          getRotationAxisRoleChar() const { return RotationAccessorFunctor::name; }
    inline char          getOtherAxisRoleChar() const { return OtherAccessorFunctor::name; }
    inline const QImage& getQImage() const { return m_outputImage; }

private:
    Axis<RotationAccessorFunctor>& m_rotationAxis; // Blijft een referentie
    Axis<OtherAccessorFunctor>&    m_otherAxis;    // Blijft een referentie
    QImage                         m_outputImage;
};

using TMatrixBuilder = std::function<void(ccGLMatrix&, float angleRad)>;

// --- AxisRotation Class (Declaration and implementation in header) ---
class AxisRotation
{
public:
    // Constructor die de contextgegevens ontvangt
    AxisRotation(ccPointCloud* cloud, TMatrixBuilder& matrixBuilder, ccMainAppInterface* app)
        : m_cloud(cloud), m_matrixBuilder(matrixBuilder), m_app(app)
    {
        if(!m_cloud)
        {
            dbg("AxisRotation::AxisRotation: cloud can't be null.");
        }
    }

#include <chrono> // De cruciale header

    template <typename RotationAccessorFunctor, typename OtherAccessorFunctor> float rotateAndAnalyzeCoarseMiddleFine()
    {
        // 1. Grove fase (Coarse)
        float bestCoarseAngle =
            analyzeRotationCase<RotationAccessorFunctor, OtherAccessorFunctor>("Coarse", -45.0f, +45.0f, 15.0f, 128);
        std::ostringstream ss_coarse;
        ss_coarse << "Phase: Coarse, Best Angle: " << bestCoarseAngle;
        dbg(ss_coarse.str().c_str());

        /*

        // 2. Midden fase (Middle)
        float bestMiddleAngle = analyzeRotationCase<RotationAccessorFunctor, OtherAccessorFunctor>(
            "Middle", -15.0f + bestCoarseAngle, +15.0f + bestCoarseAngle, 5.0f, 512);
        std::ostringstream ss_middle;
        ss_middle << "Phase: Middle, Best Angle: " << bestMiddleAngle;
        dbg(ss_middle.str().c_str());

        // 3. Fijne fase (Fine)
        float bestFineAngle = analyzeRotationCase<RotationAccessorFunctor, OtherAccessorFunctor>(
            "Fine", -5.0f + bestMiddleAngle, +5.0f + bestMiddleAngle, 1.0f, 1024);
        std::ostringstream ss_fine;
        ss_fine << "Phase: Fine, Best Angle: " << bestFineAngle;
        dbg(ss_fine.str().c_str());

        */
        // return bestFineAngle;
        return bestCoarseAngle;
    }

private:
    template <typename RotationAccessorFunctor, typename OtherAccessorFunctor>
    float analyzeRotationCase(const std::string& phaseName, float startDeg, float endDeg, float stepDeg,
                              unsigned numStrips)
    {
        // Kloon de m_cloud EENMALIG aan het begin van analyzeRotationCase.
        // De verdere rotaties en analyses vinden plaats op deze kloon, zodat m_cloud
        // (de member) onaangetast blijft voor de volgende fasen in
        // rotateAndAnalyzeCoarseMiddleFine.
        std::unique_ptr<ccPointCloud> workingCloud(safeDowncastToPointCloud(m_cloud->clone()));
        if(!workingCloud)
        {
            dbg("Failed to clone point cloud for analyzeRotationCase.");
            // Retourneer een veilige standaardwaarde (bijvoorbeeld de start hoek) bij
            // falen
            return startDeg;
        }

        // Struct om het beste resultaat van de iteraties op te slaan
        struct BestIterationResult
        {
            float bestVariance = -std::numeric_limits<float>::infinity();
            float bestAngle    = 0.0f;
        } bestResult;

        const float epsilon   = 0.001f;
        const float stopAngle = endDeg + epsilon;

        bestResult.bestAngle = startDeg;

        if(!m_cloud)
        {
            dbg("Error: Internal cloud pointer is null in analyzeRotationCase.");
            return bestResult.bestAngle;
        }

        // Matrix voor de incrementele stap-rotatie
        ccGLMatrix stepRotMatrix;
        m_matrixBuilder(stepRotMatrix, CCCoreLib::DegreesToRadians(stepDeg));

        // Matrix voor de initi√´le rotatie naar startDeg
        ccGLMatrix initialRotMatrix;
        m_matrixBuilder(initialRotMatrix, CCCoreLib::DegreesToRadians(startDeg));

        // Pas de initi√´le rotatie √©√©n keer toe op de workingCloud om bij startDeg te
        // beginnen
        workingCloud->applyRigidTransformation(initialRotMatrix);
        float angle = startDeg; // Begin direct bij de starthoek

        bool firstIteration = true; // Vlag om de eerste iteratie te markeren (geen
                                    // incrementele rotatie nodig)

        // Typedefs voor de accessor functors om de code leesbaarder te maken
        using ZAccessorFunctor = GetZCoord;

        // Typedefs voor de Axis klassen met specifieke accessor functors
        using RotationAxis = Axis<RotationAccessorFunctor>;
        using OtherAxis    = Axis<OtherAccessorFunctor>;
        using Z_Axis       = Axis<ZAccessorFunctor>;
        // De lus doorloopt alle stappen, beginnend bij de (reeds bereikte) starthoek.
        // De incrementele rotatie wordt *voorafgaand* aan de analyse van elke stap
        // toegepast, behalve voor de allereerste meting op 'startDeg'.
        int sort = 0;
        for(; angle <= stopAngle; angle += stepDeg)
        {
            ++sort;
            if(!firstIteration)
            {
                // Pas de incrementele transformatie toe op de workingCloud, alleen na de
                // eerste iteratie
                workingCloud->applyRigidTransformation(stepRotMatrix);
            }
            firstIteration = false; // Na de eerste iteratie, zet de vlag op false

            // Haal de bounding box van de getransformeerde puntenwolk op
            CCVector3 bbMin, bbMax;
            workingCloud->getBoundingBox(bbMin, bbMax);

            // Bereken de bereiken (ranges) langs de verschillende assen
            PointCoordinateType rotRange   = RotationAccessorFunctor{}(bbMax)-RotationAccessorFunctor{}(bbMin);
            PointCoordinateType otherRange = OtherAccessorFunctor{}(bbMax)-OtherAccessorFunctor{}(bbMin);
            PointCoordinateType zRange     = ZAccessorFunctor{}(bbMax)-ZAccessorFunctor{}(bbMin);

            // Bepaal de maximale range om de scaling factor te berekenen
            PointCoordinateType maxOverallRange = std::max({rotRange, otherRange, zRange});
            if(maxOverallRange <= zero)
            { // Voorkom delen door nul of zeer kleine waardes
                maxOverallRange = 1.0f;
            }

            // Bereken de schaalfactor om de punten in een vaste pixelruimte te passen
            float scalingFactor = static_cast<float>(AxisRotation::MAX_LONGEST_SIDE_PIXELS) / maxOverallRange;

            // Bereken de afmetingen in pixels voor elke as
            size_t rotPixels   = static_cast<size_t>(rotRange * scalingFactor);
            size_t otherPixels = static_cast<size_t>(otherRange * scalingFactor);
            size_t zPixels     = static_cast<size_t>(zRange * scalingFactor);

            // Zorg ervoor dat de afmetingen minimaal 1 pixel zijn om fouten te
            // voorkomen
            if(rotPixels == 0) rotPixels = 1;
            if(otherPixels == 0) otherPixels = 1;
            if(zPixels == 0) zPixels = 1;

            // Construeer nieuwe Axis instanties per lus-iteratie met de berekende
            // parameters Plane 1: Rotatie-as en de 'Other' as
            RotationAxis                                         rotationAxis1(bbMin, bbMax, numStrips, rotPixels);
            OtherAxis                                            otherAxis1(bbMin, bbMax, numStrips, otherPixels);
            Plane<RotationAccessorFunctor, OtherAccessorFunctor> plane_RotAxis_OtherAxis(rotationAxis1, otherAxis1);

            // Plane 2: Rotatie-as en de Z-as
            RotationAxis                                     rotationAxis2(bbMin, bbMax, numStrips, rotPixels);
            Z_Axis                                           zAxis2(bbMin, bbMax, numStrips, zPixels);
            Plane<RotationAccessorFunctor, ZAccessorFunctor> plane_RotAxis_zAxis(rotationAxis2, zAxis2);

            // Plane 3: OtherAxis and the Z-axis
            OtherAxis                                     otherAxis3(bbMin, bbMax, numStrips, otherPixels);
            Z_Axis                                        zAxis3(bbMin, bbMax, numStrips, zPixels);
            Plane<OtherAccessorFunctor, ZAccessorFunctor> plane_OtherAxis_zAxis(otherAxis3, zAxis3);

            // Gebruik √©√©n stringstream voor alle initi√´le debug-informatie
            std::ostringstream ss; // Gebruik ostringstream voor gemakkelijker samenvoegen

            ss << "--- Debugging workingCloud in analyzeRotationCase ---" << std::endl;

            if(!workingCloud)
            {
                ss << "Error: workingCloud is nullptr!" << std::endl;
                dbg(ss.str().c_str()); // Roep dbg hier al aan bij een fatale fout
                return 0.0f;
            }

            ss << "workingCloud current size: " << workingCloud->size() << std::endl;

            // Roep dbg √©√©n keer aan voor alle verzamelde initi√´le debug-informatie
            dbg(ss.str().c_str());
            for(unsigned i = 0; i < workingCloud->size(); ++i)
            {
                const CCVector3* pt = workingCloud->getPoint(i);
                if(!pt)
                {
                    continue;
                }

                float x,y,z;
                (*pt).
                x=pt.

                plane_RotAxis_OtherAxis.addPoint(*pt);
                plane_RotAxis_zAxis.addPoint(*pt);
                plane_OtherAxis_zAxis.addPoint(*pt);
            }

            // Bereken de totale variantie score voor de huidige hoek
            auto score = plane_RotAxis_OtherAxis.calcTotalVariance() + plane_RotAxis_zAxis.calcTotalVariance() +
                         plane_OtherAxis_zAxis.calcTotalVariance();

            // Toon de huidige geaccumuleerde hoek en de berekende variantie in de
            // console De 'phaseName' parameter wordt hier gebruikt voor contextuele
            // logging
            dbg(std::format("[{}] Angle: {:.1f} deg, Total Variance: {:.4f}\n", phaseName, angle, score).c_str());

            // Sla de visualisaties van de vlakken op
            QString imageSavePath =
                QString("/workdir/projects/C++/PluginAutoFit/images/%1/").arg(RotationAccessorFunctor::name);

            logAndSavePlane(plane_RotAxis_OtherAxis, phaseName, sort, angle, score, imageSavePath);
            logAndSavePlane(plane_RotAxis_zAxis, phaseName, sort, angle, score, imageSavePath);
            logAndSavePlane(plane_OtherAxis_zAxis, phaseName, sort, angle, score, imageSavePath);
            dbg("--------------------------------\n");

            // Update het beste resultaat als de huidige score beter is
            if(score > bestResult.bestVariance)
            { // We zoeken naar de maximale variantie
                bestResult.bestVariance = score;
                bestResult.bestAngle    = angle;
            }
        }

        // Retourneer de best gevonden absolute hoek voor deze analysefase
        return bestResult.bestAngle;
    }

    ccPointCloud*   m_cloud;         // Niet-eigendomsreferentie naar de cloud
    TMatrixBuilder& m_matrixBuilder; // Referentie naar de matrix builder functie

    ccMainAppInterface*   m_app;
    const static unsigned MAX_LONGEST_SIDE_PIXELS = 1000; // Voorbeeldwaarde
};

// Functie om de breedte en hoogte van een plane te loggen
// 'T' staat hier voor het specifieke type van de Plane objecten die je
// doorgeeft (bijv. Plane<int>, Plane<double> etc.)
template <typename T> void logPlaneInfo(const T& plane)
{
    std::cout << std::format("Plane {}{} (Width: {} Height: {})\n", plane.getRotationAxisRoleChar(),
                             plane.getOtherAxisRoleChar(), plane.getQImage().width(), plane.getQImage().height());
}

std::string angleToSortableString(float angle) { return std::format("{:02.0f}", angle); }

// Functie om een afbeelding van een plane op te slaan
// 'T' staat hier voor het specifieke type van de Plane objecten die je
// doorgeeft.
template <typename T>
bool savePlaneImage(const T& plane, const std::string& phaseName, int sort, float angle, float score,
                    const QString& imageSaveDirectory)
{
    // Bestandsnaam genereren
    // Usage in your Qt code:
    std::string baseFileName =
        std::format("{}_{}{}_{:03}_{:02.0f}_{:.2f}.png", phaseName, plane.getRotationAxisRoleChar(),
                    plane.getOtherAxisRoleChar(), sort, angle, score);

    QString fullPath = imageSaveDirectory + QString::fromStdString(baseFileName);

    // Afbeelding opslaan
    if(plane.getQImage().save(fullPath))
    {
        std::cout << std::format("Saved image: {}\n", fullPath.toStdString());
        return true;
    } else
    {
        std::cerr << std::format("Failed to save image: {}\n", fullPath.toStdString());
        return false;
    }
}

template <typename T>
void logAndSavePlane(const T& plane, const std::string& phaseName, int sort, float angle, float score,
                     const QString& imageSaveDirectory)
{
    logPlaneInfo(plane);
    savePlaneImage(plane, phaseName, sort, angle, score, imageSaveDirectory);
}

// --- Explicit Template Instantiations ---
// These instantiations force the compiler to generate code for these specific
// template specializations, allowing debuggers to set breakpoints.

// Instantiations for Axis class (used by Plane)
template class __attribute__((used)) Axis<GetXCoord>;
template class __attribute__((used)) Axis<GetYCoord>;
template class __attribute__((used)) Axis<GetZCoord>;

// Instantiations for Plane class
// Based on AxisRotation::analyzeRotationCase, the following Plane types are created:
// Plane<RotationAccessorFunctor, OtherAccessorFunctor>
// Plane<RotationAccessorFunctor, ZAccessorFunctor> (where ZAccessorFunctor is GetZCoord)
template class __attribute__((
    used)) Plane<GetXCoord, GetYCoord>; // For Plane_RotAxis_OtherAxis when Rot is X, Other is Y
template class __attribute__((
    used)) Plane<GetYCoord, GetXCoord>; // For Plane_RotAxis_OtherAxis when Rot is Y, Other is X

// Instantiations for logPlaneInfo, savePlaneImage, logAndSavePlane
// These are instantiated for the specific Plane types generated above.
template void __attribute__((used)) logPlaneInfo<Plane<GetXCoord, GetYCoord>>(const Plane<GetXCoord, GetYCoord>& plane);
template bool __attribute__((used))
savePlaneImage<Plane<GetXCoord, GetYCoord>>(const Plane<GetXCoord, GetYCoord>& plane, const std::string& phaseName,
                                            int sort, float angle, float score, const QString& imageSaveDirectory);
template void __attribute__((used))
logAndSavePlane<Plane<GetXCoord, GetYCoord>>(const Plane<GetXCoord, GetYCoord>& plane, const std::string& phaseName,
                                             int sort, float angle, float score, const QString& imageSaveDirectory);

template void __attribute__((used)) logPlaneInfo<Plane<GetYCoord, GetXCoord>>(const Plane<GetYCoord, GetXCoord>& plane);
template bool __attribute__((used))
savePlaneImage<Plane<GetYCoord, GetXCoord>>(const Plane<GetYCoord, GetXCoord>& plane, const std::string& phaseName,
                                            int sort, float angle, float score, const QString& imageSaveDirectory);
template void __attribute__((used))
logAndSavePlane<Plane<GetYCoord, GetXCoord>>(const Plane<GetYCoord, GetXCoord>& plane, const std::string& phaseName,
                                             int sort, float angle, float score, const QString& imageSaveDirectory);

template void __attribute__((used)) logPlaneInfo<Plane<GetXCoord, GetZCoord>>(const Plane<GetXCoord, GetZCoord>& plane);
template bool __attribute__((used))
savePlaneImage<Plane<GetXCoord, GetZCoord>>(const Plane<GetXCoord, GetZCoord>& plane, const std::string& phaseName,
                                            int sort, float angle, float score, const QString& imageSaveDirectory);
template void __attribute__((used))
logAndSavePlane<Plane<GetXCoord, GetZCoord>>(const Plane<GetXCoord, GetZCoord>& plane, const std::string& phaseName,
                                             int sort, float angle, float score, const QString& imageSaveDirectory);

template void __attribute__((used)) logPlaneInfo<Plane<GetYCoord, GetZCoord>>(const Plane<GetYCoord, GetZCoord>& plane);
template bool __attribute__((used))
savePlaneImage<Plane<GetYCoord, GetZCoord>>(const Plane<GetYCoord, GetZCoord>& plane, const std::string& phaseName,
                                            int sort, float angle, float score, const QString& imageSaveDirectory);
template void __attribute__((used))
logAndSavePlane<Plane<GetYCoord, GetZCoord>>(const Plane<GetYCoord, GetZCoord>& plane, const std::string& phaseName,
                                             int sort, float angle, float score, const QString& imageSaveDirectory);

// Instantiations for AxisRotation::analyzeRotationCase
// These are called from rotateAndAnalyzeCoarseMiddleFine.
template float __attribute__((used))
AxisRotation::analyzeRotationCase<GetXCoord, GetYCoord>(const std::string& phaseName, float startDeg, float endDeg,
                                                        float stepDeg, unsigned numStrips);
template float __attribute__((used))
AxisRotation::analyzeRotationCase<GetYCoord, GetXCoord>(const std::string& phaseName, float startDeg, float endDeg,
                                                        float stepDeg, unsigned numStrips);

// Instantiations for AxisRotation::rotateAndAnalyzeCoarseMiddleFine
// You had these already, keeping them.
template float __attribute__((used)) AxisRotation::rotateAndAnalyzeCoarseMiddleFine<GetXCoord, GetYCoord>();
template float __attribute__((used)) AxisRotation::rotateAndAnalyzeCoarseMiddleFine<GetYCoord, GetXCoord>();
FILE_END
FILE_BEGIN include/wiskunde_utils.cuh
#pragma once
#include <algorithm>
#include <cmath>

struct Vec3f
{
    float x, y, z;
};
struct Quat
{
    float w, x, y, z;
};

__host__ __device__ inline Vec3f normalize(const Vec3f& v)
{
    float n = std::sqrt(v.x * v.x + v.y * v.y + v.z * v.z) + 1e-20f;
    return {v.x / n, v.y / n, v.z / n};
}
__host__ __device__ inline float dot(const Vec3f& a, const Vec3f& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__host__ __device__ inline Vec3f cross(const Vec3f& a, const Vec3f& b)
{
    return {a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x};
}

// Welford: gemiddelde & M2 (variance som) voor streaming cosines
struct Welford
{
    int   n    = 0;
    float mean = 0.f;
    float M2   = 0.f;

    __host__ __device__ inline void add(float x)
    {
        n++;
        float delta = x - mean;
        mean += delta / float(n);
        float delta2 = x - mean;
        M2 += delta * delta2;
    }
    __host__ __device__ inline float variance() const { return (n & gt; 1) ? (M2 / float(n - 1)) : 0.f; }
    __host__ __device__ inline float sigma() const
    {
        float v = variance();
        return v & gt;
        0.f ? std::sqrt(v) : 0.f;
    }
};

// Exponential moving average op een normalerichting
struct EmaNormaal
{
    Vec3f n     = {0, 0, 1};
    bool  init  = false;
    float alpha = 0.2f;

    __host__ __device__ inline void setAlpha(float a) { alpha = a; }

    __host__ __device__ inline void add(const Vec3f& amp; m)
    {
        if(!init)
        {
            n    = normalize(m);
            init = true;
            return;
        }
        // lineaire mix gevolgd door normaliseren
        Vec3f mix{(1 - alpha) * n.x + alpha * m.x, (1 - alpha) * n.y + alpha * m.y, (1 - alpha) * n.z + alpha * m.z};
        n = normalize(mix);
    }
};

// Quaternion helpers
inline Quat quat_from_axis_angle(const Vec3f& axis, float rad)
{
    Vec3f a = normalize(axis);
    float s = std::sin(rad * 0.5f);
    return {std::cos(rad * 0.5f), a.x * s, a.y * s, a.z * s};
}
inline Vec3f quat_rotate(const Quat& q, const Vec3f& v)
{
    // v' = q * (0,v) * q^{-1}
    Vec3f u{q.x, q.y, q.z};
    float s   = q.w;
    Vec3f uv  = cross(u, v);
    Vec3f uuv = cross(u, uv);
    Vec3f out{v.x + 2.0f * (s * uv.x + uuv.x), v.y + 2.0f * (s * uv.y + uuv.y), v.z + 2.0f * (s * uv.z + uuv.z)};
    return out;
}
inline Quat quat_mul(const Quat& a, const Quat& b)
{
    return {a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z, a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x, a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w};
}

// Decompose quaternion naar Z-rotatie (yaw) vervolgens Y-rotatie (pitch).
// Doel: twee as-rotaties kunnen printen in graden (CloudCompare UI check).
inline void quat_to_ZY_angles(const Quat& q, float& yawDeg, float& pitchDeg)
{
    // Converteer naar rotatiematrix en haal ZY-Euler (yaw-pitch, geen roll).
    // r = Rz(yaw)*Ry(pitch)
    float ww = q.w * q.w, xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;
    float xy = q.x * q.y, xz = q.x * q.z, yz = q.y * q.z, wx = q.w * q.x, wy = q.w * q.y, wz = q.w * q.z;

    float r00 = ww + xx - yy - zz;
    float r01 = 2 * (xy - wz);
    float r02 = 2 * (xz + wy);

    float r10 = 2 * (xy + wz);
    float r11 = ww - xx + yy - zz;
    float r12 = 2 * (yz - wx);

    float r20 = 2 * (xz - wy);
    float r21 = 2 * (yz + wx);
    float r22 = ww - xx - yy + zz;

    // ZY-extract
    float pitch = std::asin(std::clamp(-r20, -1.0f, 1.0f)); // Ry
    float yaw   = std::atan2(r10, r00);                     // Rz

    yawDeg   = yaw * 180.0f / float(M_PI);
    pitchDeg = pitch * 180.0f / float(M_PI);
}

// Clip kleine correcties (|graad| < clip) naar 0
inline void clip_small_degrees(float clipDeg, float& deg)
{
    if(std::fabs(deg) < clipDeg) deg = 0.f;
}
FILE_END
FILE_BEGIN include/otndc.h
#pragma once
#include <cuda_runtime.h>
#include <stdint.h>

// === Resultaat voor hoofdassen ===
struct AssenResultaat {
    float v[3][3];   // 3 assen (unit)
    float score[3];  // sterkte per as (aantal gewogen stemmen)
    int   dimensie;  // 1D/2D/3D (hier: 1 of 2 of 3 als we later uitbreiden)
};

// === Config (OTNDC) ===
// Namen NL; geen magic numbers.
struct OTConfig {
    // Boeren-ring (ruisfilter)
    float binnenStraal2;   // min ring (kwadraat)
    float buitenStraal2;   // max ring (kwadraat)

    // Paar-acceptatie (orthogonaliteit)
    // Voor "hoek >= 20¬∞" gebruiken we |dot| <= cos(70¬∞) ~= 0.342.
    float maxDotOrtho;     // max |dot(n1,n2)| om kruispaar toe te laten (bv 0.34)

    // Warmup/minimum
    int   warmupMin;       // minimum stemmen om een richting te houden (__host__-reduce)

    // Kernel/block
    int   blokGrootte;     // threads per blok (bv 256)
    int   partnerZoekRadius; // max offset in tile om partner te zoeken (bv 32)
};

// Interne slot-accu voor as-samples (globaal).
struct OTAsAccu {
    float3 som;    // vectorsom van a-samples
    int    count;  // aantal (gewogen) stemmen
};

// Run via paren ‚Üí schat een top-as richting (v[0])
// x/y/z: arrays met punten (getransleerde cloud: stralen ‚âà p/|p|)
// N: aantal punten
// out: vult v[0], score[0], dimensie (>=1 als er steun is)
void runOTNDC_pairs(
    const float* x, const float* y, const float* z, int N,
    AssenResultaat* out,
    const OTConfig& cfg);
FILE_END
FILE_BEGIN include/k_vox
#pragma once
#include "types.cuh"

#define REGIO_PREFIX_BITS 12   // of jouw oorspronkelijke waarde

struct Kwantisatie {
    float3 bbMin;
    float3 invScale; // = 1 / voxelSize
};

__device__ __forceinline__
void kwantiseer_punt(const Vec3f& p, const Kwantisatie& Q, u32& xi, u32& yi, u32& zi)
{
    float3 rel = make_float3(
        (p.x - Q.bbMin.x) * Q.invScale.x,
        (p.y - Q.bbMin.y) * Q.invScale.y,
        (p.z - Q.bbMin.z) * Q.invScale.z);

    xi = (u32) rel.x;
    yi = (u32) rel.y;
    zi = (u32) rel.z;
}

__device__ __forceinline__
u64 morton_encode_3d(u32 x, u32 y, u32 z)
{
    return (part1by2(z) << 2) | (part1by2(y) << 1) | part1by2(x);
}
FILE_END
FILE_BEGIN include/morton_utils.cuh
#pragma once
#include "types.cuh"
#include <stdint.h>

// --------------------------------------------------------------
// CONFIG
// --------------------------------------------------------------

#ifndef REGIO_PREFIX_BITS
#define REGIO_PREFIX_BITS 12 // of jouw waarde
#endif

// Max bits voor 3D morton: 3 √ó 21 = 63 bits ‚Üí genoeg.
// De regio-prefix pakt de top REGIO_PREFIX_BITS bits.
static constexpr uint64_t MORTON_MASK = (~0ULL >> REGIO_PREFIX_BITS);

// --------------------------------------------------------------
// Bit interleave helpers (21 bits ‚Üí 63 bits)
// --------------------------------------------------------------

__host__ __device__ inline uint64_t part1by2(uint64_t x)
{
    x &= 0x1fffffULL; // 21 bits
    x = (x | (x << 32)) & 0x1f00000000ffffULL;
    x = (x | (x << 16)) & 0x1f0000ff0000ffULL;
    x = (x | (x << 8)) & 0x100f00f00f00f00fULL;
    x = (x | (x << 4)) & 0x10c30c30c30c30c3ULL;
    x = (x | (x << 2)) & 0x1249249249249249ULL;
    return x;
}

__host__ __device__ inline uint64_t morton3D(uint32_t x, uint32_t y, uint32_t z)
{
    return part1by2(x) | (part1by2(y) << 1) | (part1by2(z) << 2);
}

// --------------------------------------------------------------
// Kwantisatie-struct
// --------------------------------------------------------------

struct Kwantisatie
{
    float3 bbMin;
};

// Clamp naar 32-bit (voor veiligheid)
__host__ __device__ inline uint32_t clampu32(uint64_t v) { return (v > 0xffffffffULL) ? 0xffffffffu : (uint32_t)v; }

// --------------------------------------------------------------
// Float3 ‚Üí kwantisatie naar integer 0..2^21
// --------------------------------------------------------------
__host__ __device__ inline void kwantiseer_punt(const Vec3f& p, const Kwantisatie& Q, uint32_t& xi, uint32_t& yi,
                                                uint32_t& zi)
{
    float X = (p.x - Q.bbMin.x) * KWANTISATIE_SCHAAL;
    float Y = (p.y - Q.bbMin.y) * KWANTISATIE_SCHAAL;
    float Z = (p.z - Q.bbMin.z) * KWANTISATIE_SCHAAL;

    auto quant = [](float v) -> uint32_t {
        float t = v + 0.5f; // round-to-nearest (simpel, snel)
        if(t < 0.f) t = 0.f;
        uint64_t w = (uint64_t)t; // floor
        return (w > 0xffffffffULL ? 0xffffffffu : (uint32_t)w);
    };

    xi = quant(X);
    yi = quant(Y);
    zi = quant(Z);
}

// --------------------------------------------------------------
// Combine morton + regio-prefix
// --------------------------------------------------------------

__host__ __device__ inline uint64_t morton_met_regio(uint32_t xi, uint32_t yi, uint32_t zi, uint32_t regioCode)
{
    uint64_t m = morton3D(xi, yi, zi);
    return (((uint64_t)regioCode) << (64 - REGIO_PREFIX_BITS)) | (m & MORTON_MASK);
}
FILE_END
FILE_BEGIN include/consts.cuh.old
#pragma once
//
// consts.cuh -- constexpr tables + __device__ __constant__ mirrors
//
#include "math_utils.cuh"

namespace Bocari { namespace Cuda {

// Pre-instantiated sets (compile-time)
constexpr ConstsStruct kVoxelTable[] = {
    makeConsts<64>(),   // index 0
    makeConsts<128>()   // index 1
};
constexpr int kVoxelCount = sizeof(kVoxelTable)/sizeof(kVoxelTable[0]);

constexpr ConstsStruct kSubVoxelTable[] = {
    makeConsts<8>(),    // 3 bits
    makeConsts<16>(),   // 4 bits
    makeConsts<32>(),   // 5 bits
    makeConsts<64>()    // 6 bits
};
constexpr int kSubVoxelCount = sizeof(kSubVoxelTable)/sizeof(kSubVoxelTable[0]);

// __device__ mirrors (optional; __host__ can memcpy into these if desired)
__device__ __constant__ ConstsStruct d_voxelTable[kVoxelCount];
__device__ __constant__ ConstsStruct d_subVoxelTable[kSubVoxelCount];

inline void uploadConstsTo__device__() {
    cudaMemcpyToSymbol(d_voxelTable,   kVoxelTable,   sizeof(kVoxelTable));
    cudaMemcpyToSymbol(d_subVoxelTable,kSubVoxelTable,sizeof(kSubVoxelTable));
}

}} // namespace Bocari::Cuda
FILE_END
FILE_BEGIN include/types.cuh.old
#pragma once
// Nederlandse identifiers, behalve: seed, triangle, forest, tree
#include <cuda_runtime.h>
#include <stdint.h>
#include <math.h>

using u8  = uint8_t;
using u16 = uint16_t;
using u32 = uint32_t;
using u64 = uint64_t;

struct Vec3f { float x,y,z; };

__host__ __device__ inline Vec3f maak_vec3(float x,float y,float z){ return {x,y,z}; }
__host__ __device__ inline float dot(const Vec3f&a,const Vec3f&b){ return a.x*b.x + a.y*b.y + a.z*b.z; }
__host__ __device__ inline Vec3f cross(const Vec3f&a,const Vec3f&b){
    return {a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x};
}
__host__ __device__ inline float lengte2(const Vec3f&a){ return dot(a,a); }
__host__ __device__ inline float lengte(const Vec3f&a){ return sqrtf(lengte2(a)); }
__host__ __device__ inline Vec3f norm(const Vec3f&a){
    float L = lengte(a); return L>0 ? maak_vec3(a.x/L,a.y/L,a.z/L) : maak_vec3(0,0,0);
}
__host__ __device__ inline Vec3f plus(const Vec3f&a,const Vec3f&b){ return {a.x+b.x,a.y+b.y,a.z+b.z}; }
__host__ __device__ inline Vec3f minv(const Vec3f&a,const Vec3f&b){ return {a.x-b.x,a.y-b.y,a.z-b.z}; }
__host__ __device__ inline Vec3f schaal(const Vec3f&a,float s){ return {a.x*s,a.y*s,a.z*s}; }

// deterministische (u,v) ‚üÇ n
__host__ __device__ inline void basis_uv_orthonormaal(const Vec3f& n, Vec3f& u, Vec3f& v){
    Vec3f h = (fabsf(n.x) < 0.9f) ? maak_vec3(1,0,0) : maak_vec3(0,1,0);
    u = norm(cross(h, n));
    v = norm(cross(n, u));
}

// hemisfeer fold (n.z ‚â• 0)
__host__ __device__ inline Vec3f hemisfeer_fold(const Vec3f& a){
    return (a.z < 0.0f) ? schaal(a, -1.0f) : a;
}

// simpele octahedral mapping naar [0,1]^2
__host__ __device__ inline void octa_map(const Vec3f& n, float& ox, float& oy){
    float ax=fabsf(n.x), ay=fabsf(n.y), az=fabsf(n.z);
    float s = ax+ay+az + 1e-20f;
    float x = n.x/s, y = n.y/s;
    if (n.z < 0) {
        float xo = (n.x >= 0) ? 1.0f - fabsf(y) : -1.0f + fabsf(y);
        float yo = (n.y >= 0) ? 1.0f - fabsf(x) : -1.0f + fabsf(x);
        x = xo; y = yo;
    }
    ox = x*0.5f + 0.5f;
    oy = y*0.5f + 0.5f;
}

__host__ __device__ inline u32 kwantiseer_octa_key(const Vec3f& dir, u32 Nx, u32 Ny){
    Vec3f f = hemisfeer_fold(norm(dir));
    float ox, oy; octa_map(f, ox, oy);
    u32 ix = (u32)fminf(fmaxf(ox * Nx, 0.0f), (float)(Nx-1));
    u32 iy = (u32)fminf(fmaxf(oy * Ny, 0.0f), (float)(Ny-1));
    return (iy * Nx) + ix; // 2D ‚Üí 1D
}
FILE_END
FILE_BEGIN include/includes.h
#pragma once

// --- C++ Standard Library ---
#include <algorithm> // Voor std::round, std::max, std::min
#include <array>
#include <cassert> // Voor assert
#include <cmath>   // Voor std::floor, std::round, std::sqrt, std::abs
#include <cstddef> // Voor size_t
#include <cstdint>
#include <format>
#include <functional>  // Voor std::function
#include <iostream>    // Voor std::cout, std::cerr
#include <limits>      //
#include <memory>      // Voor std::unique_ptr, std::shared_ptr
#include <numeric>     //
#include <signal.h>    // Voor signal()
#include <sstream>     // Voor std::stringstream (toegevoegd voor eerdere discussie)
#include <stdexcept>   // Voor std::invalid_argument, std::runtime_error
#include <string>      //
#include <tuple>       //
#include <type_traits> // Vereist voor std::is_base_of_v
#include <vector>      //

// --- CloudCompare Core ---
// #include <PointCloud.h> // Let op: kan conflicteren met ccPointCloud indien
// beide gebruikt worden
// #include <ccColorScaleEditorDialog.h>
#include <ccColorScalesManager.h>
#include <ccGLMatrix.h>
#include <ccHObject.h>          // For ccHObject::Container
#include <ccMainAppInterface.h> // For ccMainAppInterface
#include <ccOctree.h>
#include <ccPointCloud.h>
#include <ccScalarField.h>
#include <ccStdPluginInterface.h> // Voor CloudCompare plugin interface

// --- CCCoreLib ---
#include <CCConst.h>
#include <CCCoreLib.h> // Voor CCCoreLib::computeOptimalLevel
#include <CCGeom.h>    //
#include <CCMath.h>    // Voor CCCoreLib::DegreesToRadians
#include <CCTypes.h>   // Voor PointCoordinateType = float!
#include <CloudSamplingTools.h>
#include <DgmOctree.h>
#include <GenericIndexedCloudPersist.h>
#include <ReferenceCloud.h>

// --- Qt ---
#include <QAction>
#include <QColor> // For qRgb
// #include <QDebug> // Voor qDebug
#include <QDir> // Voor QDir::mkpath
#include <QFile>
#include <QImage>
#include <QList>
#include <QObject>
#include <QString>
#include <QTextStream>
#include <QtGlobal> // For Qt::white etc.

// --- Project-specific forward declarations ---
namespace Bocari
{
    using u32 = uint32_t;
    using i32 = int32_t;
    template <typename T> constexpr u32 U32(T x) { return static_cast<u32>(x); }
    template <typename T> constexpr i32 I32(T x) { return static_cast<i32>(x); }

    namespace Math
    {
        // Helper functions
        template <typename T> constexpr T pow2(T x) { return x * x; }
        template <typename T> constexpr T pow3(T x) { return x * x * x; }
    } // namespace Math

    namespace Pointcloud
    {
        struct Point;
    }

    namespace Voxelprocessing
    {
    }
} // namespace Bocari

inline void dbg(const char* message) { std::cout << message << std::endl; }
inline void dbg(const QString& s) { dbg(s.toStdString().c_str()); }
FILE_END
FILE_BEGIN include/orchestratie.h
#pragma once
#include <vector>
#include <string>
#include "types.cuh"

struct AxisPermutatie {
// __host__ arrays (na permutatie)
std::vector<float> x;
std::vector<float> y;
std::vector<float> z;
char naamX='x', naamY='y', naamZ='z'; // oorspronkelijke namen
uint32_t Vx=0, Vy=0, Vz=0;            // #voxels per as (voor morton)
};

struct OrchestratieResultaat {
// hoofdrichtingen (na stemmen; niet-orthonormaal)
float3 richtA=make_float3(0,0,1);
float3 richtB=make_float3(1,0,0);
float3 richtC=make_float3(0,1,0);
bool   frameGevonden=false;
};

void doOptimizeFrame2(/* CloudCompare hook: m_selectedCloud etc. worden intern opgehaald */);

// helpers (ge√´xporteerd voor tests)
AxisPermutatie h_bereken_en_permuteer(const std::vector<float>& X,
const std::vector<float>& Y,
const std::vector<float>& Z,
float3 bbMin, float3 bbMax);
FILE_END
FILE_BEGIN include/merge_split.cuh
#pragma once
#include "types.cuh"

// ====== Doel ======
// __host__ levert drie afzonderlijke arrays (x[], y[], z[]) in "nieuwe as-volgorde"
// (na AxisPermutatie op de __host__).
// GPU merge't naar √©√©n Vec3f-buffer voor kernels die coalesced 3D willen.
// Later kan GPU weer splitten naar (x[],y[],z[]) zodat __host__ makkelijk terug-permuteert.

// Merge: (x,y,z) ‚Üí Vec3f
void h_merge_xyz_naar_vec3(const DeviceBuffer<float>& d_x, const DeviceBuffer<float>& d_y,
                           const DeviceBuffer<float>& d_z, DeviceBuffer<Vec3f>& d_pts);

// Split: Vec3f ‚Üí (x,y,z)
void h_split_vec3_naar_xyz(const DeviceBuffer<Vec3f>& d_pts, DeviceBuffer<float>& d_x, DeviceBuffer<float>& d_y,
                           DeviceBuffer<float>& d_z);

// ====== Helpers voor AxisPermutatie ======
// Bouw __host__zijde AxisPermutatie-array vanuit drie kolommen (x,y,z) die al
// hernoemd/gepermutateerd zijn.
inline void h_axis_permutatie_vul(AxisPermutatie (&ap)[3], const float* nieuwX, const float* nieuwY,
                                  const float* nieuwZ, char naamX, char naamY, char naamZ, uint32_t Vx, uint32_t Vy,
                                  uint32_t Vz)
{
    ap[0] = AxisPermutatie{nieuwX, naamX, Vx};
    ap[1] = AxisPermutatie{nieuwY, naamY, Vy};
    ap[2] = AxisPermutatie{nieuwZ, naamZ, Vz};
    // Volgorde ap[0]=X, ap[1]=Y, ap[2]=Z is wat GPU verwacht.
}
FILE_END
FILE_BEGIN include/types.cuh
#pragma once
#include <cstdint>

struct Vec3f
{
    float x, y, z;
};

enum class PuntType : uint8_t { Ruis = 0, Vlak = 1, Buis = 2, Bocht = 3, TStuk = 4, Kruis = 5, Verloop = 6 };

// SoA labels (GPU-vriendelijk)
struct LabelSoA
{
    uint8_t*  d_type = nullptr; // PuntType
    uint32_t* d_id   = nullptr; // cluster/object id
    size_t    n      = 0;
};
FILE_END
FILE_BEGIN include/config.h
#pragma once
#include <cstdint>

namespace cfg {

// Globale schakelaars voor richting-stemmen
struct RichtingStemmen {
// banden op cosine(|cos(theta)|); near strakker dan ok
float bandNearCos   = 0.985f;   // ~10¬∞ ‚Üí 0.9848
float bandOkCos     = 0.940f;   // ~20¬∞ ‚Üí 0.9397
float minNearOkRatio = 0.70f;   // ok telt mee als near/ok ‚â• 0.70

// gewichten (vlak zwaarder dan buis)
float vlakStraalGewicht = 1.00f;
float buisStraalGewicht = 0.55f;

// warmup & evict
int   warmupMinSamples = 200;
int   maxSlots         = 12;     // initieel veel
int   targetSlots      = 3;      // na evict naar 3 (1..3)
float evictRatio       = 5.0f;   // evict als score[i]*5 < maxScore

// EMA nudge
float emaAlphaVlak   = 0.25f;
float emaAlphaBuis   = 0.12f;

// Clipjes
float maxLockGraads  = 6.0f;     // reject als groter dan dit
float clipKleinGraads= 2.0f;     // kleine correcties negeren als < 2¬∞

};

// Voor later: buis/vlak specifieke tolerantievelden
struct VlakToleranties {
float slabEps = 0.010f;  // 10 mm
};

struct BuisToleranties {
float rMin   = 0.025f;   // 25 mm
float rMax   = 0.500f;   // 500 mm
};

struct Config {
RichtingStemmen stemmen;
VlakToleranties vlak;
BuisToleranties buis;
};

inline const Config& get() {
static Config C;
return C;
}

} // namespace cfg
FILE_END
FILE_BEGIN include/assen_hernoemen.h
// === context: __host__/assen_hernoemen.hpp ===
#include <array>
#include <algorithm>
#include <iostream>

// Hulptype om componenten van CCVector3 via lambdas te pakken.
struct Toegang {
    char naam;                           // 'x','y','z' (origineel)
    std::function<float(const CCVector3*)> get;
    uint32_t S;                          // onderverdeling langs deze as
};

// Zorgt dat entries[0].S ‚â• entries[1].S ‚â• entries[2].S en wisselt getters/labels mee.
inline void orden_axes_op_S(std::array<Toegang,3>& e)
{
    std::sort(e.begin(), e.end(), [](const Toegang& a, const Toegang& b){ return a.S > b.S; });
    std::cout << "Nieuwe asvolgorde: newX was " << e[0].naam
              << ", newY was " << e[1].naam
              << ", newZ was " << e[2].naam << std::endl;
}
FILE_END
FILE_BEGIN include/autofit_impl.h
// include/autofit_impl.h
#pragma once
#include "autofit.h"
#include "includes.h"
#include "strict.h"

struct OptimizationParams
{
    float   startAngle;
    float   endAngle;
    float   step;
    int     strips;
    QString phaseName;
};

struct OptimizationResult
{
    float                         bestAngle    = 0.0f;
    float                         bestVariance = -1.0f;
    std::unique_ptr<ccPointCloud> bestTransformedCloud;
};

class AutofitImpl
{
public:
    explicit AutofitImpl();

    void performFit(ccMainAppInterface* app, ccPointCloud* selectedCloud); // Implementatie zonder Qt-signalen/slots
    void doOptimizeFrame1();
    std::tuple<float, float> doOptimizeFrame2();

private:
    ccMainAppInterface* m_app           = nullptr;
    ccPointCloud*       m_selectedCloud = nullptr;
    // Subsampling methodes
    std::unique_ptr<ccPointCloud> voxelSubsample(ccPointCloud* inputCloud, int32_t pointCount);
    std::unique_ptr<ccPointCloud> spatialSubsample(ccPointCloud* inputCloud, PointCoordinateType minDistance);
    std::unique_ptr<ccPointCloud> cloneReferenceCloud(CCCoreLib::ReferenceCloud* ref);
};
FILE_END
FILE_BEGIN include/point.h
#pragma once
#include "includes.h"
#include "strict.h"

namespace Bocari
{
    namespace Math
    {
        // Template Vec3 class for float/double
        template <typename T> struct Vec3T
        {
            T x, y, z;

            Vec3T() = default;
            Vec3T(T x_, T y_, T z_) : x(x_), y(y_), z(z_) {}
            // Delegating constructors:
            template <typename U>
                requires(!std::is_same_v<T, U>)
            Vec3T(U x_, U y_, U z_) : Vec3T(static_cast<T>(x_), static_cast<T>(y_), static_cast<T>(z_))
            {
            }

            // Array-like access
            T& operator[](int index)
            {
                assert(index >= 0 && index < 3);
                return (&x)[index];
            }

            const T& operator[](int index) const
            {
                assert(index >= 0 && index < 3);
                return (&x)[index];
            }

            // Converteer naar ander type
            template <typename U>
            explicit Vec3T(const Vec3T<U>& that)
                : x(static_cast<T>(that.x)), y(static_cast<T>(that.y)), z(static_cast<T>(that.z))
            {
            }

            // Constructor voor CCVector3
            explicit Vec3T(const CCVector3& v) : x(static_cast<T>(v.x)), y(static_cast<T>(v.y)), z(static_cast<T>(v.z))
            {
            }

            Vec3T& operator+=(const Vec3T& that)
            {
                x += that.x;
                y += that.y;
                z += that.z;
                return *this;
            }

            Vec3T& operator-=(const Vec3T& that)
            {
                x -= that.x;
                y -= that.y;
                z -= that.z;
                return *this;
            }

            Vec3T& operator*=(T s)
            {
                x *= s;
                y *= s;
                z *= s;
                return *this;
            }

            Vec3T& operator/=(double denom)
            {
                Vec3T* pTHIS = const_cast<T*>(this);
                return pTHIS->operator*=(1.0 / denom);
            }

            Vec3T operator+(const Vec3T& that) const { return Vec3T(x + that.x, y + that.y, z + that.z); }
            Vec3T operator-(const Vec3T& that) const { return Vec3T(x - that.x, y - that.y, z - that.z); }
            Vec3T operator*(T s) const { return Vec3T(x * s, y * s, z * s); }
            Vec3T operator/(T s) const { return this->operator*(1.0 / s); }

            T     dot(const Vec3T& that) const { return x * that.x + y * that.y + z * that.z; }
            Vec3T cross(const Vec3T& that) const
            {
                return Vec3T(y * that.z - z * that.y, z * that.x - x * that.z, x * that.y - y * that.x);
            }

            T length2() const { return Math::pow2(x) + Math::pow2(y) + Math::pow2(z); }
            T length() const { return std::sqrt(length2()); }

            void normalizeInplace(bool& ok)
            {
                T len = length();
                ok    = len > static_cast<T>(1.0e-12);
                if(!ok) return;
                T inv = static_cast<T>(1.0) / len;
                x *= inv;
                y *= inv;
                z *= inv;
            }

            static Vec3T normalFrom(const Vec3T& a, const Vec3T& b, const Vec3T& c, bool& ok)
            {
                Vec3T v1 = b - a;
                Vec3T v2 = c - a;
                Vec3T n  = v1.cross(v2);
                n.normalizeInplace(ok);
                return n;
            }
        };

        using Vec3f = Math::Vec3T<float>;
        using Vec3d = Math::Vec3T<double>;

        // --- Matrix3d + helpers (compact) ---
        struct Matrix3d
        {
            double m[3][3];

            Matrix3d() { zero(); }

            void zero()
            {
                for(int i = 0; i < 3; i++)
                    for(int j = 0; j < 3; j++) m[i][j] = 0.0;
            }

            static Matrix3d zeroMatrix() { return Matrix3d(); }

            Matrix3d& operator+=(const Matrix3d& that)
            {
                for(int i = 0; i < 3; i++)
                    for(int j = 0; j < 3; j++) this->m[i][j] += that.m[i][j];
                return *this;
            }

            Matrix3d& operator*=(double s)
            {
                for(int i = 0; i < 3; i++)
                    for(int j = 0; j < 3; j++) this->m[i][j] *= s;
                return *this;
            }

            Matrix3d operator+(const Matrix3d& that) const
            {
                Matrix3d result;
                for(int i = 0; i < 3; i++)
                    for(int j = 0; j < 3; j++) result.m[i][j] = this->m[i][j] + that.m[i][j];
                return result;
            }

            Matrix3d operator*(double s) const
            {
                Matrix3d result;
                for(int i = 0; i < 3; i++)
                    for(int j = 0; j < 3; j++) result.m[i][j] = this->m[i][j] * s;
                return result;
            }

            Matrix3d operator/(double denom) const { return (*this) * (1.0 / denom); }
        };

        inline Matrix3d outer_product(const Math::Vec3d& a, const Math::Vec3d& b)
        {
            Matrix3d result;
            for(int i = 0; i < 3; i++)
                for(int j = 0; j < 3; j++) result.m[i][j] = a[i] * b[j];
            return result;
        }

        template <typename T> struct Quaternion
        {
            T w, x, y, z;

            Quaternion() = default;

            // Constructor voor w, x, y, z
            Quaternion(T w_in, T x_in, T y_in, T z_in) : w(w_in), x(x_in), y(y_in), z(z_in) {}

            // Generieke constructor voor een vector
            template <typename V> explicit Quaternion(const V& v) : w(0), x(v.x), y(v.y), z(v.z) {}

            // Geconjugeerde
            Quaternion conj() const { return {w, -x, -y, -z}; }

            // Magnitude (lengte) //RR!!! make normSquared, use here and in inverse
            T normSquared() const { return Math::pow2(w) + Math::pow2(x) + Math::pow2(y) + Math::pow2(z); }
            T norm() const { return std::sqrt(normSquared()); }

            // Normaliseer
            void normalize()
            {
                T _norm = norm();
                if(_norm > std::numeric_limits<T>::epsilon())
                {
                    T invMag = static_cast<T>(1.0) / _norm;
                    w *= invMag;
                    x *= invMag;
                    y *= invMag;
                    z *= invMag;
                }
            }

            // Inverse - compute on demand
            Quaternion inverse() const
            {
                T _normSquared = normSquared();
                if(_normSquared == 0) return {1, 0, 0, 0}; // identity as fallback
                return Quaternion(w / _normSquared, -x / _normSquared, -y / _normSquared, -z / _normSquared);
            }

            // Quaternion vermenigvuldiging
            Quaternion operator*(const Quaternion& that) const
            {
                return Quaternion(w * that.w - x * that.x - y * that.y - z * that.z,
                                  w * that.x + x * that.w + y * that.z - z * that.y,
                                  w * that.y - x * that.z + y * that.w + z * that.x,
                                  w * that.z + x * that.y - y * that.x + z * that.w);
            }

            // Roteer een Pointcloud::Point (in-place versie)
            void rotateInPlace(Pointcloud::Point& p) const;

            // Roteer een span van Points in-place
            void rotateSpanInPlace(std::span<Pointcloud::Point> points) const;
        };

        // Convert rotation matrix R (orthonormal, right-handed) to quaternion.
        // Uses robust algorithm and normalizes at the end.
        static Quaternion<double> fromMatrix(const Matrix3d& R)
        {
            double trace = R.m[0][0] + R.m[1][1] + R.m[2][2];
            double qw, qx, qy, qz;

            if(trace > 0.0)
            {
                double s = 0.5 / std::sqrt(trace + 1.0);
                qw       = 0.25 / s;
                qx       = (R.m[2][1] - R.m[1][2]) * s;
                qy       = (R.m[0][2] - R.m[2][0]) * s;
                qz       = (R.m[1][0] - R.m[0][1]) * s;
            } else
            {
                if(R.m[0][0] > R.m[1][1] && R.m[0][0] > R.m[2][2])
                {
                    double s = std::sqrt(1.0 + R.m[0][0] - R.m[1][1] - R.m[2][2]) * 2.0; // s = 4*qx
                    qw       = (R.m[2][1] - R.m[1][2]) / s;
                    qx       = 0.25 * s;
                    qy       = (R.m[0][1] + R.m[1][0]) / s;
                    qz       = (R.m[0][2] + R.m[2][0]) / s;
                } else if(R.m[1][1] > R.m[2][2])
                {
                    double s = std::sqrt(1.0 + R.m[1][1] - R.m[0][0] - R.m[2][2]) * 2.0; // s = 4*qy
                    qw       = (R.m[0][2] - R.m[2][0]) / s;
                    qx       = (R.m[0][1] + R.m[1][0]) / s;
                    qy       = 0.25 * s;
                    qz       = (R.m[1][2] + R.m[2][1]) / s;
                } else
                {
                    double s = std::sqrt(1.0 + R.m[2][2] - R.m[0][0] - R.m[1][1]) * 2.0; // s = 4*qz
                    qw       = (R.m[1][0] - R.m[0][1]) / s;
                    qx       = (R.m[0][2] + R.m[2][0]) / s;
                    qy       = (R.m[1][2] + R.m[2][1]) / s;
                    qz       = 0.25 * s;
                }
            }

            Quaternion q(qw, qx, qy, qz);
            // Normalize quaternion
            double len = std::sqrt(Math::pow2(q.w) + Math::pow2(q.x) + Math::pow2(q.y) + Math::pow2(q.z));
            if(len > 0.0)
            {
                q.w /= len;
                q.x /= len;
                q.y /= len;
                q.z /= len;
            } else
            {
                // fallback identity
                q.w = 1.0;
                q.x = q.y = q.z = 0.0;
            }
            return q;
        }

    } // namespace Math

    namespace Pointcloud
    {

        struct Point
        {
            Point() = default;
            Point(int32_t ccIndex, float x, float y, float z) : m_ccIndex(ccIndex), m_point(x, y, z) {}
            Point(int32_t ccIndex, const Math::Vec3f& vec) : m_ccIndex(ccIndex), m_point(vec) {}
            int32_t     m_ccIndex = -1;
            Math::Vec3f m_point;
            void        dbg() const
            {
                std::cout << "point=(" << m_point.x << ", " << m_point.y << ", " << m_point.z
                          << "), ccIndex = " << m_ccIndex << std::endl;
            }
            // Array-access voor de coordinaten: x->[0], y->[1], z->[2]
            float& operator[](int index)
            {
                assert(index >= 0 && index < 3);
                return (&m_point.x)[index];
            }

            const float& operator[](int index) const
            {
                assert(index >= 0 && index < 3);
                return (&m_point.x)[index];
            }
        };

        ccPointCloud* to_ccPointCloud(std::span<const Pointcloud::Point> points);
        ccPointCloud* createRotatedPointCloud(const Math::Quaternion<double>& quat, const ccPointCloud* original);

    } // namespace Pointcloud
} // namespace Bocari
FILE_END
FILE_BEGIN include/types.h
// Minimale types/structs voor orkestratie (sluit aan op eerdere parts)
#pragma once
#include <cstdint>
#include <cmath>

using u8  = uint8_t;
using u32 = uint32_t;
using u64 = uint64_t;

struct Vec3f { float x,y,z; };
struct Quatf { float w,x,y,z; };

struct StemKeyVal {
u64   key;
float value;
};

// Helpers (declaraties) ‚Äî implementatie in wiskunde_utils.cuh
inline Vec3f make_vec3f(float x,float y,float z){ return Vec3f{x,y,z}; }
FILE_END
FILE_BEGIN include/cc_adapter.h
#pragma once

// Pas onderstaande includes aan naar jouw lokale CloudCompare pad.
// Deze adapter biedt minimale typedefs/bridge die in h_do_optimize_frame3.cpp worden gebruikt.

#include <vector>
#include <string>

struct CCVector3 {
float x, y, z;
};

struct CCPointCloud {
std::vector<CCVector3> punten;
size_t size() const { return punten.size(); }
const CCVector3* getPoint(size_t i) const { return &punten[i]; }
void getBoundingBox(CCVector3& mn, CCVector3& mx) const {
if (punten.empty()){ mn={0,0,0}; mx={0,0,0}; return; }
mn = mx = punten[0];
for (auto &p: punten){
if (p.x<mn.x) mn.x=p.x; if (p.y<mn.y) mn.y=p.y; if (p.z<mn.z) mn.z=p.z;
if (p.x>mx.x) mx.x=p.x; if (p.y>mx.y) mx.y=p.y; if (p.z>mx.z) mx.z=p.z;
}
}
};

// In jouw plugin: vervang bovenstaande dummy door echte CC includes,
// of maak een converteerfunctie die jouw CC cloud omzet naar deze dummy-structs.
FILE_END
FILE_BEGIN include/pairs_bucket.cuh
#pragma once
#include "otndc.h" // for OTAsAccu
#include <cuda_runtime.h>

// kernel forward declaration
extern "C" __global__ void k_otndc_pairs(
    const float* __restrict__ x,
    const float* __restrict__ y,
    const float* __restrict__ z,
    int N,
    float binnen2, float buiten2,
    float maxDotOrtho,
    int partnerZoekRadius,
    OTAsAccu* __restrict__ gAccu);
FILE_END
FILE_BEGIN include/axis_permutatie.h
#pragma once
#include <algorithm>
#include <cstdint>
#include <array>
#include <iostream>
#include "types.h"          // Vec3f, u32
#include "cc_adapter.h"     // CCVector3, CCPointCloud (forward wrappers)

/*
Doel
----

* Bepaal een as-permutatie zodat intern voor de GPU altijd Vx ‚â• Vy ‚â• Vz geldt
  (waar V* = aantal voxel-cellen / effectieve resolutie per as).
* Bewaar de *namen* van de originele assen zodat we na afloop labels
  en (optioneel) geroteerde punten terug kunnen mappen.

## Afspraak

* Identifiers NL, behalve seed/triangle/forest/tree/vote/count/slab.
* Deze header is *__host__-only* hulplogica.
  */

namespace Bocari {

struct AsInfo {
char   naam;   // 'x', 'y' of 'z' (originele naam)
float* data;   // __host__ buffer (x[], y[], z[]) ‚Äî eigendom buiten deze struct
u32    V;      // effectieve voxelverdeling langs deze as (bv. Vx/Vy/Vz)
};

struct AxisPermutatie {
// volgorde newX,newY,newZ na sorteren op V aflopend
AsInfo nieuwX{};
AsInfo nieuwY{};
AsInfo nieuwZ{};


// inverse naam-mapping om later terug te mappen (‚Äòx‚Äô->positie etc.)
// bijv: invNaam['x'] == 'z' betekent: originele ‚Äòx‚Äô kwam op plek ‚Äòz‚Äô terecht.
std::array<char, 256> invNaam{};


};

inline AxisPermutatie maak_axis_permutatie(AsInfo ax, AsInfo ay, AsInfo az)
{
// Sorteer aflopend op V (grotere resolutie eerst).
std::array<AsInfo,3> v = {ax, ay, az};
std::sort(v.begin(), v.end(), [](const AsInfo&a, const AsInfo&b){ return a.V > b.V; });


AxisPermutatie perm;
perm.nieuwX = v[0];
perm.nieuwY = v[1];
perm.nieuwZ = v[2];

// invNaam: voor elke originele naam, waar is hij terechtgekomen?
// newX.naam was bv ‚Äòy‚Äô ‚Üí invNaam['y'] = 'x'
for (auto& r : perm.invNaam) r = 0;
perm.invNaam[(unsigned char)perm.nieuwX.naam] = 'x';
perm.invNaam[(unsigned char)perm.nieuwY.naam] = 'y';
perm.invNaam[(unsigned char)perm.nieuwZ.naam] = 'z';

std::cout << "[AxisPermutatie] volgorde: "
          << perm.nieuwX.naam << "‚Üíx, "
          << perm.nieuwY.naam << "‚Üíy, "
          << perm.nieuwZ.naam << "‚Üíz (op V)\n";
return perm;


}

// Hulpfunctie: druk mapping af
inline void toon_axis_mapping(const AxisPermutatie& P)
{
std::cout << "  nieuwX komt van '" << P.nieuwX.naam << "' (V=" << P.nieuwX.V << ")\n";
std::cout << "  nieuwY komt van '" << P.nieuwY.naam << "' (V=" << P.nieuwY.V << ")\n";
std::cout << "  nieuwZ komt van '" << P.nieuwZ.naam << "' (V=" << P.nieuwZ.V << ")\n";
std::cout << "  inverse naam: "
<< "orig 'x'‚Üí'" << P.invNaam[(unsigned char)'x'] << "', "
<< "orig 'y'‚Üí'" << P.invNaam[(unsigned char)'y'] << "', "
<< "orig 'z'‚Üí'" << P.invNaam[(unsigned char)'z'] << "'\n";
}

} // namespace Bocari
FILE_END
FILE_BEGIN include/grid_utils.h
#pragma once
#include "includes.h"
#include "point.h"
#include "strict.h"

namespace Bocari
{
    namespace Voxelprocessing
    {
        struct RangeData;

        // GridUnion definition. Provides both 3D [_3D[z][y][x]] and flat _1D[] access
        template <typename T, u32 N> union GridUnionT
        {
            static constexpr u32 SIZE = Math::pow3(N);

            T _3D[N][N][N];
            T _1D[SIZE + 1]; // One beyond end

            GridUnionT()
            {
                // Initialiseer laatste element van _1D array op 0/false, omdat dit ongeldig is voor counts.
                _1D[SIZE] = T{};
            }

            void initialize(const T& value = T{})
            {
                for(u32 i = 0; i <= SIZE; ++i) _1D[i] = value;
            }

            T& operator()(u32 z, u32 y, u32 x)
            {
                assert(z < N && y < N && x < N && "3D bounds exceeded");
                return _3D[z][y][x];
            }

            const T& operator()(u32 z, u32 y, u32 x) const
            {
                assert(z < N && y < N && x < N && "3D bounds exceeded");
                return _3D[z][y][x];
            }

            T& operator[](u32 index)
            {
                assert(index < SIZE + 1 && "1D bounds exceeded");
                return _1D[index];
            }

            const T& operator[](u32 index) const
            {
                assert(index < SIZE + 1 && "1D bounds exceeded");
                return _1D[index];
            }
        };

        // Alias for backward compatibility
        template <u32 N> using GridUnion = GridUnionT<u32, N>;

        constexpr u32 log2(u32 n)
        {
            u32 bits = 0;
            while((1 << bits) < n) ++bits;
            return bits;
            // return n <= 1 ? 0 : 1 + computeMadRangeprocessing::log2(n >> 1);
        }

        constexpr u32 maskFor(u32 n) { return n - 1u; }

        template <u32 N> inline u32 flatten3(u32 z, u32 y, u32 x)
        {
            constexpr u32 shift = Voxelprocessing::log2(N);
            return (U32(z) << (2 * shift)) | U32((y) << shift) | U32(x);
        }

        template <u32 N> inline void unflatten3(u32 index, u32& z, u32& y, u32& x)
        {
            constexpr u32 shift = Voxelprocessing::log2(N);
            constexpr u32 mask  = maskFor(N);
            x                   = index & mask;
            y                   = (index >> shift) & mask;
            z                   = (index >> (2 * shift)) & mask;
        }

        template <u32 Bins, typename GroupIndexFunc>
        void countIndices(const std::vector<Pointcloud::Point>& points, u32 begin, u32 end, std::span<u32> counts,
                          GroupIndexFunc groupOf)
        {
            static_assert(Bins >= Math::pow3(32));
            for(u32 i = begin; i < end; ++i)
            {
                int32_t bin = groupOf(points[i]);
                if(bin < 0 || U32(bin) >= Bins) bin = 0;
                counts[U32(bin)]++;
            }
        }

        template <u32 N>
        void buildStartIndices(const std::span<u32> counts, Voxelprocessing::GridUnion<N>& starts, u32 begin)
        {
            static_assert(N <= 64);
            constexpr u32 Bins = Math::pow3(32);
            u32           sum  = begin;
            for(u32 i = 0; i < Bins; ++i)
            {
                starts._1D[i] = sum;
                sum += counts[i];
            }
            starts._1D[Bins] = sum;
        }

        template <u32 N, typename GroupIndexFunc>
        void countingSort(std::vector<Pointcloud::Point>& points, GroupIndexFunc groupOf,
                          Voxelprocessing::GridUnion<N>& starts)
        {
            static_assert(N <= 64);
            constexpr u32         Bins = Math::pow3(N);
            std::array<u32, Bins> counts{};

            countIndices<Bins>(points, 0, U32(points.size()), std::span{counts}, groupOf);
            buildStartIndices<N>(std::span{counts}, starts, 0);

            // Stable reorder
            std::vector<Pointcloud::Point> tmp;
            tmp.resize(points.size());

            std::array<u32, Bins + 1> writePos{};
            std::copy(&starts._1D[0], &starts._1D[Bins + 1], writePos.begin());

            for(const auto& p : points)
            {
                u32 bin = groupOf(p);
                if(bin >= Bins) bin = Bins - 1;
                u32 dest  = writePos[bin]++;
                tmp[dest] = p;
            }

            points.swap(tmp);
        }

        template <u32 N> void buildCumSum(const GridUnion<N>& counts, GridUnion<N>& cumSum)
        {
            cumSum.initialize(0);
            for(u32 z = 0; z < N; ++z)
            {
                for(u32 y = 0; y < N; ++y)
                {
                    for(u32 x = 0; x < N; ++x)
                    {
                        int32_t v = counts(z, y, x);
                        if(z > 0) v += cumSum(z - 1, y, x);
                        if(y > 0) v += cumSum(z, y - 1, x);
                        if(x > 0) v += cumSum(z, y, x - 1);
                        if(z > 0 && y > 0) v -= cumSum(z - 1, y - 1, x);
                        if(z > 0 && x > 0) v -= cumSum(z - 1, y, x - 1);
                        if(y > 0 && x > 0) v -= cumSum(z, y - 1, x - 1);
                        if(z > 0 && y > 0 && x > 0) v += cumSum(z - 1, y - 1, x - 1);
                        cumSum(z, y, x) = v;
                    }
                }
            }
        }

        template <u32 N>
        u32 countPointsInBox(const GridUnion<N>& cumSum, u32 x1, u32 y1, u32 z1, u32 x2, u32 y2, u32 z2)
        {
            if(x1 > x2) std::swap(x1, x2);
            if(y1 > y2) std::swap(y1, y2);
            if(z1 > z2) std::swap(z1, z2);
            auto constexpr mask = maskFor(N);
            x1 &= mask;
            x2 &= mask;
            y1 &= mask;
            y2 &= mask;
            z1 &= mask;
            z2 &= mask;
            if(x1 > x2 || y1 > y2 || z1 > z2) return 0;
            auto get = [&](u32 x, u32 y, u32 z) -> u32 { return cumSum(z, y, x); };
            u32  A   = get(x2, y2, z2);
            u32  B   = (x1 > 0) ? get(x1 - 1, y2, z2) : 0;
            u32  C   = (y1 > 0) ? get(x2, y1 - 1, z2) : 0;
            u32  D   = (z1 > 0) ? get(x2, y2, z1 - 1) : 0;
            u32  E   = (x1 > 0 && y1 > 0) ? get(x1 - 1, y1 - 1, z2) : 0;
            u32  F   = (x1 > 0 && z1 > 0) ? get(x1 - 1, y2, z1 - 1) : 0;
            u32  G   = (y1 > 0 && z1 > 0) ? get(x2, y1 - 1, z1 - 1) : 0;
            u32  H   = (x1 > 0 && y1 > 0 && z1 > 0) ? get(x1 - 1, y1 - 1, z1 - 1) : 0;
            return A - B - C - D + E + F + G - H;
        }
    } // namespace Voxelprocessing
} // namespace Bocari
FILE_END
FILE_BEGIN include/bdrm_lru.cuh
#pragma once
#include "consts.cuh"
#include <cuda_runtime.h>

/**

* Boeren-richtingstralenmethode (BDRM) ‚Äî LRU ringbuffer voor richtingen.
* Bewaart top-k richtingskandidaten binnen een CTA (block), met simpele bubble-swap na score++.
*
* ASCII (per block in shared):
* slot:   0        1        2 ... k-1
* dir:   v0       v1       v2     vk
* score: s0       s1       s2     sk
*
* Invariant: geen volledige sort; alleen lokale swap als score[i] > score[i-1].
  */

struct LruItem
{
    float3 dir;   // genormaliseerd
    int    score; // stemmen
    int    used;  // 0/1
};

template <int K> struct LruBlock
{
    LruItem items[K];

    __device__ void init()
    {
#pragma unroll
        for(int i = 0; i & lt; K; i++)
        {
            items[i].dir   = make_float3(0, 0, 0);
            items[i].score = 0;
            items[i].used  = 0;
        }
    }

    __device__ int find_similar(const float3 v)
    {
#pragma unroll
        for(int i = 0; i & lt; K; i++)
        {
            if(!items[i].used) continue;
            float c = fabsf(items[i].dir.x * v.x + items[i].dir.y * v.y + items[i].dir.z * v.z);
            if(c& gt; = Consts::SIMILAR_COS_MIN) return i;
        }
        return -1;
    }

    __device__ int find_empty_or_evict()
    {
// probeer leeg slot
#pragma unroll
        for(int i = 0; i & lt; K; i++)
            if(!items[i].used) return i;
        // evict agressief op ratio
        int maxIdx = 0;
        for(int i = 1; i & lt; K; i++)
            if(items[i].score& gt; items[maxIdx].score) maxIdx = i;
        const float mx = float(items[maxIdx].score);
        for(int i = 0; i & lt; K; i++)
        {
            if(float(items[i].score) * Consts::EVICT_RATIO & lt; mx) return i;
        }
        // geen evict: pak laagste score
        int minIdx = 0;
        for(int i = 1; i & lt; K; i++)
            if(items[i].score& lt; items[minIdx].score) minIdx = i;
        return minIdx;
    }

    __device__ void bump_and_bubble(int idx)
    {
        items[idx].score += 1;
        // bubble 1 stap naar links indien nodig
        if(idx& gt; 0 & amp;& amp; items[idx].score& gt; items[idx - 1].score)
        {
            LruItem tmp    = items[idx - 1];
            items[idx - 1] = items[idx];
            items[idx]     = tmp;
        }
    }

    __device__ int add_or_bump(const float3 v, int warmupLeft)
    {
        int j = find_similar(v);
        if(j& gt; = 0)
        {
            bump_and_bubble(j);
            return j;
        }
        // alleen nieuwe richting toevoegen als nog warmup of evict toegestaan
        int i          = find_empty_or_evict();
        items[i].dir   = v;
        items[i].score = (warmupLeft & gt; 0 ? 1 : 1); // init score
        items[i].used  = 1;
        // geen bubble voor nieuw; wordt vanzelf omhoog gedrukt bij volgende hits
        return i;
    }
};
FILE_END
FILE_BEGIN include/morton_config.h
#pragma once

// We werken altijd in millimeters.
// Dus: ints = round( (p - bbMin) * 1000 )
static constexpr float KWANTISATIE_SCHAAL = 1000.0f;  // meter ‚Üí mm
static constexpr int   KWANTISATIE_MAX_BITS = 21;     // 0..2^21 (2M mm ‚âà 2000m)
FILE_END
FILE_BEGIN include/strict.h
#pragma once

#if defined(__GNUC__) || defined(__clang__)

// Save current warning state
#pragma GCC diagnostic push

// Enable specific warnings as errors
#pragma GCC diagnostic error "-Wall"
#pragma GCC diagnostic error "-Wextra"
#pragma GCC diagnostic error "-Wpedantic"
#pragma GCC diagnostic error "-Wshadow"
#pragma GCC diagnostic error "-Wnon-virtual-dtor"
#pragma GCC diagnostic error "-Wold-style-cast"
#pragma GCC diagnostic error "-Wunused"
#pragma GCC diagnostic error "-Woverloaded-virtual"
#pragma GCC diagnostic error "-Wconversion"
#pragma GCC diagnostic error "-Wsign-conversion"
#pragma GCC diagnostic error "-Wsuggest-override"

#endif
FILE_END
FILE_BEGIN include/device_buffer.cuh
#pragma once
#include <cuda_runtime.h>
#include <stdexcept>

template <typename T> struct DeviceBuffer
{
    T*     ptr = nullptr;
    size_t n   = 0;

    DeviceBuffer() = default;
    explicit DeviceBuffer(size_t count) { alloc(count); }
    ~DeviceBuffer() { free(); }

    void alloc(size_t count)
    {
        free();
        n = count;
        if(n)
        {
            cudaError_t e = cudaMalloc(&ptr, n * sizeof(T));
            if(e != cudaSuccess) throw std::runtime_error("cudaMalloc failed");
        }
    }
    void free()
    {
        if(ptr) cudaFree(ptr);
        ptr = nullptr;
        n   = 0;
    }
    void upload(const T* h, size_t count)
    {
        if(count != n) throw std::runtime_error("upload size mismatch");
        if(count) cudaMemcpy(ptr, h, count * sizeof(T), cudaMemcpyHostToDevice);
    }
    void download(T* h, size_t count) const
    {
        if(count != n) throw std::runtime_error("download size mismatch");
        if(count) cudaMemcpy(h, ptr, count * sizeof(T), cudaMemcpyDeviceToHost);
    }
};
FILE_END
FILE_BEGIN include/consts.cuh
#pragma once
#include <cuda_runtime.h>

// ============================================================
// Globale (tuneable) __constant__s voor orkestratie & logging
// ============================================================

// Log iedere N "hits" (votes die Gate A passeren)
#ifndef ORCH_LOG_INTERVAL
#define ORCH_LOG_INTERVAL 1024u
#endif

// 1 = ook naar log.txt schrijven (append), 0 = alleen stdout
#ifndef ORCH_LOG_TO_FILE
#define ORCH_LOG_TO_FILE 1
#endif

// Format: vaste precisie voor hoeken/varianties
#ifndef ORCH_LOG_PREC_DEG
#define ORCH_LOG_PREC_DEG 3
#endif

#ifndef ORCH_LOG_PREC_VAR
#define ORCH_LOG_PREC_VAR 4
#endif

*Globale __constant__en voor JBF -
    pipeline.*Waarden in meters.Houd rekening met schaal(__host__ kan schalen als scene > 1km).*/ namespace Consts
{
    // ---------- LIDAR / ring ----------
    __host__ __device__ constexpr float LIDAR_HALF_ERROR   = 0.001f;                           // 1 mm
    __host__ __device__ constexpr float R1_CLUSTER         = 0.004f;                           // 4 mm
    __host__ __device__ constexpr float R2_RING            = 0.012f;                           // 12 mm
    __host__ __device__ constexpr float R2_HALF_CLAIM      = 0.006f;                           // 6 mm
    __host__ __device__ constexpr float R2_HALF_CLAIM_SAFE = R2_HALF_CLAIM - LIDAR_HALF_ERROR; // claim-marge

    // ---------- slab ----------
    __host__ __device__ constexpr float SLAB_TOL         = 0.003f; // 3 mm | vlak-inliers
    __host__ __device__ constexpr int   SLAB_MIN_INLIERS = 4;

    // ---------- chaos veto ----------
    __host__ __device__ constexpr float CHAOS_RANGE_MIN  = 0.008f; // 8 mm
    __host__ __device__ constexpr int   CHAOS_INLIER_MAX = 3;      // <4 => zwak

    // ---------- stemmen / LRU ----------
    __host__ __device__ constexpr int   LRU_SLOTS       = 8;
    __host__ __device__ constexpr int   WARMUP_SEEDS    = 200;
    __host__ __device__ constexpr float ORTHO_COS_MAX   = 0.2f;  // |dot| < 0.2 ~ 11¬∞
    __host__ __device__ constexpr float SIMILAR_COS_MIN = 0.98f; // bijna dezelfde richting
    __host__ __device__ constexpr float EVICT_RATIO     = 5.0f;  // score[i]*5 < maxScore => evict
}
FILE_END
FILE_BEGIN include/autofit.h
#pragma once
#include "includes.h"
#include <QtPlugin>

class AutofitImpl;
class ccPointCloud;

class Autofit : public QObject, public ccStdPluginInterface
{
    Q_OBJECT
    Q_INTERFACES(ccPluginInterface ccStdPluginInterface)
    // Q_PLUGIN_METADATA(IID "nl.Bocari.cc.plugin.Autofit" FILE "../info.json")
    Q_PLUGIN_METADATA(IID "cc.plugins.stdplugin" FILE "../info.json")

public:
    explicit Autofit(QObject* parent = nullptr);
    ~Autofit() override;

    // Verplichte ccStdPluginInterface methodes
    QList<QAction*> getActions() override { return {m_action}; }
    ContactList     getAuthors() const override { return {{"Richard Rombouts", "rf.rombouts@gmail.com"}}; }
    QString         getDescription() const override { return "Plugin voor vinden van pijpen, bochten, ..."; }
    QIcon           getIcon() const override { return m_action->icon(); } // RR!!!
    ContactList     getMaintainers() const override { return getAuthors(); }
    QString         getName() const override { return "Autofit"; }
    ReferenceList   getReferences() const override { return ReferenceList(); }
    CC_PLUGIN_TYPE  getType() const override { return CC_STD_PLUGIN; }
    bool            isCore() const override { return false; }
    void            onNewSelection(const ccHObject::Container& selectedEntities) override;
    bool            start() override { return true; }
    void            stop() override {}

private:
    QAction*                     m_action; // Behoudt actie in basisklasse voor signal/slot connecties
    ccPointCloud*                m_selectedCloud;
    std::unique_ptr<AutofitImpl> m_pimpl;
private slots:
    virtual void performFit();
};
FILE_END
FILE_BEGIN src/k_reduce_groepen.cu
#include "config.h"
#include "types.h"
#include <cub/cub.cuh>
#include <cuda_runtime.h>
#include <stdexcept>

// reduce-by-key op __device__ naar unieke (key, count) paren.
// Input: d_keys_in[N], d_counts_in[N] (vaak counts=1)
// Output: d_keys_out[M], d_counts_out[M], __host__ verkrijgt M via memcpy(d_out_count).
//
// Simpele implementatie: radix-sort ‚Üí reduceByKey (CUB).

template <typename KeyT, typename ValT>
void __device___reduce_by_key(const KeyT* d_keys_in, const ValT* d_vals_in, u32 N, KeyT*& d_keys_out, ValT*& d_vals_out,
                              u32& M)
{
    if(N == 0)
    {
        d_keys_out = nullptr;
        d_vals_out = nullptr;
        M          = 0;
        return;
    }

    KeyT* d_keys_sorted = nullptr;
    ValT* d_vals_sorted = nullptr;
    cudaMalloc(&d_keys_sorted, N * sizeof(KeyT));
    cudaMalloc(&d_vals_sorted, N * sizeof(ValT));

    // Sort input pairs (keys_in, vals_in)
    void*  d_temp     = nullptr;
    size_t temp_bytes = 0;
    cub::__device__RadixSort::SortPairs(d_temp, temp_bytes, d_keys_in, d_keys_sorted, d_vals_in, d_vals_sorted, N);
    cudaMalloc(&d_temp, temp_bytes);
    cub::__device__RadixSort::SortPairs(d_temp, temp_bytes, d_keys_in, d_keys_sorted, d_vals_in, d_vals_sorted, N);
    cudaFree(d_temp);

    // Allocate output worst case = N
    KeyT* d_keys_red = nullptr;
    ValT* d_vals_red = nullptr;
    u32*  d_M        = nullptr;
    cudaMalloc(&d_keys_red, N * sizeof(KeyT));
    cudaMalloc(&d_vals_red, N * sizeof(ValT));
    cudaMalloc(&d_M, sizeof(u32));
    cudaMemset(d_M, 0, sizeof(u32));

    // ReduceByKey
    cub::__device__Reduce::ReduceByKey(d_temp, temp_bytes, d_keys_sorted, d_keys_red, d_vals_sorted, d_vals_red, d_M,
                                       cub::Equality(), cub::Sum(), N);
    cudaMalloc(&d_temp, temp_bytes);
    cub::__device__Reduce::ReduceByKey(d_temp, temp_bytes, d_keys_sorted, d_keys_red, d_vals_sorted, d_vals_red, d_M,
                                       cub::Equality(), cub::Sum(), N);
    cudaFree(d_temp);

    // Copy M to __host__
    cudaMemcpy(&M, d_M, sizeof(u32), cudaMemcpyDeviceToHost);

    // Resize output to M (optional)
    d_keys_out = d_keys_red;
    d_vals_out = d_vals_red;

    cudaFree(d_keys_sorted);
    cudaFree(d_vals_sorted);
    cudaFree(d_M);
}

extern "C" void k_reduce_groepen_launch(const u64* d_keys_in, const u32* d_counts_in, u32 N_pairs, u64*& d_unique_keys,
                                        u32*& d_unique_counts, u32& M_out)
{
    __device___reduce_by_key<u64, u32>(d_keys_in, d_counts_in, N_pairs, d_unique_keys, d_unique_counts, M_out);
}
FILE_END
FILE_BEGIN src/k_planair_regressie.cu
#include "config.h"
#include "types.h"
#include "wiskunde_utils.cuh"
#include <cuda_runtime.h>
#include <thrust/__device___vector.h>

// JBF-planar regressie: voor een candidate vlak (normaal n0) binnen puntset,
// refine naar n* door projectie op (u,v) basis, lineaire regressie op 2D,
// bereken nieuwe n* = normalize(u* √ó v*), en bereken d via trim-K methode.

// Kernel: voor eenvoud per blok √©√©n kandidaat plaatser (optioneel uitbreiden),
// nu: __host__ roept √©√©n candidate richting aan.
// Input: punten_sorted[N], kandidaat normaal n0, parameter k_trim_fraction
// Output: top RichtingPeak (richting n*, stemmen = aantal kept, vertrouwen ~ 1/(1+rms))

__global__ void k_planair_regressie_kernel(const Vec3f*** restrict** punten, u32 N, Vec3f n0, float trim_frac,
                                           Vec3f* out_n_star, u32* out_kept, float* out_rms)
{
    extern** shared** float s_buf[]; // tijdelijk geen gebruik
    // E√©n thread per kernel (__host__ scale) ‚Äî dus blockDim=1, gridDim=1

    // Stap 1: maak u,v basis uit n0
    Vec3f u, v;
    maak_orthobasis_uv_uit_n(n0, u, v);

    // Stap 2: projecteer alle punten op u,v: (u_i, v_i) in 2D
    // On‚Äê__device__ simpel accumulate
    float sum_u = 0.f, sum_v = 0.f, sum_uu = 0.f, sum_uv = 0.f, sum_vv = 0.f;
    for(u32 i = 0; i < N; ++i)
    {
        Vec3f p  = punten[i];
        float uu = dot(p, u);
        float vv = dot(p, v);
        sum_u += uu;
        sum_v += vv;
        sum_uu += uu * uu;
        sum_uv += uu * vv;
        sum_vv += vv * vv;
    }

    float mean_u = sum_u / N;
    float mean_v = sum_v / N;

    float cov_uu = sum_uu / N - mean_u * mean_u;
    float cov_uv = sum_uv / N - mean_u * mean_v;
    float cov_vv = sum_vv / N - mean_v * mean_v;

    // Eenvoudige Richting v* op basis van covariantie
    Vec3f v_star = norm(make_vec3f(cov_uv, cov_vv - cov_uu, 0.f));
    Vec3f u_star = norm(cross(v_star, n0));

    Vec3f n_star = norm(cross(u_star, v_star));

    // Stap 3: afstand d_i = dot(n_star, p_i). Bereken RMS na trim-K
    // Kopi√´er d_i in __host__‚Äêarray? Simpel: __host__ doet dit later. Hier __device__ approx:
    float sum_d2 = 0.f;
    for(u32 i = 0; i < N; ++i)
    {
        float di = dot(n_star, punten[i]);
        sum_d2 += di * di;
    }
    float rms = sqrtf(sum_d2 / (float)N);

    *out_n_star = n_star;
    *out_kept   = N;
    *out_rms    = rms;
}

extern "C" void k_planair_regressie_launch(const Vec3f* d_points_sorted, u32 N, const Vec3f& n0, u32 K_trim_frac_int,
                                           RichtingPeak& peakOut)
{
    if(N == 0)
    {
        peakOut.stemmen    = 0;
        peakOut.vertrouwen = 0.f;
        peakOut.richting   = make_vec3f(0, 0, 0);
        return;
    }

    Vec3f*    d_nstar;
    uint32_t* d_kept;
    float*    d_rms;
    cudaMalloc(&d_nstar, sizeof(Vec3f));
    cudaMalloc(&d_kept, sizeof(uint32_t));
    cudaMalloc(&d_rms, sizeof(float));

    float trim_frac = ((float)K_trim_frac_int) * 0.01f;
    k_planair_regressie_kernel<<<1, 1, 0>>>(d_points_sorted, N, n0, trim_frac, d_nstar, d_kept, d_rms);
    cudaDeviceSynchronize();

    Vec3f    h_nstar;
    uint32_t h_kept;
    float    h_rms;
    cudaMemcpy(&h_nstar, d_nstar, sizeof(Vec3f), cudaMemcpyDeviceToHost);
    cudaMemcpy(&h_kept, d_kept, sizeof(uint32_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(&h_rms, d_rms, sizeof(float), cudaMemcpyDeviceToHost);

    cudaFree(d_nstar);
    cudaFree(d_kept);
    cudaFree(d_rms);

    peakOut.richting   = h_nstar;
    peakOut.stemmen    = h_kept;
    peakOut.vertrouwen = 1.f / (1.f + h_rms); // simpele confidence
}
FILE_END
FILE_BEGIN src/h_merge_split.cu
#include "merge_split.cuh"
#include <cassert>

void h_merge_xyz_naar_vec3(const DeviceBuffer<float>& d_x, const DeviceBuffer<float>& d_y,
                           const DeviceBuffer<float>& d_z, DeviceBuffer<Vec3f>& d_pts)
{
    assert(d_x.n == d_y.n && d_y.n == d_z.n);
    const uint32_t N = (uint32_t)d_x.n;
    if(d_pts.n != N) d_pts.alloc(N);

    dim3 blk(256);
    dim3 grd((N + blk.x - 1u) / blk.x);
    k_merge_xyz_naar_vec3_kernel<<<grd, blk>>>(d_x.ptr, d_y.ptr, d_z.ptr, d_pts.ptr, N);
    cudaDeviceSynchronize();
}

void h_split_vec3_naar_xyz(const DeviceBuffer<Vec3f>& d_pts, DeviceBuffer<float>& d_x, DeviceBuffer<float>& d_y,
                           DeviceBuffer<float>& d_z)
{
    const uint32_t N = (uint32_t)d_pts.n;
    if(d_x.n != N) d_x.alloc(N);
    if(d_y.n != N) d_y.alloc(N);
    if(d_z.n != N) d_z.alloc(N);

    dim3 blk(256);
    dim3 grd((N + blk.x - 1u) / blk.x);
    k_split_vec3_naar_xyz_kernel<<<grd, blk>>>(d_pts.ptr, d_x.ptr, d_y.ptr, d_z.ptr, N);
    cudaDeviceSynchronize();
}
FILE_END
FILE_BEGIN src/h_axis_fit.cu
#include "pairs_bucket.cuh"
#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>

// small helper
static inline void cudaCheck(cudaError_t e, const char* msg)
{
    if(e != cudaSuccess)
    {
        std::cerr << "CUDA fout: " << msg << ": " << cudaGetErrorString(e) << "\n";
        std::abort();
    }
}
static inline float3 make3(float x, float y, float z) { return make_float3(x, y, z); }

void runOTNDC_pairs(const float* x, const float* y, const float* z, int N, AssenResultaat* out, const OTConfig& cfg)
{
    // Globale accumulator
    OTAsAccu* dAccu = nullptr;
    cudaCheck(cudaMalloc(&dAccu, sizeof(OTAsAccu)), "malloc dAccu");
    cudaCheck(cudaMemset(dAccu, 0, sizeof(OTAsAccu)), "memset dAccu");

    // Kernelconfig
    const int    B     = (cfg.blokGrootte > 0 ? cfg.blokGrootte : 256);
    const int    G     = (N + B - 1) / B;
    const size_t shmem = 3 * B * sizeof(float); // sx,sy,sz

    // Launch
    k_otndc_pairs<<<G, B, shmem>>>(x, y, z, N, cfg.binnenStraal2, cfg.buitenStraal2, cfg.maxDotOrtho,
                                   cfg.partnerZoekRadius, dAccu);
    cudaCheck(cudaGetLastError(), "launch k_otndc_pairs");
    cudaCheck(cudaDeviceSynchronize(), "sync k_otndc_pairs");

    // __host__ reduce
    OTAsAccu hAccu{};
    cudaCheck(cudaMemcpy(&hAccu, dAccu, sizeof(OTAsAccu), cudaMemcpyDeviceToHost), "cpy accu");
    cudaCheck(cudaFree(dAccu), "free accu");

    // Normeer richting
    float len = std::sqrt(hAccu.som.x * hAccu.som.x + hAccu.som.y * hAccu.som.y + hAccu.som.z * hAccu.som.z);
    int   dim = 0;
    if(hAccu.count >= cfg.warmupMin && len > 1e-8f)
    {
        out->v[0][0]  = hAccu.som.x / len;
        out->v[0][1]  = hAccu.som.y / len;
        out->v[0][2]  = hAccu.som.z / len;
        out->score[0] = static_cast<float>(hAccu.count);
        dim           = 1;
    }
    out->dimensie = dim;

    // (Slots 2 en 3 blijven leeg in deze fase)
    for(int i = 1; i < 3; i++)
    {
        out->v[i][0] = out->v[i][1] = out->v[i][2] = 0.f;
        out->score[i]                              = 0.f;
    }
}
FILE_END
FILE_BEGIN src/otndc_host.cu
#include "otndc.h"
#include <algorithm>
#include <cmath>
#include <cuda_runtime.h> // voor CUDA launch macros
#include <iostream>
#include <vector>

static float3 to3(float x, float y, float z) { return make_float3(x, y, z); }

// forward decl of CUDA kernel
__global__ void k_oTNDCRays(const float* x, const float* y, const float* z, int N, OTSlot* slots, int maxSlots,
                            float binnen2, float buiten2, float minHoekCos);

void runOTNDC(const float* x, const float* y, const float* z, int N, AssenResultaat* out, const OTConfig& cfg)
{
    int blocks  = (N + 255) / 256;
    int threads = 256;

    int                 S = cfg.maxSlots;
    std::vector<OTSlot> hslots(S);
    OTSlot*             dslots;
    cudaMalloc(&dslots, S * sizeof(OTSlot));
    cudaMemset(dslots, 0, S * sizeof(OTSlot));

    k_oTNDCRays<<<blocks, threads>>>(x, y, z, N, dslots, S, cfg.binnenStraal2, cfg.buitenStraal2, cfg.minHoekCos);
    cudaDeviceSynchronize();

    cudaMemcpy(hslots.data(), dslots, S * sizeof(OTSlot), cudaMemcpyDeviceToHost);
    cudaFree(dslots);

    // reduce + pick top 3
    struct V
    {
        float3 v;
        float  score;
    };
    std::vector<V> vals;
    for(int i = 0; i < S; i++)
    {
        if(hslots[i].count < cfg.warmupMin) continue;
        float3 a   = to3(hslots[i].som.x, hslots[i].som.y, hslots[i].som.z);
        float  len = sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        if(len < 1e-6) continue;
        vals.push_back({make_float3(a.x / len, a.y / len, a.z / len), (float)hslots[i].count});
    }

    // sort by score desc
    std::sort(vals.begin(), vals.end(), [](const V& A, const V& B) { return A.score > B.score; });

    int D         = std::min((int)vals.size(), 3);
    out->dimensie = D;
    for(int i = 0; i < D; i++)
    {
        out->v[i][0]  = vals[i].v.x;
        out->v[i][1]  = vals[i].v.y;
        out->v[i][2]  = vals[i].v.z;
        out->score[i] = vals[i].score;
    }
}
FILE_END
FILE_BEGIN src/h_region_queue.cu
#include "consts.cuh"
#include "types.cuh"
#include <algorithm>
#include <cstdint>
#include <vector>

// ====== Uitleg (__host__):
// - We hebben al 64-bit morton keys per punt (__device__ berekend of __host__-side).
// - Regio = d_REGION_BITS MSB's van de key.
// - We bouwen hier een 1D work-queue van regio-indexen met hun [begin,einde] rangen
//   in de gepermuteerde, op-key gesorteerde arrays (keys/points/labels).

struct RegioRange
{
    uint64_t regio;
    uint32_t begin;
    uint32_t einde;
};

void h_bouw_regio_ranges(const std::vector<uint64_t>& keys_sorted, std::vector<RegioRange>& ranges_out)
{
    ranges_out.clear();
    if(keys_sorted.empty()) return;

    const uint32_t R     = REGION_BITS;
    uint64_t       cur   = morton_prefix(keys_sorted[0], R);
    uint32_t       begin = 0;

    for(uint32_t i = 1; i < keys_sorted.size(); ++i)
    {
        uint64_t pre = morton_prefix(keys_sorted[i], R);
        if(pre != cur)
        {
            ranges_out.push_back({cur, begin, i});
            cur   = pre;
            begin = i;
        }
    }
    ranges_out.push_back({cur, begin, (uint32_t)keys_sorted.size()});

    // Optioneel: sorteer ranges op grootte desc (work-steal vriendelijk)
    std::sort(ranges_out.begin(), ranges_out.end(),
              [](const RegioRange& A, const RegioRange& B) { return (A.einde - A.begin) > (B.einde - B.begin); });
}
FILE_END
FILE_BEGIN src/k_merge_split.cu
#include "types.cuh"

// ====== Kernels ======

__global__ void k_merge_xyz_naar_vec3_kernel(const float*** restrict** x, const float*** restrict** y,
                                             const float*** restrict** z, Vec3f*** restrict** pts, uint32_t N)
{
    const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    pts[i] = Vec3f{x[i], y[i], z[i]};
}

__global__ void k_split_vec3_naar_xyz_kernel(const Vec3f*** restrict** pts, float*** restrict** x,
                                             float*** restrict** y, float*** restrict** z, uint32_t N)
{
    const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    Vec3f p = pts[i];
    x[i]    = p.x;
    y[i]    = p.y;
    z[i]    = p.z;
}
FILE_END
FILE_BEGIN src/k_voxeliseer_morton.cu
#include <cub/cub.cuh>
#include <cuda_runtime.h>

#include "morton_utils.cuh"
#include "types.cuh"

__global__ void k_kwantiseer_en_key(const Vec3f* __restrict__ punten, uint32_t N, Kwantisatie Q, uint32_t regioCode,
                                    uint64_t* __restrict__ keys_out)
{
    uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;

    uint32_t xi, yi, zi;
    kwantiseer_punt(punten[i], Q, xi, yi, zi);

    uint64_t key = morton_met_regio(xi, yi, zi, regioCode);
    keys_out[i]  = key;
}

__global__ void k_init_indices(u32* __restrict__ idx, u32 N)
{
    u32 i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    idx[i] = i;
}

__global__ void k_permuteer_punten(const Vec3f* __restrict__ punten_in, const u32* __restrict__ index_perm, u32 N,
                                   Vec3f* __restrict__ punten_out)
{
    u32 i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;

    u32 src       = index_perm[i];
    punten_out[i] = punten_in[src];
}

// Host wrapper:

void voxeliseer_morton(const Vec3f* d_points, u32 N, Kwantisatie Q, Vec3f* d_points_perm)
{
    // alloc keys
    u64* d_keys;
    cudaMalloc(&d_keys, N * sizeof(u64));

    u32* d_index_perm;
    cudaMalloc(&d_index_perm, N * sizeof(u32));

    dim3 bs(256);
    dim3 gs((N + bs.x - 1) / bs.x);

    k_kwantiseer_en_key<<<gs, bs>>>(d_points, N, Q, d_keys);
    k_init_indices<<<gs, bs>>>(d_index_perm, N);

    // Radix sort
    size_t temp_bytes = 0;
    void*  d_temp     = nullptr;
    cub::DeviceRadixSort::SortPairs(nullptr, temp_bytes, d_keys, d_keys, d_index_perm, d_index_perm, N);
    cudaMalloc(&d_temp, temp_bytes);
    cub::DeviceRadixSort::SortPairs(d_temp, temp_bytes, d_keys, d_keys, d_index_perm, d_index_perm, N);

    k_permuteer_punten<<<gs, bs>>>(d_points, d_index_perm, N, d_points_perm);

    cudaFree(d_keys);
    cudaFree(d_index_perm);
    cudaFree(d_temp);
}
FILE_END
FILE_BEGIN src/h_do_optimize_frame3.cpp
#include <iostream>
#include <vector>
#include <cstdint>
#include <memory>

#include "cc_adapter.h"            // CCVector3, CCPointCloud*
#include "__device___buffer.cuh"       // DeviceBuffer<T>
#include "types.h"                 // Vec3f, u32
#include "axis_permutatie.h"       // AxisPermutatie
#include "orchestratie.h"          // NL orchestratie-functies
#include "consts.cuh"              // thresholds/__constant__en
#include "merge_split.cuh"         // h_merge_xyz_naar_vec3 / h_split_vec3_naar_xyz

// Kernels/__host__-stappen (geleverde modules)
extern void h_voxeliseer_morton(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts,
/*io*/Bocari::DeviceBuffer<u64>& d_keys,
/*io*/Bocari::DeviceBuffer<u32>& d_index,
/*out*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted);

extern void h_ruis_boeren(/*io*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels);

extern void h_vlak_vote_current_frame(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels,
/*out*/Bocari::KandidaatAssen& uit);

extern void h_vlak_vote_bruteforce(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels,
/*out*/Bocari::KandidaatAssen& uit);

// NB: buis_vote happy path pas inzetten als nodig
extern void h_buis_vote_bruteforce(/*in*/const Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels,
/*out*/Bocari::KandidaatAssen& uit);

extern void h_rotatie_quat_apply(/*io*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*in*/const Bocari::Quat& q);

extern void h_fine_slabs_cyl_label(/*io*/Bocari::DeviceBuffer<Bocari::Vec3f>& d_pts_sorted,
/*io*/Bocari::DeviceBuffer<u8>& d_labels);

// ============= HOOFDFLOW =============

void AutofitImpl::doOptimizeFrame3()
{
using namespace Bocari;


if (!m_selectedCloud || m_selectedCloud->size() == 0)
{
    std::cout << "[Autofit] Geen point cloud of leeg.\n";
    return;
}

// 1) __host__: lees CC-punten en bepaal as-verdeling (Vx/Vy/Vz) + permutatie
CCVector3 bbMin, bbMax;
m_selectedCloud->getBoundingBox(bbMin, bbMax);

const size_t N = m_selectedCloud->size();
std::vector<float> h_x(N), h_y(N), h_z(N);

for (size_t i=0; i<N; ++i)
{
    const CCVector3* p = m_selectedCloud->getPoint(i);
    if (!p) continue;
    h_x[i] = p->x;
    h_y[i] = p->y;
    h_z[i] = p->z;
}

// Bepaal Vx,Vy,Vz (bijv via morton-driven voxelisatie ontwerp; hier simpele placeholder:
// neem verhouding van BB-lengtes t.o.v. target gridgrootte)
const float Lx = bbMax.x - bbMin.x;
const float Ly = bbMax.y - bbMin.y;
const float Lz = bbMax.z - bbMin.z;

// Ruime schatting: grotere lengte ‚Üí grotere V
u32 Vx = std::max(1u, (u32)(Lx > 0 ? 1024.f * (Lx / std::max({Lx,Ly,Lz})) : 1));
u32 Vy = std::max(1u, (u32)(Ly > 0 ? 1024.f * (Ly / std::max({Lx,Ly,Lz})) : 1));
u32 Vz = std::max(1u, (u32)(Lz > 0 ? 1024.f * (Lz / std::max({Lx,Ly,Lz})) : 1));

Bocari::AsInfo ax{ 'x', h_x.data(), Vx };
Bocari::AsInfo ay{ 'y', h_y.data(), Vy };
Bocari::AsInfo az{ 'z', h_z.data(), Vz };

AxisPermutatie perm = maak_axis_permutatie(ax, ay, az);
toon_axis_mapping(perm);

// 2) Upload nieuwe x/y/z volgens permutatie
DeviceBuffer<float> d_x(N), d_y(N), d_z(N);
d_x.upload(perm.nieuwX.data, N);
d_y.upload(perm.nieuwY.data, N);
d_z.upload(perm.nieuwZ.data, N);

// 3) Merge naar vec3f (__device__) ‚Üí d_pts
DeviceBuffer<Vec3f> d_pts(N);
h_merge_xyz_naar_vec3(d_x, d_y, d_z, d_pts);

std::cout << "[Autofit] Merge x/y/z ‚Üí vec3f gedaan. Start pipeline‚Ä¶\n";

// 4) Morton-driven sort + boeren ruisfilter
DeviceBuffer<u64> d_keys(N);
DeviceBuffer<u32> d_index(N);
DeviceBuffer<Vec3f> d_pts_sorted(N);
DeviceBuffer<u8>  d_labels(N); d_labels.memset(0);

h_voxeliseer_morton(d_pts, d_keys, d_index, d_pts_sorted);
h_ruis_boeren(d_pts_sorted, d_labels);

// 5) Probeer huidig frame (3 richtingen) ‚Üí vlakken
KandidaatAssen assen{};
h_vlak_vote_current_frame(d_pts_sorted, d_labels, assen);

if (!assen.heeftMinstensEenAs())
{
    std::cout << "[Autofit] Geen vlak in huidig frame. Brute planes‚Ä¶\n";
    h_vlak_vote_bruteforce(d_pts_sorted, d_labels, assen);
}

if (!assen.heeftMinstensEenAs())
{
    std::cout << "[Autofit] Geen vlak gevonden. Brute buizen (annulus/wedge)‚Ä¶\n";
    h_buis_vote_bruteforce(d_pts_sorted, d_labels, assen);
}

if (!assen.heeftMinstensEenAs())
{
    std::cout << "[Autofit] Geen eerste as te vinden (vlakken/buizen). Stop.\n";
    return;
}

// 6) Orthonormaliseer 2e/3e as (JBF ‚Üí Gram‚ÄìSchmidt), maak quaternion
Quat q = maak_quat_naar_ideaal_frame(assen); // in orchestratie.h/.cpp

std::cout << "[Autofit] Roteer naar ideaal frame (quaternion)‚Ä¶\n";
h_rotatie_quat_apply(d_pts_sorted, q);

// 7) Fine slabs + (simpele) radiale buislabeling in ideaal frame
h_fine_slabs_cyl_label(d_pts_sorted, d_labels);

// 8) Split terug: vec3f ‚Üí x/y/z
h_split_vec3_naar_xyz(d_pts_sorted, d_x, d_y, d_z);

// 9) Download en TERUG-PERMUTEER naar oorspronkelijke as-namen
std::vector<float> rx(N), ry(N), rz(N);
d_x.download(rx.data(), N);
d_y.download(ry.data(), N);
d_z.download(rz.data(), N);

// Terug-mapping: we hebben invNaam: orig 'x'‚Üí'?' (x/y/z)
auto zetTerug = [&](char orig, const std::vector<float>& nx,
                    const std::vector<float>& ny,
                    const std::vector<float>& nz, float& out)
{
    char nieuwe = perm.invNaam[(unsigned char)orig];
    if (nieuwe == 'x') out = nx[&out - &out]; // niet bruikbaar zo; we schrijven rechtstreeks per punt
};

// Simpeler: schrijf direct de juiste component per punt
for (size_t i=0; i<N; ++i)
{
    float X = rx[i], Y = ry[i], Z = rz[i];
    // welke originele as kwam op nieuwX?
    // perm.nieuwX.naam == 'y' betekent: oude 'y' staat nu in X
    float out_x=0, out_y=0, out_z=0;
    // inv map: welke nieuwe letter hoort bij orig?
    // We bepalen per nieuwe component naar welke originele naam die hoort:
    // nieuwX kwam van naamA ‚Üí schrijf X terug naar die orig naamA
    auto schrijf = [&](char kwamVan, float waarde) {
        if (kwamVan=='x') out_x = waarde;
        else if (kwamVan=='y') out_y = waarde;
        else if (kwamVan=='z') out_z = waarde;
    };
    schrijf(perm.nieuwX.naam, X);
    schrijf(perm.nieuwY.naam, Y);
    schrijf(perm.nieuwZ.naam, Z);

    // Update terug in CC cloud (alleen pos; labels kun je separaat ophalen)
    CCVector3* p = m_selectedCloud->getPointMutable(i);
    if (p) { p->x = out_x; p->y = out_y; p->z = out_z; }
}

std::cout << "[Autofit] Klaar: punten teruggezet in originele as-namen.\n";


}
FILE_END
FILE_BEGIN src/axis.cpp

FILE_END
FILE_BEGIN src/ds
ccPointCloud* ccCloud = new ccPointCloud("VoxelCheckerboard");
if(!ccCloud)
{
    std::cout << "Error: Failed to create rotated sampled cloud" << std::endl;
    return;
}
if(!ccCloud->reserve(U32(voxelManager.groupedPoints.size())))
{
    delete ccCloud;
    return;
}

// Stap 1: Voeg ALLE punten eerst toe aan de cloud
std::cout << "Adding points to cloud..." << std::endl;
for(u32 v = 0; v < Bin; ++v)
{
    for(u32 i = 0; i < voxelManager.m_voxelCounts[v]; ++i)
    {
        u32           j = voxelManager.m_voxelStarts[v] + i;
        Pointcloud::Point& p = voxelManager.groupedPoints[j];
        CCVector3          ccPoint{p.m_point.x, p.m_point.y, p.m_point.z};
        ccCloud->addPoint(ccPoint);
    }
}
std::cout << "Cloud size: " << ccCloud->size() << std::endl;

// Stap 2: Nu pas de scalar field maken en toevoegen
std::cout << "Creating scalar field..." << std::endl;
ccScalarField* sf = new ccScalarField("ColoredPoints");

// BELANGRIJK: Reserveer de exacte grootte
if(!sf->reserve(ccCloud->size()))
{
    std::cout << "Failed to reserve scalar field!" << std::endl;
    sf->release();
    delete ccCloud;
    return;
}

// Stap 3: Vul de scalar field
auto odd = [](u32 x) -> bool { return (x & 1) != 0; };

u32 pointIndex = 0;
for(u32 v = 0; v < Bin; ++v)
{
    u32 x, y, z;
    Bocari::Voxelprocessing::unflatten3<c_voxel>(v, z, y, x);
    bool odds = odd(x) ^ odd(y) ^ odd(z);

    for(u32 i = 0; i < voxelManager.m_voxelCounts[v]; ++i)
    {
        float value = odds ? 1.0f : 0.0f;
        sf->addElement(value);  // Gebruik addElement in plaats van setValue!
        
        if (pointIndex < 10) {
            std::cout << "Added SF[" << pointIndex << "] = " << value << std::endl;
        }
        
        pointIndex++;
    }
}

std::cout << "SF final size: " << sf->size() << std::endl;

// Stap 4: Voeg scalar field toe aan cloud
int sfIndex = ccCloud->addScalarField(sf);
std::cout << "Scalar field index: " << sfIndex << std::endl;

if (sfIndex < 0) {
    std::cout << "Failed to add scalar field to cloud!" << std::endl;
    sf->release();
    delete ccCloud;
    return;
}

// Stap 5: Compute min/max
sf->computeMinAndMax();
std::cout << "Scalar field range: " << sf->getMin() << " to " << sf->getMax() << std::endl;

// Stap 6: Configureer display
ccCloud->setCurrentScalarField(sfIndex);
ccCloud->setCurrentDisplayedScalarField(sfIndex);
ccCloud->showSF(true);
ccCloud->setPointSize(2.0f);

ccScalarField* currentSF = static_cast<ccScalarField*>(ccCloud->getScalarField(sfIndex));
if (currentSF)
{
    currentSF->setMinDisplayed(0.0f);
    currentSF->setMaxDisplayed(1.0f);
    currentSF->setSaturationStart(0.0f);
    currentSF->setSaturationStop(1.0f);
    
    ccColorScale::Shared colorScale = ccColorScale::Create("Checkerboard");
    if (colorScale)
    {
        colorScale->insert(ccColorScaleElement(0.0, Qt::red), false);
        colorScale->insert(ccColorScaleElement(1.0, Qt::blue), false);
        colorScale->update();
        currentSF->setColorScale(colorScale);
        std::cout << "Color scale configured" << std::endl;
    }
}

ccCloud->showSFColorsScale(true);
ccCloud->prepareDisplayForRefresh();

// Voeg toe aan CC
ccHObject* parent = m_selectedCloud->getParent();
if(parent)
{
    parent->addChild(ccCloud);
}

m_app->addToDB(ccCloud);
m_app->setSelectedInDB(ccCloud, true);
m_app->refreshAll();

std::cout << "Voxel checkerboard cloud created successfully!" << std::endl;
FILE_END
FILE_BEGIN src/autofit.cpp
#include "autofit.h"
#include "autofit_impl.h"
#include "includes.h"
#include "strict.h"

#include "voxelprocessor.h"
// using CCCoreLib::DegreesToRadians;

Autofit::Autofit(QObject* parent)
    : QObject(parent), m_action(nullptr), m_selectedCloud(nullptr), m_pimpl(new AutofitImpl)
{
    if(!m_action)
    {
        m_action = new QAction("Perform autofit", this);
        m_action->setIcon(QIcon(":/icons/bochtje50.png"));
        connect(m_action, &QAction::triggered, this, &Autofit::performFit);
    }
    m_action->setEnabled(false);
}

Autofit::~Autofit() = default;

void Autofit::onNewSelection(const ccHObject::Container& selectedEntities)
{
    bool enabled = selectedEntities.size() == 1 && selectedEntities[0]->isA(CC_TYPES::POINT_CLOUD);
    m_action->setEnabled(enabled);
    m_selectedCloud = enabled ? static_cast<ccPointCloud*>(selectedEntities[0]) : nullptr;
}

void Autofit::performFit()
{
    if(m_pimpl && m_selectedCloud != nullptr) m_pimpl->performFit(m_app, m_selectedCloud);
}
FILE_END
FILE_BEGIN src/autofit_impl.cpp
#include "autofit_impl.h"
#include "assen_hernoemen.h"
#include "axis.h"
#include "includes.h"
#include "voxelprocessor.h"

using namespace CCCoreLib;
using namespace Bocari::Voxelprocessing;
// using CCCoreLib::DegreesToRadians;

AutofitImpl::AutofitImpl() {}

void AutofitImpl::performFit(ccMainAppInterface* app, ccPointCloud* selectedCloud)
{
    m_app           = app;
    m_selectedCloud = selectedCloud;
    //[[maybe_unused]] auto res = doOptimizeFrame1();
    doOptimizeFrame1();
}

void AutofitImpl::doOptimizeFrame1()
{
    using namespace std::chrono;
    using namespace Bocari;
    if(!m_selectedCloud || m_selectedCloud->size() == 0)
    {
        std::cout << "Geen point cloud of lege cloud" << std::endl;
        return;
    }

    /*
    const unsigned int THRESHOLD_COUNT = 100000;
    dbg("Applying voxel subsampling");
    std::unique_ptr<ccPointCloud> voxelSubsampledCloud = AutofitImpl::voxelSubsample(m_selectedCloud, THRESHOLD_COUNT);

    if(voxelSubsampledCloud)
    {
        m_selectedCloud = voxelSubsampledCloud.get();
    } else
    {
        return;
    }uint32
    */

    // Start timing
    auto startTime = high_resolution_clock::now();

    VoxelManager voxelManager;

    // Stap 1: Verwerk de complete cloud naar voxels
    std::cout << "Verwerken van " << m_selectedCloud->size() << " punten..." << std::endl;
    voxelManager.voxelize(m_selectedCloud);

    // Eind timing voor voxelization
    auto endTime          = high_resolution_clock::now();
    auto voxelizeDuration = duration_cast<milliseconds>(endTime - startTime);

    // Convert naar minuten, seconden, milliseconden
    // Correcte en duidelijke manier om de resterende tijd te berekenen
    auto mins = duration_cast<minutes>(voxelizeDuration);
    auto secs = duration_cast<seconds>(voxelizeDuration - mins);
    auto ms   = duration_cast<milliseconds>(voxelizeDuration - mins - secs);

    std::cout << "Voxelization tijd: " << mins.count() << " min, " << secs.count() << " sec, " << ms.count() << " ms"
              << std::endl;

    // Stap 2: Selecteer specifieke voxel (z, y, x volgorde!)
    const uint8_t         targetZ = 1, targetY = 2, targetX = 3;
    Voxel                 voxel;
    GridUnion<c_subvoxel> subVoxelStarts;
    voxelManager.getVoxel(targetZ, targetY, targetX, voxel, subVoxelStarts);

    if(voxel.count() == 0)
    {
        std::cout << "Voxel (" << static_cast<int>(targetZ) << "," << static_cast<int>(targetY) << ","
                  << static_cast<int>(targetX) << ") bevat geen punten" << std::endl;
        // return;
    }

    voxelManager.buildVoxelCumSum();

    auto constexpr mask = maskFor(c_voxel);
    // Example: count points in (0,0,0)-(x,y,z)
    u32 magic = voxelManager.m_voxelCumSum(mask, mask, mask);

    std::cout << "Voxel (" << targetZ << "," << targetY << "," << targetX << ") bevat " << magic << " punten"
              << std::endl;

    assert(magic == voxelManager.groupedPoints.size());

    // Converteer naar ccPointCloud
    // RR!!! Hier
    bool b = false;
    for(u32 i = 0; i < U32(voxelManager.groupedPoints.size()); ++i)
    {
        GridUnion<c_subvoxel> subvoxelStarts;
        Voxel                 v;
        voxelManager.getVoxelById(i, v, subvoxelStarts);
        b |= v.detectPlane();
    }

    std::cout << b;

    return;

    ccPointCloud* ccCloud = new ccPointCloud();
    if(!ccCloud)
    {
        std::cout << "Error: Failed to create rotated sampled cloud" << std::endl;
        return;
    }

    if(!ccCloud->reserve(U32(voxelManager.groupedPoints.size())))
    {
        delete ccCloud;
        return;
    }

    // Stap 1: Voeg scalar field toe
    std::cout << "Adding points to cloud..." << std::endl;
    constexpr u32 Bin = Math::pow3(c_voxel);
    // Voeg eerst alle punten toe
    for(u32 v = 0; v < Bin; ++v)
    {
        for(u32 i = 0; i < voxelManager.m_voxelCounts[v]; ++i)
        {
            u32                j = voxelManager.m_voxelStarts[v] + i;
            Pointcloud::Point& p = voxelManager.groupedPoints[j];
            CCVector3          ccPoint{p.m_point.x, p.m_point.y, p.m_point.z};
            ccCloud->addPoint(ccPoint);
        }
    }

    std::cout << "Cloud size: " << ccCloud->size() << std::endl;

    // Stap 2: Nu pas de scalar field maken en toevoegen
    std::cout << "Creating scalar field..." << std::endl;
    ccScalarField* sf = new ccScalarField("ColoredPoints");

    // BELANGRIJK: Reserveer de exacte grootte
    sf->reserve(ccCloud->size());

    // Stap 3: Vul de scalar field
    auto odd = [](u32 x) -> bool { return (x & 1) != 0; };

    u32 pointIndex = 0;
    for(u32 v = 0; v < Bin; ++v)
    {
        if(!voxelManager.isMediumDensityVoxel(v)) continue;
        u32 x, y, z;
        Bocari::Voxelprocessing::unflatten3<c_voxel>(v, z, y, x);

        bool odds = odd(x) ^ odd(y) ^ odd(z);

        for(u32 i = 0; i < voxelManager.m_voxelCounts[v]; ++i)
        {
            float value = odds ? 1.0f : 0.0f;
            sf->addElement(value); // Gebruik addElement in plaats van setValue!

            if(pointIndex < 10)
            {
                std::cout << "Added SF[" << pointIndex << "] = " << value << std::endl;
            }

            pointIndex++;
        }
    }

    std::cout << "SF final size: " << sf->size() << std::endl;

    // Stap 4: Voeg scalar field toe aan cloud
    int sfIndex = ccCloud->addScalarField(sf);
    std::cout << "Scalar field index: " << sfIndex << std::endl;

    if(sfIndex < 0)
    {
        std::cout << "Failed to add scalar field to cloud!" << std::endl;
        sf->release();
        delete ccCloud;
        return;
    }

    // Stap 5: Compute min/max
    sf->computeMinAndMax();
    std::cout << "Scalar field range: " << sf->getMin() << " to " << sf->getMax() << std::endl;

    // Stap 6: Configureer display
    ccCloud->setCurrentScalarField(sfIndex);
    ccCloud->setCurrentDisplayedScalarField(sfIndex);
    ccCloud->showSF(true);
    ccCloud->setPointSize(2.0f);

    ccScalarField* currentSF = static_cast<ccScalarField*>(ccCloud->getScalarField(sfIndex));
    if(currentSF)
    {
        currentSF->setMinDisplayed(0.0f);
        currentSF->setMaxDisplayed(1.0f);
        currentSF->setSaturationStart(0.0f);
        currentSF->setSaturationStop(1.0f);

        ccColorScale::Shared colorScale = ccColorScale::Create("Checkerboard");
        if(colorScale)
        {
            colorScale->insert(ccColorScaleElement(0.0, Qt::red), false);
            colorScale->insert(ccColorScaleElement(1.0, Qt::blue), false);
            colorScale->update();
            currentSF->setColorScale(colorScale);
            std::cout << "Color scale configured" << std::endl;
        }
    }

    ccCloud->showSFColorsScale(true);
    ccCloud->prepareDisplayForRefresh();

    // Voeg toe aan CC
    ccHObject* parent = m_selectedCloud->getParent();
    if(parent)
    {
        parent->addChild(ccCloud);
    }

    m_app->addToDB(ccCloud);
    m_app->setSelectedInDB(ccCloud, true);
    m_app->refreshAll();

    std::cout << "Voxel checkerboard cloud created successfully!" << std::endl;
}

void AutofitImpl::doOptimizeFrame2()
{
    if(!m_selectedCloud || m_selectedCloud->size() == 0)
    {
        std::cout << "Geen point cloud of lege cloud\n";
        return;
    }

    CCVector3 bbMin, bbMax;
    m_selectedCloud->getBoundingBox(bbMin, bbMax);

    // Bepaal Sx, Sy, Sz op basis van jouw "vierkant-houden" + regio‚Äôs.
    // (Hier placeholder; hang dit aan jouw regioneringslogica.)
    uint32_t Sx = /*...*/ 64;
    uint32_t Sy = /*...*/ 64;
    uint32_t Sz = /*...*/ 32;

    // Maak accessor-lijst met huidige asvolgorde
    std::array<Toegang, 3> ax = {{{'x', [](auto* p) { return p->x; }, Sx},
                                  {'y', [](auto* p) { return p->y; }, Sy},
                                  {'z', [](auto* p) { return p->z; }, Sz}}};

    // Forceer Sx ‚â• Sy ‚â• Sz en onthoud welke as waarheen verhuisde
    orden_axes_op_S(ax); // ax[0] ‚Üí newX, ax[1] ‚Üí newY, ax[2] ‚Üí newZ

    // Bouw __host__-buffers (SoA + labels)
    const size_t        N = m_selectedCloud->size();
    std::vector<float3> punten;
    punten.reserve(N);

    // vertaal/scale ‚Üí hier enkel copy, echte translatie/scale kan op GPU in init-kernel
    for(size_t i = 0; i < N; ++i)
    {
        const CCVector3* pt = m_selectedCloud->getPoint(static_cast<unsigned>(i));
        if(!pt) continue;
        float X = ax[0].get(pt);
        float Y = ax[1].get(pt);
        float Z = ax[2].get(pt);
        punten.push_back(make_float3(X, Y, Z));
    }

    // Labels initialiseren
    enum Label : uint32_t { LABEL_GEEN = 0, LABEL_RUIS = 1, LABEL_VLAK = 2, LABEL_BUIS = 3 };
    std::vector<uint32_t> labels(punten.size(), LABEL_GEEN);

    // __device__ allocs/kopie
    float3*   d_punten = nullptr;
    uint32_t* d_labels = nullptr;
    cudaMalloc((void**)&d_punten, punten.size() * sizeof(float3));
    cudaMalloc((void**)&d_labels, punten.size() * sizeof(uint32_t));
    cudaMemcpy(d_punten, punten.data(), punten.size() * sizeof(float3), cudaMemcpyHostToDevice);
    cudaMemcpy(d_labels, labels.data(), labels.size() * sizeof(uint32_t), cudaMemcpyHostToDevice);

    // Daarna: roep jouw GPU-pipeline (ruisfilter ‚Üí vlak-quickcheck ‚Üí wedge) aan.
    // (Zie aanroep-skel onderaan.)
}

// Helper to convert ReferenceCloud (from CloudSamplingTools) to
// unique_ptr<ccPointCloud>
std::unique_ptr<ccPointCloud> convertReferenceCloudToCCPointCloud(ReferenceCloud* refCloud)
{
    if(!refCloud || refCloud->size() == 0) return nullptr;

    auto cloud = std::make_unique<ccPointCloud>();

    if(!cloud->reserve(refCloud->size())) return nullptr;

    for(unsigned i = 0; i < refCloud->size(); ++i)
    {
        const CCVector3* point = refCloud->getPoint(i);
        cloud->addPoint(*point);
    }

    cloud->setName("ConvertedCloud");
    delete refCloud; // ReferenceCloud is dynamically allocated by CloudCompare
                     // tools and needs to be deleted
    return cloud;
}

std::unique_ptr<ccPointCloud> AutofitImpl::voxelSubsample(ccPointCloud* inputCloud, int32_t pointCount)
{
    if(!inputCloud) return nullptr;

    auto subsampledCloud = CCCoreLib::CloudSamplingTools::subsampleCloudWithOctree(
        inputCloud, pointCount, CCCoreLib::CloudSamplingTools::SUBSAMPLING_CELL_METHOD::RANDOM_POINT, nullptr, nullptr);

    return convertReferenceCloudToCCPointCloud(subsampledCloud);
}

std::unique_ptr<ccPointCloud> AutofitImpl::spatialSubsample(ccPointCloud* inputCloud, PointCoordinateType minDistance)
{
    if(!inputCloud) return nullptr;

    CloudSamplingTools::SFModulationParams modParams;
    auto subsampledCloud = CloudSamplingTools::resampleCloudSpatially(inputCloud, minDistance, modParams);

    return convertReferenceCloudToCCPointCloud(subsampledCloud);
}
FILE_END
FILE_BEGIN src/point.cpp
#include "point.h"
namespace Bocari
{
    namespace Math
    {
        // Roteer een Pointcloud::Point (in-place versie)
        template <typename T> void Quaternion<T>::rotateInPlace(Pointcloud::Point& p) const
        {
            // Gebruik double precisie voor berekeningen, zelfs als punt float gebruikt
            Quaternion<T> p_quat(static_cast<T>(0), static_cast<T>(p.m_point.x), static_cast<T>(p.m_point.y),
                                 static_cast<T>(p.m_point.z));
            Quaternion<T> q_inv     = this->inverse();
            Quaternion<T> rotated_p = (*this) * p_quat * q_inv;

            // Converteer terug naar float
            p.m_point.x = static_cast<float>(rotated_p.x);
            p.m_point.y = static_cast<float>(rotated_p.y);
            p.m_point.z = static_cast<float>(rotated_p.z);
        }

        // Roteer een span van Points in-place
        template <typename T> void Quaternion<T>::rotateSpanInPlace(std::span<Pointcloud::Point> points) const
        {
            for(auto& p : points)
            {
                rotateInPlace(p);
            }
        }
    } // namespace Math

    namespace Pointcloud
    {
        // Converteer een span van onze Points naar een ccPointCloud
        ccPointCloud* to_ccPointCloud(std::span<const Pointcloud::Point> points)
        {
            if(points.empty()) return nullptr;

            ccPointCloud* result = new ccPointCloud();
            if(!result->reserve(U32(points.size())))
            {
                delete result;
                return nullptr;
            }

            // Voeg alle punten toe √©√©n voor √©√©n
            for(const auto& p : points)
            {
                CCVector3 ccPoint{p.m_point.x, p.m_point.y, p.m_point.z};
                result->addPoint(ccPoint);
            }

            return result;
        }

        // Converteer een ccPointCloud naar een vector van onze Points
        std::vector<Pointcloud::Point> from_ccPointCloud(const ccPointCloud* cloud, u32 step = 1)
        {
            std::vector<Pointcloud::Point> result;

            if(!cloud || cloud->size() == 0)
            {
                return result;
            }

            result.reserve(cloud->size());

            for(u32 i = 0; i < cloud->size(); i += step)
            {
                const CCVector3* p = cloud->getPoint(i);
                result.emplace_back(i32(i), Math::Vec3f{p->x, p->y, p->z});
            }

            return result;
        }

        // Helper: roteer een ccPointCloud met een quaternion
        ccPointCloud* createRotatedPointCloud(const Math::Quaternion<double>& quat, const ccPointCloud* original)
        {
            if(!original || original->size() == 0) return nullptr;

            // Converteer naar onze Points
            auto ourPoints = from_ccPointCloud(original);

            // Roteer de punten in-place
            quat.rotateSpanInPlace(std::span<Pointcloud::Point>(ourPoints));

            // Converteer terug naar ccPointCloud
            return to_ccPointCloud(std::span<const Pointcloud::Point>(ourPoints));
        }

    } // namespace Pointcloud
} // namespace Bocari
FILE_END
FILE_BEGIN src/k_label_sort.cu
#include "types.cuh"
#include <thrust/__device___ptr.h>
#include <thrust/iterator/zip_iterator.h>
#include <thrust/sort.h>
#include <thrust/tuple.h>

/**

* Sorteer labels op (type, clusterId, mortonKey) stabiel om spatial locality te bewaren.
* Aanname: d_morton bestaat (uint64_t*) parallel aan punten.
  */

extern "C" void sort_labels_by_type_cluster_morton(uint8_t* d_type, uint32_t* d_cluster, uint64_t* d_morton, int N,
                                                   cudaStream_t stream)
{
    using thrust::__device___ptr;
    using thrust::make_tuple;
    using thrust::make_zip_iterator;

    auto t0 = __device___ptr & lt;
    uint8_t & gt;
    (d_type);
    auto t1 = __device___ptr & lt;
    uint32_t & gt;
    (d_cluster);
    auto t2 = __device___ptr & lt;
    uint64_t & gt;
    (d_morton);

    auto zip_begin = make_zip_iterator(make_tuple(t0, t1, t2));
    auto zip_end   = zip_begin + N;

    thrust::stable_sort(thrust::cuda::par.on(stream), zip_begin, zip_end,
                        [] __device__(const thrust::tuple& lt; uint8_t, uint32_t, uint64_t& gt;
                                      &a, const thrust::tuple& lt; uint8_t, uint32_t, uint64_t& gt; &b) {
                            if(thrust::get& lt; 0 & gt; (a) < thrust::get & lt; 0 & gt; (b)) return true;
                            if(thrust::get& lt; 0 & gt; (a) > thrust::get & lt; 0 & gt; (b)) return false;
                            if(thrust::get& lt; 1 & gt; (a) < thrust::get & lt; 1 & gt; (b)) return true;
                            if(thrust::get& lt; 1 & gt; (a) > thrust::get & lt; 1 & gt; (b)) return false;
                            return thrust::get & lt;
                            2 & gt;
                            (a) & lt;
                            thrust::get& lt;
                            2 & gt;
                            (b);
                        });
}
FILE_END
FILE_BEGIN src/grid_utils.cpp
#include "voxelprocessor.h"

namespace Bocari
{
    namespace Voxelprocessing
    {
        // Explicit instantiations
        template void buildStartIndices<c_voxel>(const std::span<u32>, Voxelprocessing::GridUnion<c_voxel>&, u32);
        template void buildCumSum<c_voxel>(const Voxelprocessing::GridUnion<c_voxel>&,
                                           Voxelprocessing::GridUnion<c_voxel>&);
        template u32  countPointsInBox<c_voxel>(const Voxelprocessing::GridUnion<c_voxel>&, u32, u32, u32, u32, u32,
                                                u32);

#if c_voxel != c_subvoxel
        template void buildStartIndices<c_subvoxel>(const std::span<u32>, Voxelprocessing::GridUnion<c_voxel>&, u32);
        template void buildCumSum<c_subvoxel>(const Voxelprocessing::GridUnion<c_subvoxel>&,
                                              Voxelprocessing::GridUnion<c_subvoxel>&);
        template u32  countPointsInBox<c_subvoxel>(const Voxelprocessing::GridUnion<c_voxel>&, u32, u32, u32, u32, u32,
                                                   u32);
#endif
    } // namespace Voxelprocessing
} // namespace Bocari
FILE_END
FILE_BEGIN src/k_direction_vote_bdrm.cu
#include "bdrm_lru.cuh"
#include "consts.cuh"
#include "types.cuh"
#include <cooperative_groups.h>
#include <cuda_runtime.h>

namespace cg = cooperative_groups;

/*
k_direction_vote_bdrm
---------------------

Boeren-richtingstralenmethode:
- Neem normale n van mini-triangle (of fallback), translatie naar O is impliciet (we gebruiken alleen richting).
- LRU per block; stem op n.
- In warmup: maak max 2 cross-products met top-slots die bijna orthogonaal zijn; voeg toe als nieuw.
- Bij stem: als LRU al vector ~orthogonaal heeft, bump ook die.

ASCII:
O  ‚Üê alle stralen (normals) worden gezien als pijlen vanuit O.
We clusteren VLAKRICHTINGEN en leiden asrichtingen af via kruisproducten.
*/

__device__ inline float  dot3f(const float3 a, const float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__device__ inline float3 cross3f(const float3 a, const float3 b)
{
    return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
__device__ inline float  len3f(const float3 v) { return sqrtf(dot3f(v, v)); }
__device__ inline float3 norm3f(const float3 v)
{
    float L = len3f(v);
    return (L > 0) ? make_float3(v.x / L, v.y / L, v.z / L) : make_float3(0, 0, 0);
}

template <int K>
__global__ void k_direction_vote_bdrm(const float3*** restrict** d_norm_tri, const uint8_t*** restrict** d_ok_for_vote,
                                      int                  N,
                                      float3*** restrict** d_block_winners, // per block: top 3
                                      int                  maxWinnersPerBlock)
{
    extern** shared** unsigned char shmem[];
    auto*                           lru = reinterpret_cast<LruBlock<K>*>(shmem);
    if(threadIdx.x == 0) lru->init();
    __syncthreads();

    const int gid  = blockIdx.x * blockDim.x + threadIdx.x;
    const int lane = threadIdx.x;

    int warmupLeft = Consts::WARMUP_SEEDS;

    if(gid& lt; N& amp;& amp; d_ok_for_vote[gid])
    {
        float3 n = d_norm_tri[gid];
        // force hemisfeer-consistentie (optioneel): maak z>=0 b.v.
        if(n.z& lt; 0.f)
        {
            n.x = -n.x;
            n.y = -n.y;
            n.z = -n.z;
        }
        n = norm3f(n);

        // stem op n
        __syncthreads();
        int idx = lru - > add_or_bump(n, warmupLeft);
        __syncthreads();

        // orthogonale partner bump
        if(idx& gt; = 0)
        {
#pragma unroll
            for(int i = 0; i & lt; K; i++)
            {
                if(!lru - & gt; items[i].used) continue;
                if(i == idx) continue;
                if(fabsf(dot3f(lru - > items[i].dir, n)) & lt; = Consts::ORTHO_COS_MAX)
                {
                    lru - > bump_and_bubble(i);
                    break; // √©√©n partner is genoeg
                }
            }
        }

        // warmup cross-product (max 2 tegen top slots)
        if(warmupLeft& gt; 0)
        {
            // top 2
            for(int t = 0; t & lt; 2 & amp; &t & lt; K; ++t)
            {
                if(!lru - & gt; items[t].used) continue;
                float c = fabsf(dot3f(lru - > items[t].dir, n));
                if(c& lt; = Consts::ORTHO_COS_MAX)
                {
                    float3 v = norm3f(cross3f(n, lru - > items[t].dir));
                    if(len3f(v) & gt; 0.5f)
                    {
                        // voeg toe als niet gelijk
                        int sim = lru - > find_similar(v);
                        if(sim& lt; 0) lru - > add_or_bump(v, warmupLeft);
                    }
                }
            }
            atomicSub(&warmupLeft, 1);
        }
    }
    __syncthreads();

    // schrijf block-winnaars (top M)
    if(threadIdx.x == 0)
    {
        const int base = blockIdx.x * maxWinnersPerBlock;
        const int M    = (maxWinnersPerBlock & lt; K ? maxWinnersPerBlock : K);
        for(int m = 0; m & lt; M; m++)
        {
            d_block_winners[base + m] = lru - > items[m].used ? lru - > items[m].dir : make_float3(0, 0, 0);
        }
    }
}

// explicit instantiation
extern "C" void launch_direction_vote_bdrm(const float3* d_norms, const uint8_t* d_voteMask, int N,
                                           float3* d_blockWinners, int maxWinnersPerBlock, cudaStream_t stream,
                                           int* gridOut, int* blockOut)
{
    const int block = 256;
    const int grid  = (N + block - 1) / block;
    size_t    sh    = sizeof(LruBlock<Consts::LRU_SLOTS>);
    k_direction_vote_bdrm<Consts::LRU_SLOTS>
        <<<grid, block, sh, stream>>>(d_norms, d_voteMask, N, d_blockWinners, maxWinnersPerBlock);
    if(gridOut) *gridOut = grid;
    if(blockOut) *blockOut = block;
}
FILE_END
FILE_BEGIN src/k_otndc.cu
#include "otndc.h"
#include <cuda_runtime.h>
#include <math___constant__s.h>

////////////////////////////////////////////////////////////////////////////////
// __device__ helpers
////////////////////////////////////////////////////////////////////////////////
__device__ __forceinline__ float3 norm3(float3 v)
{
    float l = rsqrtf(v.x * v.x + v.y * v.y + v.z * v.z + 1e-20f);
    return make_float3(v.x * l, v.y * l, v.z * l);
}

__device__ __forceinline__ float dot3(float3 a, float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

__device__ __forceinline__ float3 cross3(float3 a, float3 b)
{
    return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

////////////////////////////////////////////////////////////////////////////////
// kernel: generate stralen voor boeren-ring + slot vote
////////////////////////////////////////////////////////////////////////////////
__global__ void k_oTNDCRays(const float* __restrict__ x, const float* __restrict__ y, const float* __restrict__ z,
                            int N, OTSlot* slots, int maxSlots, float binnen2, float buiten2, float minHoekCos)
{
    // per punt ‚Üí straal
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;

    float3 p  = make_float3(x[i], y[i], z[i]);
    float  r2 = dot3(p, p);

    // ring filter
    if(r2 < binnen2 || r2 > buiten2) return;

    float3 v = norm3(p);

    // warm-up cross bootstrap (met vorige in warp)
    // simpel: only with thread-1 if exists
    if(threadIdx.x > 0)
    {
        float3 vp = v; // current
        // but we need 3 floats: do it properly
        float  px    = __shfl_up_sync(0xffffffff, v.x, 1);
        float  py    = __shfl_up_sync(0xffffffff, v.y, 1);
        float  pz    = __shfl_up_sync(0xffffffff, v.z, 1);
        float3 vprev = make_float3(px, py, pz);

        float dp = fabsf(dot3(vp, vprev));
        if(dp < minHoekCos)
        {
            float3 cr = norm3(cross3(vp, vprev));
            // vote cross to slot 0 always during warmup
            atomicAdd(&slots[0].som.x, cr.x);
            atomicAdd(&slots[0].som.y, cr.y);
            atomicAdd(&slots[0].som.z, cr.z);
            atomicAdd(&slots[0].count, 1);
        }
    }

    // vote v to best slot or empty slot
    int   best    = -1;
    float bestDot = 0.f;

    for(int s = 0; s < maxSlots; ++s)
    {
        int c = slots[s].count;
        if(c == 0)
        {
            best = s;
            break;
        }
        float3 acc = slots[s].som;
        float3 dir = norm3(acc);
        float  d   = fabsf(dot3(v, dir));
        if(d > bestDot)
        {
            bestDot = d;
            best    = s;
        }
    }
    if(best < 0) return;

    atomicAdd(&slots[best].som.x, v.x);
    atomicAdd(&slots[best].som.y, v.y);
    atomicAdd(&slots[best].som.z, v.z);
    atomicAdd(&slots[best].count, 1);
}
FILE_END
FILE_BEGIN src/h_orchestratie.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cmath>
#include "include/config.h"
#include "include/wiskunde_utils.cuh"

// Helper
static inline float clampf(float x, float a, float b) {
    return std::max(a, std::min(b, x));
}

// ------------------------------------------------------------
// __host__ visuele check ‚Äî rotatie-voorspeller
// ------------------------------------------------------------
namespace __host__vis {

static inline void print_frame_nudge_preview(const Vec3f& asX,
                                             const Vec3f& asY,
                                             const Vec3f& asZ)
{
    Vec3f Z{0,0,1};
    Vec3f v = cross(Z, asZ);
    float c = dot(Z, asZ);
    float ang = std::acos( std::clamp(c, -1.0f, 1.0f) );
    Quat qz = (std::fabs(ang) < 1e-6f) ? Quat{1,0,0,0}
                                      : quat_from_axis_angle(v, ang);

    Vec3f X{1,0,0};
    Vec3f Xp = quat_rotate(qz, X);
    Vec3f t  = cross(Xp, asX);
    float c2 = dot(Xp, asX);
    float ang2 = std::acos( std::clamp(c2, -1.0f, 1.0f) );
    Quat qx = (std::fabs(ang2) < 1e-6f) ? Quat{1,0,0,0}
                                       : quat_from_axis_angle(t, ang2);

    Quat q = quat_mul(qx, qz);

    float yawDeg=0.f, pitchDeg=0.f;
    quat_to_ZY_angles(q, yawDeg, pitchDeg);

    float clip = cfg::get().stemmen.clipKleinGraads;
    clip_small_degrees(clip, yawDeg);
    clip_small_degrees(clip, pitchDeg);

    float maxLock = cfg::get().stemmen.maxLockGraads;
    bool reject   = (std::fabs(yawDeg) > maxLock ||
                     std::fabs(pitchDeg) > maxLock);

    std::cout << "[FrameCheck] Rotaties (Z,Y): yaw="
              << yawDeg << "¬∞, pitch=" << pitchDeg << "¬∞";
    if (reject) {
        std::cout << " [REJECT >" << maxLock << "¬∞]";
    }
    std::cout << "\n";
}

} // namespace __host__vis

// ------------------------------------------------------------
// Struct for logging
// ------------------------------------------------------------
struct StatBlok {
    uint32_t hitsTotaal   = 0;
    uint32_t hitsNieuw    = 0;
    uint32_t nearCount    = 0;
    uint32_t okCount      = 0;
    uint32_t slotCount    = 0;
    float    dHoekDeg     = 0.f;
    float    varCos       = 0.f;
    bool     locked       = false;
};

static inline void log_status(const StatBlok& s)
{
    std::cout << "hits+=" << s.hitsNieuw
              << " total=" << s.hitsTotaal
              << " near=" << s.nearCount
              << " ok=" << s.okCount
              << " slots=" << s.slotCount
              << " dHoek=" << std::fixed << std::setprecision(2)
              << s.dHoekDeg << "¬∞"
              << " varCos=" << std::setprecision(4) << s.varCos
              << " " << (s.locked ? "LOCKED" : "-")
              << std::endl;
}

// ------------------------------------------------------------
// Dummy orchestration loop ‚Äî compiles now
// When real __device__ stats exist, replace dummy block
// ------------------------------------------------------------
void h_run_orchestratie_logging_loop()
{
    StatBlok acc;
    uint32_t intervalHits = 0;

    // Dummy loop just once for test
    {
        uint32_t newlyAccepted = ORCH_LOG_INTERVAL;
        uint32_t nearIn        = ORCH_LOG_INTERVAL * 3 / 4;
        uint32_t okIn          = ORCH_LOG_INTERVAL * 1 / 4;
        uint32_t activeSlots   = 3;
        float dHoekDegSample   = 0.18f;
        float varCosSample     = 0.0017f;
        bool lockedNow         = true;

        intervalHits       += newlyAccepted;
        acc.hitsTotaal     += newlyAccepted;
        acc.nearCount      += nearIn;
        acc.okCount        += okIn;
        acc.slotCount       = activeSlots;
        acc.dHoekDeg        = dHoekDegSample;
        acc.varCos          = varCosSample;
        acc.locked          = lockedNow;
        acc.hitsNieuw       = intervalHits;

        log_status(acc);

        // ==== FINAL axes preview ====
        // üî• Dit is nu gewoon identity frame
        Vec3f asX{1,0,0}, asY{0,1,0}, asZ{0,0,1};
        __host__vis::print_frame_nudge_preview(asX, asY, asZ);
    }
}
FILE_END
FILE_BEGIN src/k_rotatie_quat.cu
#include "config.h"
#include "types.h"
#include "wiskunde_utils.cuh"
#include <cuda_runtime.h>

__device__ __forceinline__ Vec3f d_quat_apply(const Quatf& q, const Vec3f& v)
{
    Vec3f qv = make_vec3f(q.x, q.y, q.z);
    Vec3f t  = mul(cross(qv, v), 2.0f);
    Vec3f vp = v + mul(t, q.w) + mul(cross(qv, t), 1.0f);
    return vp;
}

__global__ void k_rotate_quat(const Quatf q, Vec3f* punten, const u8* mask, u32 N)
{
    u32 i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;
    if(mask && mask[i] == 0) return;
    punten[i] = d_quat_apply(q, punten[i]);
}

extern "C" void k_rotatie_quat_launch(const Quatf& q_norm, Vec3f* d_punten, const u8* d_mask, u32 N)
{
    if(!d_punten || N == 0) return;
    dim3 bs(256), gs((N + bs.x - 1) / bs.x);
    k_rotate_quat<<<gs, bs>>>(q_norm, d_punten, d_mask, N);
    cudaDeviceSynchronize();
}
FILE_END
FILE_BEGIN src/k_pairs_bucket.cu
#include "pairs_bucket.cuh"
#include <math___constant__s.h>

// ============ __device__ helpers ============
__device__ __forceinline__ float3 make3(float x, float y, float z) { return make_float3(x, y, z); }
__device__ __forceinline__ float  dot3(float3 a, float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__device__ __forceinline__ float3 cross3(float3 a, float3 b)
{
    return make3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
__device__ __forceinline__ float3 norm3(float3 v)
{
    float n2 = v.x * v.x + v.y * v.y + v.z * v.z;
    if(n2 < 1e-20f) return make3(0, 0, 0);
    float inv = rsqrtf(n2);
    return make3(v.x * inv, v.y * inv, v.z * inv);
}

// ============ kernel ============
// Per punt -> straal (v). In gedeeld geheugen een tile.
// Voor elk v: zoek binnen +- partnerZoekRadius in de tile 1 partner u
// met |dot(v,u)| <= maxDotOrtho; kies de beste (kleinste |dot|).
// Voeg a = normalize(cross(v,u)) bij aan globale accumulator met gewicht sin(theta).
extern "C" __global__ void k_otndc_pairs(const float* __restrict__ x, const float* __restrict__ y,
                                         const float* __restrict__ z, int N, float binnen2, float buiten2,
                                         float maxDotOrtho, int partnerZoekRadius, OTAsAccu* __restrict__ gAccu)
{
    extern __shared__ float sMem[]; // layout: vx[], vy[], vz[]
    float*                  sx = sMem;
    float*                  sy = sx + blockDim.x;
    float*                  sz = sy + blockDim.x;

    const int gid = blockIdx.x * blockDim.x + threadIdx.x;

    // Laad tile stralen (met ringfilter)
    float3 v = make3(0, 0, 0);
    if(gid < N)
    {
        float3 p  = make3(x[gid], y[gid], z[gid]);
        float  r2 = dot3(p, p);
        if(r2 >= binnen2 && r2 <= buiten2)
        {
            v = norm3(p); // straal = genormaliseerde plaatsvector
        }
    }
    sx[threadIdx.x] = v.x;
    sy[threadIdx.x] = v.y;
    sz[threadIdx.x] = v.z;
    __syncthreads();

    // Zoek √©√©n partner in de tile
    if(gid >= N) return;
    if(v.x == 0.f && v.y == 0.f && v.z == 0.f) return; // buiten ring

    float  bestAbsDot = 1e9f;
    float3 bestU      = make3(0, 0, 0);

    // Zoek rondom huidige thread (beperkt venster)
    const int t = threadIdx.x;
    const int L = max(0, t - partnerZoekRadius);
    const int R = min(blockDim.x - 1, t + partnerZoekRadius);

    for(int j = L; j <= R; ++j)
    {
        if(j == t) continue;
        float3 u = make3(sx[j], sy[j], sz[j]);
        if(u.x == 0.f && u.y == 0.f && u.z == 0.f) continue;

        float d = fabsf(dot3(v, u)); // |cos theta|
        if(d <= maxDotOrtho && d < bestAbsDot)
        {
            bestAbsDot = d;
            bestU      = u;
        }
    }

    if(bestAbsDot == 1e9f) return; // geen geschikte partner

    // Kruisproduct ‚Üí as-sample
    float3 a  = cross3(v, bestU);
    float  a2 = dot3(a, a);
    if(a2 < 1e-20f) return;
    float inv = rsqrtf(a2);
    a.x *= inv;
    a.y *= inv;
    a.z *= inv;

    // Gewicht: sin(theta) = sqrt(1 - cos^2)
    float w = sqrtf(fmaxf(0.f, 1.f - bestAbsDot * bestAbsDot));

    // Atomics naar globale accu
    atomicAdd(&gAccu->som.x, a.x * w);
    atomicAdd(&gAccu->som.y, a.y * w);
    atomicAdd(&gAccu->som.z, a.z * w);
    atomicAdd(&gAccu->count, 1);
}
FILE_END
FILE_BEGIN src/k_r1r2_filter.cu
#include "consts.cuh"
#include "types.cuh"
#include <cuda_runtime.h>

/*
k_r1r2_filter
-------------

In:  d_pts (Vec3f*), N
Out: d_mask_tri (uint8*)  : 1 = mini-triangle kandidaat (exclusief), 0 anders
d_norm_tri (float3*) : normale van (c,a,b) indien mask==1
d_inlier_slab (int*) : aantal slab-inliers binnen r2 (voor chaos veto)
d_is_chaos (uint8*)  : 1 = chaos, 0 = ok
NB: eenvoudige implementatie: per punt c zoeken we 2 dichtste in ring [r1‚Ä¶r2], dan exclusiviteitscheck.

ASCII:
r2
.-----.
/       \    ring [r1..r2], kies 2 dichtste {a,b}, check max(|c-a|,|c-b|) <= r2/2 - 1mm
|    c    |
\       /
'-----'
r1
*/

__device__ inline float3 make3(const Vec3f& p) { return make_float3(p.x, p.y, p.z); }
__device__ inline float  dot3(const float3 a, const float3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
__device__ inline float3 cross3(const float3 a, const float3 b)
{
    return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
__device__ inline float  len3(const float3 v) { return sqrtf(dot3(v, v)); }
__device__ inline float3 norm3(const float3 v)
{
    float L = len3(v);
    return (L > 0) ? make_float3(v.x / L, v.y / L, v.z / L) : make_float3(0, 0, 0);
}

__global__ void k_r1r2_filter(const Vec3f*** restrict** d_pts, int N, uint8_t*** restrict** d_mask_tri,
                              float3*** restrict** d_norm_tri, int*** restrict** d_inlier_slab,
                              uint8_t*** restrict** d_is_chaos)
{
    const int i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i >= N) return;

    const float r1      = Consts::R1_CLUSTER;
    const float r2      = Consts::R2_RING;
    const float r2h     = Consts::R2_HALF_CLAIM_SAFE;
    const float slabTol = Consts::SLAB_TOL;

    const float3 c = make3(d_pts[i]);

    // eenvoudig: brute buurt (N) ‚Äî in praktijk: per tile/voxel buurtlijst
    // DEMO: we gaan lineair door (kan later getiled worden)
    float best1 = 1e9f, best2 = 1e9f;
    int   ia = -1, ib = -1;

    for(int j = 0; j & lt; N; j++)
    {
        if(j == i) continue;
        const float3 q = make3(d_pts[j]);
        float        d = len3(make_float3(q.x - c.x, q.y - c.y, q.z - c.z));
        if(d& lt; r1 - Consts::LIDAR_HALF_ERROR) continue;
        if(d& gt; r2 + Consts::LIDAR_HALF_ERROR) continue;

        if(d& lt; best1)
        {
            best2 = best1;
            ib    = ia;
            best1 = d;
            ia    = j;
        } else if(d& lt; best2)
        {
            best2 = d;
            ib    = j;
        }
    }

    // init outputs
    d_mask_tri[i]    = 0;
    d_is_chaos[i]    = 0;
    d_inlier_slab[i] = 0;
    d_norm_tri[i]    = make_float3(0, 0, 0);

    // slab inliers quick check (vlak vs chaos)
    int slabCnt = 0;
    if(ia& gt; = 0 & amp; &ib& gt; = 0)
    {
        // normale van driehoek (c,a,b)
        const float3 a = make3(d_pts[ia]);
        const float3 b = make3(d_pts[ib]);
        const float3 n =
            norm3(cross3(make_float3(a.x - c.x, a.y - c.y, a.z - c.z), make_float3(b.x - c.x, b.y - c.y, b.z - c.z)));

        // slab door c met normaal n: |dot(n, p-c)| <= slabTol
        for(int j = 0; j & lt; N; j++)
        {
            float3 q  = make3(d_pts[j]);
            float3 qc = make_float3(q.x - c.x, q.y - c.y, q.z - c.z);
            float  ad = fabsf(dot3(n, qc));
            if(ad& lt; = slabTol) slabCnt++;
        }

        d_inlier_slab[i] = slabCnt;

        // exclusiviteitscheck
        const bool triOk = (best1& lt; = r2h) & amp;
        &(best2 & lt; = r2h);
        if(triOk)
        {
            d_mask_tri[i] = 1;
            d_norm_tri[i] = n;
        }
    }

    // chaos veto
    // cheap 8mm-range + inliers<4
    // (range berekenen: hier approximatie via min/max in X/Y/Z; demo: subsample)
    if(slabCnt& lt; = Consts::SLAB_MIN_INLIERS - 1)
    {
        // heuristische cheap-check: markeer chaos indien geen triangle en weinig slab-inliers
        if(!d_mask_tri[i]) d_is_chaos[i] = 1;
    }
}
FILE_END
FILE_BEGIN src/demo/demo_orchestratie_main.cpp
#include <iostream>
#include <vector>
#include <cuda_runtime.h>
#include "orchestratie.h"
#include "types.h"

template <typename T>
static T* gpu_malloc_copy(const std::vector<T>& h){
T* d=nullptr;
cudaMalloc(&d, h.size()*sizeof(T));
if(!h.empty()) cudaMemcpy(d, h.data(), h.size()*sizeof(T), cudaMemcpyHostToDevice);
return d;
}

int main()
{
// Demo: lege stub ‚Äî in de echte plugin geef jij d_punten/d_mask/d_labels door.
std::vector<Vec3f> h_pts; // vul met jouw cloud
u32 N = (u32)h_pts.size();


Vec3f* d_punten = gpu_malloc_copy(h_pts);
u8* d_mask=nullptr;  // alles actief
PuntLabel* d_labels=nullptr;
cudaMalloc(&d_labels, N*sizeof(PuntLabel));
cudaMemset(d_labels, 0, N*sizeof(PuntLabel));

OrkestratieParams p;
FrameStatus frame;
DiscoverLog log;

bool ok = h_vind_ideaal_frame(d_punten, N, d_mask, d_labels, p, frame, log);
if(!ok){
    std::cout << "[demo] geen ideaal frame gevonden: " << log.verslag << "\n";
    return 0;
}
h_print_frame(frame);

h_rotatie_naar_ideaal(d_punten, N, frame);

h_fine_labeling(d_punten, N, d_labels, frame, p);

cudaFree(d_punten);
cudaFree(d_labels);
std::cout << "[demo] klaar.\n";
return 0;


}
FILE_END
FILE_BEGIN src/demo/demo_axis.cpp
#include "otndc.h"
#include <iostream>
#include <vector>
#include <cmath>

// Dummy test: points on X axis + some noise
int main(){
    int N = 100000;
    std::vector<float> x(N),y(N),z(N);
    for(int i=0;i<N;i++){
        float t = (float)i/N * 100.0f;
        x[i]=t;
        y[i]=0.002f*sin(t);
        z[i]=0.002f*cos(t);
    }

    OTConfig cfg;
    cfg.binnenStraal2 = 0.01f*0.01f; // 1cm
    cfg.buitenStraal2 = 3.0f*3.0f;   // 3m
    cfg.minHoekCos = 0.94f;          // ~20¬∞
    cfg.warmupMin = 50;
    cfg.maxSlots = 16;

    AssenResultaat out;
    runOTNDC(x.data(),y.data(),z.data(),N,&out,cfg);

    std::cout<<"Dimensie: "<<out.dimensie<<"\n";
    for(int i=0;i<out.dimensie;i++){
        std::cout<<"As "<<i<<": "<<out.v[i][0]<<","<<out.v[i][1]<<","<<out.v[i][2]
                 <<" score="<<out.score[i]<<"\n";
    }
}
FILE_END
FILE_BEGIN src/demo/demo_axis2.cpp
#include "otndc.h"
#include <vector>
#include <iostream>
#include <cmath>
#include <random>

// Synthetische test: cilinder rond X-as (asrichting moet ~ (1,0,0) worden).
int main(){
    const int turns = 2000;     // aantal "ringen" langs x
    const float lengte = 5.0f;  // 5 m
    const float r = 0.10f;      // 10 cm
    const float sigma = 0.003f; // 3 mm jitter
    const int perRing = 256;    // punten per ring

    const int N = turns * perRing;
    std::vector<float> x(N), y(N), z(N);

    std::mt19937 rng(42);
    std::normal_distribution<float> noise(0.0f, sigma);

    for(int i=0;i<turns;i++){
        float t = (float)i/(turns-1);
        float X = -lengte*0.5f + t * lengte;
        for(int k=0;k<perRing;k++){
            float ang = (2.0f*float(M_PI))* (float)k / (float)perRing;
            int idx = i*perRing + k;
            x[idx] = X + noise(rng)*0.1f; // klein
            y[idx] = r*std::cos(ang) + noise(rng);
            z[idx] = r*std::sin(ang) + noise(rng);
        }
    }

    OTConfig cfg{};
    // Ring (we gebruiken hele cloud; zet ring ruim open zodat alles meedoet)
    cfg.binnenStraal2 = 0.0f;
    cfg.buitenStraal2 = (lengte*lengte + 4*r*r)*2.0f; // ruime bovengrens

    // Orthogonaliteit (>=~20¬∞): |dot| <= cos(70¬∞) ‚âà 0.342
    cfg.maxDotOrtho = 0.35f;

    cfg.warmupMin = 100;     // min stemmen om richting te accepteren
    cfg.blokGrootte = 256;
    cfg.partnerZoekRadius = 32;

    AssenResultaat out{};
    runOTNDC_pairs(x.data(), y.data(), z.data(), N, &out, cfg);

    std::cout<<"Dimensie: "<<out.dimensie<<"\n";
    if(out.dimensie>=1){
        std::cout<<"As 0: "<<out.v[0][0]<<","<<out.v[0][1]<<","<<out.v[0][2]
                 <<"  score="<<out.score[0]<<"\n";
    }
    return 0;
}
FILE_END
